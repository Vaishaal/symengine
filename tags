!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
A	benchmarks/lwbench.cpp	/^double A()$/;"	f
A	benchmarks/lwbench_ginac.cpp	/^double A()$/;"	f
A	build/cmake/checkcxx11.cpp	/^class A {$/;"	c	file:
A	cmake/checkcxx11.cpp	/^class A {$/;"	c	file:
ABORT	symengine/parser/parserbase.h	/^inline void ParserBase::ABORT() const$/;"	f	class:SymEngine::ParserBase
ACCEPT	symengine/eval_double.cpp	/^#define ACCEPT(/;"	d	file:
ACCEPT	symengine/parser/parserbase.h	/^inline void ParserBase::ACCEPT() const$/;"	f	class:SymEngine::ParserBase
ACCEPT	symengine/visitor.cpp	/^#define ACCEPT(/;"	d	file:
ACos	symengine/functions.cpp	/^ACos::ACos(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ACos
ACos	symengine/functions.h	/^class ACos : public InverseTrigFunction$/;"	c	namespace:SymEngine
ACosh	symengine/functions.cpp	/^ACosh::ACosh(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ACosh
ACosh	symengine/functions.h	/^class ACosh : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
ACot	symengine/functions.cpp	/^ACot::ACot(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ACot
ACot	symengine/functions.h	/^class ACot : public InverseTrigFunction$/;"	c	namespace:SymEngine
ACoth	symengine/functions.cpp	/^ACoth::ACoth(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ACoth
ACoth	symengine/functions.h	/^class ACoth : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
ACsc	symengine/functions.cpp	/^ACsc::ACsc(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ACsc
ACsc	symengine/functions.h	/^class ACsc : public InverseTrigFunction$/;"	c	namespace:SymEngine
ACsch	symengine/functions.cpp	/^ACsch::ACsch(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ACsch
ACsch	symengine/functions.h	/^class ACsch : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
ALLSPHINXOPTS	doc/Makefile	/^ALLSPHINXOPTS   = -d $(BUILDDIR)\/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .$/;"	m
AND_THEN	symengine/utilities/catch/catch.hpp	/^#define AND_THEN(/;"	d
AND_WHEN	symengine/utilities/catch/catch.hpp	/^#define AND_WHEN(/;"	d
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#   define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define ARCHITECTURE_ID$/;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define ARCHITECTURE_ID /;"	d	file:
ARCHITECTURE_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define ARCHITECTURE_ID$/;"	d	file:
ASec	symengine/functions.cpp	/^ASec::ASec(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ASec
ASec	symengine/functions.h	/^class ASec : public InverseTrigFunction$/;"	c	namespace:SymEngine
ASech	symengine/functions.cpp	/^ASech::ASech(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ASech
ASech	symengine/functions.h	/^class ASech : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
ASin	symengine/functions.cpp	/^ASin::ASin(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ASin
ASin	symengine/functions.h	/^class ASin : public InverseTrigFunction$/;"	c	namespace:SymEngine
ASinh	symengine/functions.cpp	/^ASinh::ASinh(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ASinh
ASinh	symengine/functions.h	/^class ASinh : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
AT_EOF	symengine/parser/scannerbase.h	/^    enum { AT_EOF = -1 };$/;"	e	enum:SymEngine::ScannerBase::__anon27
AT_EOF	symengine/parser/scannerbase.h	/^    enum { AT_EOF = -1 };$/;"	e	enum:SymEngine::ScannerBase::__anon6
ATan	symengine/functions.cpp	/^ATan::ATan(const RCP<const Basic> &arg) : InverseTrigFunction(arg)$/;"	f	class:SymEngine::ATan
ATan	symengine/functions.h	/^class ATan : public InverseTrigFunction$/;"	c	namespace:SymEngine
ATan2	symengine/functions.cpp	/^ATan2::ATan2(const RCP<const Basic> &num, const RCP<const Basic> &den)$/;"	f	class:SymEngine::ATan2
ATan2	symengine/functions.h	/^class ATan2 : public TwoArgFunction$/;"	c	namespace:SymEngine
ATanh	symengine/functions.cpp	/^ATanh::ATanh(const RCP<const Basic> &arg) : InverseHyperbolicFunction(arg)$/;"	f	class:SymEngine::ATanh
ATanh	symengine/functions.h	/^class ATanh : public InverseHyperbolicFunction$/;"	c	namespace:SymEngine
Abs	symengine/functions.cpp	/^Abs::Abs(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Abs
Abs	symengine/functions.h	/^class Abs : public OneArgFunction$/;"	c	namespace:SymEngine
ActionType__	symengine/parser/scannerbase.h	/^    enum class ActionType__ {$/;"	c	class:SymEngine::ScannerBase
ActiveRCPNodesSetup	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^ActiveRCPNodesSetup::ActiveRCPNodesSetup()$/;"	f	class:Teuchos::ActiveRCPNodesSetup
ActiveRCPNodesSetup	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT ActiveRCPNodesSetup {$/;"	c	namespace:Teuchos
Add	symengine/add.cpp	/^Add::Add(const RCP<const Number> &coef, umap_basic_num &&dict)$/;"	f	class:SymEngine::Add
Add	symengine/add.h	/^class Add : public Basic$/;"	c	namespace:SymEngine
Add	symengine/printers/strprinter.h	/^enum class PrecedenceEnum { Relational, Add, Mul, Pow, Atom };$/;"	m	class:SymEngine::PrecedenceEnum
AllOf	symengine/utilities/catch/catch.hpp	/^    Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {$/;"	f	namespace:Catch::Matchers
AllOf	symengine/utilities/catch/catch.hpp	/^    Impl::MatchAllOf<T> AllOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {$/;"	f	namespace:Catch::Matchers
And	symengine/logic.cpp	/^And::And(const set_boolean &s) : container_{s}$/;"	f	class:SymEngine::And
And	symengine/logic.h	/^class And : public Boolean$/;"	c	namespace:SymEngine
AnyOf	symengine/utilities/catch/catch.hpp	/^    Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2 ) {$/;"	f	namespace:Catch::Matchers
AnyOf	symengine/utilities/catch/catch.hpp	/^    Impl::MatchAnyOf<T> AnyOf( Impl::MatcherBase<T> const& m1, Impl::MatcherBase<T> const& m2, Impl::MatcherBase<T> const& m3 ) {$/;"	f	namespace:Catch::Matchers
AssertionInfo	symengine/utilities/catch/catch.hpp	/^    struct AssertionInfo$/;"	s	namespace:Catch
AssertionResult	symengine/utilities/catch/catch.hpp	/^    class AssertionResult {$/;"	c	namespace:Catch
AssertionResultData	symengine/utilities/catch/catch.hpp	/^        AssertionResultData() : decomposedExpression( CATCH_NULL )$/;"	f	struct:Catch::AssertionResultData
AssertionResultData	symengine/utilities/catch/catch.hpp	/^    struct AssertionResultData$/;"	s	namespace:Catch
Assign	symengine/parser/parserbase.h	/^struct Assign<false, SType> {$/;"	s	namespace:SymEngine::Meta__
Assign	symengine/parser/parserbase.h	/^struct Assign<false, Tp_> {$/;"	s	namespace:SymEngine::Meta__
Assign	symengine/parser/parserbase.h	/^struct Assign<true, Tp_> {$/;"	s	namespace:SymEngine::Meta__
AtomsVisitor	symengine/visitor.h	/^class AtomsVisitor : public BaseVisitor<AtomsVisitor<Args...>>$/;"	c	namespace:SymEngine
AutoReg	symengine/utilities/catch/catch.hpp	/^    AutoReg$/;"	f	struct:Catch::AutoReg
AutoReg	symengine/utilities/catch/catch.hpp	/^struct AutoReg {$/;"	s	namespace:Catch
B	benchmarks/lwbench.cpp	/^double B()$/;"	f
B	benchmarks/lwbench_ginac.cpp	/^double B()$/;"	f
B	build/cmake/checkcxx11.cpp	/^class B : public A {$/;"	c	file:
B	cmake/checkcxx11.cpp	/^class B : public A {$/;"	c	file:
BUILDDIR	doc/Makefile	/^BUILDDIR      = _build$/;"	m
Base	symengine/parser/parserbase.h	/^class Base$/;"	c	namespace:SymEngine::Meta__
Base	symengine/parser/parserbase.h	/^inline Base::Base(Tag__ tag) : d_tag(tag)$/;"	f	class:SymEngine::Meta__::Base
BaseVisitor	symengine/visitor.h	/^    BaseVisitor() : Base()$/;"	f	class:SymEngine::BaseVisitor
BaseVisitor	symengine/visitor.h	/^    BaseVisitor(Args &&... args) : Base(std::forward<Args>(args)...)$/;"	f	class:SymEngine::BaseVisitor
BaseVisitor	symengine/visitor.h	/^class BaseVisitor : public Base$/;"	c	namespace:SymEngine
Basic	symengine/basic.h	/^    Basic() : hash_{0}$/;"	f	class:SymEngine::Basic
Basic	symengine/basic.h	/^class Basic : public EnableRCPFromThis<Basic>$/;"	c	namespace:SymEngine
BasicToMExprPoly	symengine/polys/basic_conversions.h	/^    BasicToMExprPoly(const set_basic &gens) : BasicToMPolyBase(gens)$/;"	f	class:SymEngine::BasicToMExprPoly
BasicToMExprPoly	symengine/polys/basic_conversions.h	/^class BasicToMExprPoly : public BasicToMPolyBase<MExprPoly, BasicToMExprPoly>$/;"	c	namespace:SymEngine
BasicToMIntPoly	symengine/polys/basic_conversions.h	/^    BasicToMIntPoly(const set_basic &gens) : BasicToMPolyBase(gens)$/;"	f	class:SymEngine::BasicToMIntPoly
BasicToMIntPoly	symengine/polys/basic_conversions.h	/^class BasicToMIntPoly : public BasicToMPolyBase<MIntPoly, BasicToMIntPoly>$/;"	c	namespace:SymEngine
BasicToMPolyBase	symengine/polys/basic_conversions.h	/^    BasicToMPolyBase(const set_basic &gens_)$/;"	f	class:SymEngine::BasicToMPolyBase
BasicToMPolyBase	symengine/polys/basic_conversions.h	/^class BasicToMPolyBase : public BaseVisitor<V>$/;"	c	namespace:SymEngine
BasicToUExprPoly	symengine/polys/basic_conversions.h	/^    BasicToUExprPoly(const RCP<const Basic> &gen) : BasicToUPolyBase(gen)$/;"	f	class:SymEngine::BasicToUExprPoly
BasicToUExprPoly	symengine/polys/basic_conversions.h	/^class BasicToUExprPoly : public BasicToUPolyBase<UExprPoly, BasicToUExprPoly>$/;"	c	namespace:SymEngine
BasicToUIntPoly	symengine/polys/basic_conversions.h	/^    BasicToUIntPoly(const RCP<const Basic> &gen)$/;"	f	class:SymEngine::BasicToUIntPoly
BasicToUIntPoly	symengine/polys/basic_conversions.h	/^class BasicToUIntPoly : public BasicToUPolyBase<Poly, BasicToUIntPoly<Poly>>$/;"	c	namespace:SymEngine
BasicToUPolyBase	symengine/polys/basic_conversions.h	/^    BasicToUPolyBase(const RCP<const Basic> &gen_)$/;"	f	class:SymEngine::BasicToUPolyBase
BasicToUPolyBase	symengine/polys/basic_conversions.h	/^class BasicToUPolyBase : public BaseVisitor<V>$/;"	c	namespace:SymEngine
BasicToURatPoly	symengine/polys/basic_conversions.h	/^    BasicToURatPoly(const RCP<const Basic> &gen)$/;"	f	class:SymEngine::BasicToURatPoly
BasicToURatPoly	symengine/polys/basic_conversions.h	/^class BasicToURatPoly : public BasicToUPolyBase<Poly, BasicToURatPoly<Poly>>$/;"	c	namespace:SymEngine
Beta	symengine/functions.h	/^    Beta(const RCP<const Basic> &x, const RCP<const Basic> &y)$/;"	f	class:SymEngine::Beta
Beta	symengine/functions.h	/^class Beta : public TwoArgFunction$/;"	c	namespace:SymEngine
Boolean	symengine/logic.h	/^class Boolean : public Basic$/;"	c	namespace:SymEngine
BooleanAtom	symengine/logic.cpp	/^BooleanAtom::BooleanAtom(bool b) : b_{b}$/;"	f	class:SymEngine::BooleanAtom
BooleanAtom	symengine/logic.h	/^class BooleanAtom : public Boolean$/;"	c	namespace:SymEngine
BorgType	symengine/utilities/catch/catch.hpp	/^    struct BorgType {$/;"	s	namespace:Catch::Detail
C	benchmarks/lwbench.cpp	/^double C()$/;"	f
C	benchmarks/lwbench_ginac.cpp	/^double C()$/;"	f
C0	symengine/constants.cpp	/^RCP<const Basic> C0 = div(sub(sq3, one), mul(i2, sq2));$/;"	m	namespace:SymEngine	file:
C1	symengine/constants.cpp	/^RCP<const Basic> C1 = div(one, i2);$/;"	m	namespace:SymEngine	file:
C2	symengine/constants.cpp	/^RCP<const Basic> C2 = div(sq2, i2);$/;"	m	namespace:SymEngine	file:
C3	symengine/constants.cpp	/^RCP<const Basic> C3 = div(sq3, i2);$/;"	m	namespace:SymEngine	file:
C4	symengine/constants.cpp	/^RCP<const Basic> C4 = div(add(sq3, one), mul(i2, sq2));$/;"	m	namespace:SymEngine	file:
C5	symengine/constants.cpp	/^RCP<const Basic> C5 = div(sqrt_(sub(i5, sqrt_(i5))), integer(8));$/;"	m	namespace:SymEngine	file:
C6	symengine/constants.cpp	/^RCP<const Basic> C6 = div(sub(sqrt_(i5), one), integer(4));$/;"	m	namespace:SymEngine	file:
C89CodePrinter	symengine/printers/codegen.h	/^class C89CodePrinter : public BaseVisitor<C89CodePrinter, CodePrinter>$/;"	c	namespace:SymEngine
C99CodePrinter	symengine/printers/codegen.h	/^class C99CodePrinter : public BaseVisitor<C99CodePrinter, C89CodePrinter>$/;"	c	namespace:SymEngine
CATCH_AND_THEN	symengine/utilities/catch/catch.hpp	/^#define CATCH_AND_THEN(/;"	d
CATCH_AND_WHEN	symengine/utilities/catch/catch.hpp	/^#define CATCH_AND_WHEN(/;"	d
CATCH_ANON_TEST_CASE	symengine/utilities/catch/catch.hpp	/^#define CATCH_ANON_TEST_CASE(/;"	d
CATCH_ARC_ENABLED	symengine/utilities/catch/catch.hpp	/^#define CATCH_ARC_ENABLED /;"	d
CATCH_ARC_STRONG	symengine/utilities/catch/catch.hpp	/^#define CATCH_ARC_STRONG /;"	d
CATCH_ARC_STRONG	symengine/utilities/catch/catch.hpp	/^#define CATCH_ARC_STRONG$/;"	d
CATCH_AUTO_PTR	symengine/utilities/catch/catch.hpp	/^#   define CATCH_AUTO_PTR(/;"	d
CATCH_BREAK_INTO_DEBUGGER	symengine/utilities/catch/catch.hpp	/^    #define CATCH_BREAK_INTO_DEBUGGER(/;"	d
CATCH_CAPTURE	symengine/utilities/catch/catch.hpp	/^#define CATCH_CAPTURE(/;"	d
CATCH_CHECK	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK(/;"	d
CATCH_CHECKED_ELSE	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECKED_ELSE(/;"	d
CATCH_CHECKED_IF	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECKED_IF(/;"	d
CATCH_CHECK_FALSE	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_FALSE(/;"	d
CATCH_CHECK_NOFAIL	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_NOFAIL(/;"	d
CATCH_CHECK_NOTHROW	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_NOTHROW(/;"	d
CATCH_CHECK_THAT	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_THAT(/;"	d
CATCH_CHECK_THROWS	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_THROWS(/;"	d
CATCH_CHECK_THROWS_AS	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_THROWS_AS(/;"	d
CATCH_CHECK_THROWS_WITH	symengine/utilities/catch/catch.hpp	/^#define CATCH_CHECK_THROWS_WITH(/;"	d
CATCH_CONFIG_COLOUR_NONE	symengine/utilities/catch/catch.hpp	/^#       define CATCH_CONFIG_COLOUR_NONE$/;"	d
CATCH_CONFIG_COLOUR_WINDOWS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_CONFIG_COLOUR_WINDOWS$/;"	d
CATCH_CONFIG_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#define CATCH_CONFIG_CONSOLE_WIDTH /;"	d
CATCH_CONFIG_COUNTER	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_COUNTER$/;"	d
CATCH_CONFIG_CPP11_GENERATED_METHODS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_CONFIG_CPP11_IS_ENUM	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_IS_ENUM$/;"	d
CATCH_CONFIG_CPP11_LONG_LONG	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_LONG_LONG$/;"	d
CATCH_CONFIG_CPP11_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_CONFIG_CPP11_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_OVERRIDE$/;"	d
CATCH_CONFIG_CPP11_SHUFFLE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_SHUFFLE$/;"	d
CATCH_CONFIG_CPP11_TUPLE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_TUPLE$/;"	d
CATCH_CONFIG_CPP11_TYPE_TRAITS	symengine/utilities/catch/catch.hpp	/^#  define CATCH_CONFIG_CPP11_TYPE_TRAITS$/;"	d
CATCH_CONFIG_CPP11_UNIQUE_PTR	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_CONFIG_DEFAULT_REPORTER	symengine/utilities/catch/catch.hpp	/^#define CATCH_CONFIG_DEFAULT_REPORTER /;"	d
CATCH_CONFIG_POSIX_SIGNALS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_POSIX_SIGNALS$/;"	d
CATCH_CONFIG_RUNNER	symengine/utilities/catch/catch.cpp	/^#define CATCH_CONFIG_RUNNER$/;"	d	file:
CATCH_CONFIG_SFINAE	symengine/utilities/catch/catch.cpp	/^#define CATCH_CONFIG_SFINAE$/;"	d	file:
CATCH_CONFIG_VARIADIC_MACROS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_CONFIG_WINDOWS_SEH	symengine/utilities/catch/catch.hpp	/^#   define CATCH_CONFIG_WINDOWS_SEH$/;"	d
CATCH_CPP11_OR_GREATER	symengine/utilities/catch/catch.hpp	/^#    define CATCH_CPP11_OR_GREATER$/;"	d
CATCH_CPP14_OR_GREATER	symengine/utilities/catch/catch.hpp	/^#    define CATCH_CPP14_OR_GREATER$/;"	d
CATCH_FAIL	symengine/utilities/catch/catch.hpp	/^    #define CATCH_FAIL(/;"	d
CATCH_FAIL_CHECK	symengine/utilities/catch/catch.hpp	/^    #define CATCH_FAIL_CHECK(/;"	d
CATCH_GENERATE	symengine/utilities/catch/catch.hpp	/^#define CATCH_GENERATE(/;"	d
CATCH_GIVEN	symengine/utilities/catch/catch.hpp	/^#define CATCH_GIVEN(/;"	d
CATCH_IMPL	symengine/utilities/catch/catch.hpp	/^#  define CATCH_IMPL$/;"	d
CATCH_INFO	symengine/utilities/catch/catch.hpp	/^#define CATCH_INFO(/;"	d
CATCH_INTERNAL_CONFIG_COUNTER	symengine/utilities/catch/catch.hpp	/^    #define CATCH_INTERNAL_CONFIG_COUNTER$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_IS_ENUM$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_LONG_LONG$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_OVERRIDE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_SHUFFLE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_TUPLE	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_TUPLE$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	symengine/utilities/catch/catch.hpp	/^#  define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_CPP11_TYPE_TRAITS$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_CONFIG_NO_POSIX_SIGNALS$/;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	symengine/utilities/catch/catch.hpp	/^#    define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_INTERNAL_CONFIG_VARIADIC_MACROS	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_VARIADIC_MACROS$/;"	d
CATCH_INTERNAL_CONFIG_WINDOWS_SEH	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_CONFIG_WINDOWS_SEH$/;"	d
CATCH_INTERNAL_ERROR	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_ERROR(/;"	d
CATCH_INTERNAL_LINEINFO	symengine/utilities/catch/catch.hpp	/^#define CATCH_INTERNAL_LINEINFO /;"	d
CATCH_INTERNAL_STRINGIFY	symengine/utilities/catch/catch.hpp	/^# define CATCH_INTERNAL_STRINGIFY(/;"	d
CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS /;"	d
CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_SUPPRESS_ETD_WARNINGS$/;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS /;"	d
CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_SUPPRESS_PARENTHESES_WARNINGS$/;"	d
CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS /;"	d
CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_UNSUPPRESS_ETD_WARNINGS$/;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	symengine/utilities/catch/catch.hpp	/^#       define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS /;"	d
CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS	symengine/utilities/catch/catch.hpp	/^#   define CATCH_INTERNAL_UNSUPPRESS_PARENTHESES_WARNINGS$/;"	d
CATCH_METHOD_AS_TEST_CASE	symengine/utilities/catch/catch.hpp	/^    #define CATCH_METHOD_AS_TEST_CASE(/;"	d
CATCH_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^        virtual const char* what() const CATCH_NOEXCEPT;$/;"	m	class:Catch::NotImplementedException
CATCH_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#  define CATCH_NOEXCEPT /;"	d
CATCH_NOEXCEPT_IS	symengine/utilities/catch/catch.hpp	/^#  define CATCH_NOEXCEPT_IS(/;"	d
CATCH_NOT_IMPLEMENTED	symengine/utilities/catch/catch.hpp	/^#define CATCH_NOT_IMPLEMENTED /;"	d
CATCH_NULL	symengine/utilities/catch/catch.hpp	/^#   define CATCH_NULL /;"	d
CATCH_OVERRIDE	symengine/utilities/catch/catch.hpp	/^        virtual void reconstructExpression( std::string& dest ) const CATCH_OVERRIDE;$/;"	m	class:Catch::ResultBuilder
CATCH_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_OVERRIDE /;"	d
CATCH_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#   define CATCH_OVERRIDE$/;"	d
CATCH_PLATFORM_MAC	symengine/utilities/catch/catch.hpp	/^#  define CATCH_PLATFORM_MAC$/;"	d
CATCH_REGISTER_LEGACY_REPORTER	symengine/utilities/catch/catch.hpp	/^#define CATCH_REGISTER_LEGACY_REPORTER(/;"	d
CATCH_REGISTER_LISTENER	symengine/utilities/catch/catch.hpp	/^#define CATCH_REGISTER_LISTENER(/;"	d
CATCH_REGISTER_REPORTER	symengine/utilities/catch/catch.hpp	/^#define CATCH_REGISTER_REPORTER(/;"	d
CATCH_REGISTER_TAG_ALIAS	symengine/utilities/catch/catch.hpp	/^#define CATCH_REGISTER_TAG_ALIAS(/;"	d
CATCH_REGISTER_TEST_CASE	symengine/utilities/catch/catch.hpp	/^    #define CATCH_REGISTER_TEST_CASE(/;"	d
CATCH_REQUIRE	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE(/;"	d
CATCH_REQUIRE_FALSE	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_FALSE(/;"	d
CATCH_REQUIRE_NOTHROW	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_NOTHROW(/;"	d
CATCH_REQUIRE_THAT	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_THAT(/;"	d
CATCH_REQUIRE_THROWS	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_THROWS(/;"	d
CATCH_REQUIRE_THROWS_AS	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_THROWS_AS(/;"	d
CATCH_REQUIRE_THROWS_WITH	symengine/utilities/catch/catch.hpp	/^#define CATCH_REQUIRE_THROWS_WITH(/;"	d
CATCH_SCENARIO	symengine/utilities/catch/catch.hpp	/^#define CATCH_SCENARIO(/;"	d
CATCH_SCENARIO_METHOD	symengine/utilities/catch/catch.hpp	/^#define CATCH_SCENARIO_METHOD(/;"	d
CATCH_SCOPED_CAPTURE	symengine/utilities/catch/catch.hpp	/^#define CATCH_SCOPED_CAPTURE(/;"	d
CATCH_SCOPED_INFO	symengine/utilities/catch/catch.hpp	/^#define CATCH_SCOPED_INFO(/;"	d
CATCH_SECTION	symengine/utilities/catch/catch.hpp	/^    #define CATCH_SECTION(/;"	d
CATCH_SUCCEED	symengine/utilities/catch/catch.hpp	/^    #define CATCH_SUCCEED(/;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#define CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH /;"	d
CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#undef CATCH_TEMP_CLARA_CONFIG_CONSOLE_WIDTH$/;"	d
CATCH_TEST_CASE	symengine/utilities/catch/catch.hpp	/^    #define CATCH_TEST_CASE(/;"	d
CATCH_TEST_CASE_METHOD	symengine/utilities/catch/catch.hpp	/^    #define CATCH_TEST_CASE_METHOD(/;"	d
CATCH_THEN	symengine/utilities/catch/catch.hpp	/^#define CATCH_THEN(/;"	d
CATCH_TRANSLATE_EXCEPTION	symengine/utilities/catch/catch.hpp	/^#define CATCH_TRANSLATE_EXCEPTION(/;"	d
CATCH_TRAP	symengine/utilities/catch/catch.hpp	/^        #define CATCH_TRAP(/;"	d
CATCH_UNSAFE_UNRETAINED	symengine/utilities/catch/catch.hpp	/^#define CATCH_UNSAFE_UNRETAINED /;"	d
CATCH_UNSAFE_UNRETAINED	symengine/utilities/catch/catch.hpp	/^#define CATCH_UNSAFE_UNRETAINED$/;"	d
CATCH_WARN	symengine/utilities/catch/catch.hpp	/^#define CATCH_WARN(/;"	d
CATCH_WHEN	symengine/utilities/catch/catch.hpp	/^#define CATCH_WHEN(/;"	d
CDenseMatrix	symengine/cwrapper.cpp	/^struct CDenseMatrix {$/;"	s	file:
CDenseMatrix	symengine/cwrapper.h	/^typedef struct CDenseMatrix CDenseMatrix;$/;"	t	typeref:struct:CDenseMatrix
CLARA_AUTO_PTR	symengine/utilities/catch/catch.hpp	/^#   define CLARA_AUTO_PTR(/;"	d
CLARA_CONFIG_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CONSOLE_WIDTH /;"	d
CLARA_CONFIG_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#undef CLARA_CONFIG_CONSOLE_WIDTH$/;"	d
CLARA_CONFIG_CPP11_GENERATED_METHODS	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CLARA_CONFIG_CPP11_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CPP11_NOEXCEPT$/;"	d
CLARA_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CPP11_NULLPTR$/;"	d
CLARA_CONFIG_CPP11_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CPP11_OVERRIDE$/;"	d
CLARA_CONFIG_CPP11_UNIQUE_PTR	symengine/utilities/catch/catch.hpp	/^#define CLARA_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CLARA_CONFIG_MAIN	symengine/utilities/catch/catch.hpp	/^#    define CLARA_CONFIG_MAIN$/;"	d
CLARA_CONFIG_MAIN	symengine/utilities/catch/catch.hpp	/^#  undef CLARA_CONFIG_MAIN$/;"	d
CLARA_CONFIG_MAIN_NOT_DEFINED	symengine/utilities/catch/catch.hpp	/^#    define CLARA_CONFIG_MAIN_NOT_DEFINED$/;"	d
CLARA_CPP11_OR_GREATER	symengine/utilities/catch/catch.hpp	/^#define CLARA_CPP11_OR_GREATER$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS	symengine/utilities/catch/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_GENERATED_METHODS$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_NOEXCEPT$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_NULLPTR	symengine/utilities/catch/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_NULLPTR$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_OVERRIDE$/;"	d
CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR	symengine/utilities/catch/catch.hpp	/^#define CLARA_INTERNAL_CONFIG_CPP11_UNIQUE_PTR$/;"	d
CLARA_NOEXCEPT	symengine/utilities/catch/catch.hpp	/^#define CLARA_NOEXCEPT /;"	d
CLARA_NOEXCEPT_IS	symengine/utilities/catch/catch.hpp	/^#  define CLARA_NOEXCEPT_IS(/;"	d
CLARA_NULL	symengine/utilities/catch/catch.hpp	/^#define CLARA_NULL /;"	d
CLARA_OVERRIDE	symengine/utilities/catch/catch.hpp	/^#define CLARA_OVERRIDE /;"	d
CLARA_PLATFORM_WINDOWS	symengine/utilities/catch/catch.hpp	/^#define CLARA_PLATFORM_WINDOWS$/;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#define CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE /;"	d
CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#undef CLICHE_TBC_TEXT_FORMAT_OUTER_NAMESPACE$/;"	d
CLLVMDoubleVisitor	symengine/cwrapper.cpp	/^struct CLLVMDoubleVisitor {$/;"	s	file:
CLLVMDoubleVisitor	symengine/cwrapper.h	/^typedef struct CLLVMDoubleVisitor CLLVMDoubleVisitor;$/;"	t	typeref:struct:CLLVMDoubleVisitor
CLambdaRealDoubleVisitor	symengine/cwrapper.cpp	/^struct CLambdaRealDoubleVisitor {$/;"	s	file:
CLambdaRealDoubleVisitor	symengine/cwrapper.h	/^typedef struct CLambdaRealDoubleVisitor CLambdaRealDoubleVisitor;$/;"	t	typeref:struct:CLambdaRealDoubleVisitor
CMAKE_BINARY_DIR	build/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/benchmarks/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/basic/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/cwrapper/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/eval/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/expression/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/finitediff/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/logic/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/matrix/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/ntheory/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/polynomial/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/printing/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/tests/rcp/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_BINARY_DIR	build/symengine/utilities/catch/Makefile	/^CMAKE_BINARY_DIR = \/Users\/vaishaal\/research\/symengine\/build$/;"	m
CMAKE_COMMAND	build/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/benchmarks/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/basic/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/cwrapper/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/eval/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/expression/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/finitediff/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/logic/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/matrix/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/ntheory/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/polynomial/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/printing/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/tests/rcp/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_COMMAND	build/symengine/utilities/catch/Makefile	/^CMAKE_COMMAND = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake$/;"	m
CMAKE_SOURCE_DIR	build/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/benchmarks/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/basic/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/cwrapper/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/eval/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/expression/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/finitediff/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/logic/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/matrix/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/ntheory/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/polynomial/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/printing/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/tests/rcp/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMAKE_SOURCE_DIR	build/symengine/utilities/catch/Makefile	/^CMAKE_SOURCE_DIR = \/Users\/vaishaal\/research\/symengine$/;"	m
CMapBasicBasic	symengine/cwrapper.cpp	/^struct CMapBasicBasic {$/;"	s	file:
CMapBasicBasic	symengine/cwrapper.h	/^typedef struct CMapBasicBasic CMapBasicBasic;$/;"	t	typeref:struct:CMapBasicBasic
COMPILER_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_ID /;"	d	file:
COMPILER_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_ID /;"	d	file:
COMPILER_VERSION_INTERNAL	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_INTERNAL /;"	d	file:
COMPILER_VERSION_INTERNAL	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_INTERNAL /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MAJOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_MINOR /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^  # define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^  # define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#   define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_PATCH	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_PATCH /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define COMPILER_VERSION_TWEAK /;"	d	file:
COMPILER_VERSION_TWEAK	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define COMPILER_VERSION_TWEAK /;"	d	file:
CONTINUE	symengine/parser/scannerbase.h	/^        CONTINUE,   \/\/ transition succeeded, go on$/;"	m	class:SymEngine::ScannerBase::ActionType__
CPPTEMPL_H	benchmarks/nonius.h++	/^#define CPPTEMPL_H$/;"	d
CRCPBasic	symengine/cwrapper.cpp	/^struct CRCPBasic {$/;"	s	file:
CRCPBasic_C	symengine/cwrapper.h	/^struct CRCPBasic_C {$/;"	s
CSRMatrix	symengine/matrix.h	/^class CSRMatrix : public MatrixBase$/;"	c	namespace:SymEngine
CSRMatrix	symengine/sparse_matrix.cpp	/^CSRMatrix::CSRMatrix()$/;"	f	class:SymEngine::CSRMatrix
CSRMatrix	symengine/sparse_matrix.cpp	/^CSRMatrix::CSRMatrix(unsigned row, unsigned col) : row_(row), col_(col)$/;"	f	class:SymEngine::CSRMatrix
CSRMatrix	symengine/sparse_matrix.cpp	/^CSRMatrix::CSRMatrix(unsigned row, unsigned col, const std::vector<unsigned> &p,$/;"	f	class:SymEngine::CSRMatrix
CSRMatrix	symengine/sparse_matrix.cpp	/^CSRMatrix::CSRMatrix(unsigned row, unsigned col, std::vector<unsigned> &&p,$/;"	f	class:SymEngine::CSRMatrix
CSetBasic	symengine/cwrapper.cpp	/^struct CSetBasic {$/;"	s	file:
CSetBasic	symengine/cwrapper.h	/^typedef struct CSetBasic CSetBasic;$/;"	t	typeref:struct:CSetBasic
CSparseMatrix	symengine/cwrapper.cpp	/^struct CSparseMatrix {$/;"	s	file:
CSparseMatrix	symengine/cwrapper.h	/^typedef struct CSparseMatrix CSparseMatrix;$/;"	t	typeref:struct:CSparseMatrix
CVecBasic	symengine/cwrapper.cpp	/^struct CVecBasic {$/;"	s	file:
CVecBasic	symengine/cwrapper.h	/^typedef struct CVecBasic CVecBasic;$/;"	t	typeref:struct:CVecBasic
CVectorInt	symengine/cwrapper.cpp	/^struct CVectorInt {$/;"	s	file:
CVectorInt	symengine/cwrapper.h	/^typedef struct CVectorInt CVectorInt;$/;"	t	typeref:struct:CVectorInt
CWRAPPER_BEGIN	symengine/cwrapper.cpp	/^#define CWRAPPER_BEGIN /;"	d	file:
CWRAPPER_END	symengine/cwrapper.cpp	/^#define CWRAPPER_END /;"	d	file:
CWRAPPER_H	symengine/cwrapper.h	/^#define CWRAPPER_H$/;"	d
CWRAPPER_OUTPUT_TYPE	symengine/cwrapper.h	/^typedef symengine_exceptions_t CWRAPPER_OUTPUT_TYPE;$/;"	t
CXX_STD	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define CXX_STD /;"	d	file:
C_DIALECT	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define C_DIALECT /;"	d	file:
C_DIALECT	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define C_DIALECT$/;"	d	file:
C_DIALECT	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define C_DIALECT /;"	d	file:
CaseSensitive	symengine/utilities/catch/catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	s	namespace:Catch
Catalan	symengine/constants.cpp	/^RCP<const Constant> Catalan = constant("Catalan");$/;"	m	namespace:SymEngine	file:
Catch	symengine/utilities/catch/catch.hpp	/^namespace Catch {$/;"	n
Ceiling	symengine/functions.cpp	/^Ceiling::Ceiling(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Ceiling
Ceiling	symengine/functions.h	/^class Ceiling : public OneArgFunction$/;"	c	namespace:SymEngine
Choice	symengine/utilities/catch/catch.hpp	/^    struct CaseSensitive { enum Choice {$/;"	g	struct:Catch::CaseSensitive
CodePrinter	symengine/printers/codegen.h	/^class CodePrinter : public BaseVisitor<CodePrinter, StrPrinter>$/;"	c	namespace:SymEngine
CoeffVisitor	symengine/visitor.h	/^    CoeffVisitor(Ptr<const Basic> x, Ptr<const Basic> n) : x_(x), n_(n)$/;"	f	class:SymEngine::CoeffVisitor
CoeffVisitor	symengine/visitor.h	/^class CoeffVisitor : public BaseVisitor<CoeffVisitor, StopVisitor>$/;"	c	namespace:SymEngine
Complement	symengine/sets.cpp	/^Complement::Complement(const RCP<const Set> &universe,$/;"	f	class:SymEngine::Complement
Complement	symengine/sets.h	/^class Complement : public Set$/;"	c	namespace:SymEngine
Complex	symengine/complex.cpp	/^Complex::Complex(rational_class real, rational_class imaginary)$/;"	f	class:SymEngine::Complex
Complex	symengine/complex.h	/^class Complex : public ComplexBase$/;"	c	namespace:SymEngine
Complex	symengine/eval.h	/^    Complex = 0,$/;"	m	class:SymEngine::EvalfDomain
ComplexBase	symengine/complex.h	/^class ComplexBase : public Number$/;"	c	namespace:SymEngine
ComplexDouble	symengine/complex_double.cpp	/^ComplexDouble::ComplexDouble(std::complex<double> i)$/;"	f	class:SymEngine::ComplexDouble
ComplexDouble	symengine/complex_double.h	/^class ComplexDouble : public ComplexBase$/;"	c	namespace:SymEngine
ComplexInf	symengine/constants.cpp	/^RCP<const Infty> ComplexInf = Infty::from_int(0);$/;"	m	namespace:SymEngine	file:
ComplexMPC	symengine/complex_mpc.cpp	/^ComplexMPC::ComplexMPC(mpc_class i) : i{std::move(i)}$/;"	f	class:SymEngine::ComplexMPC
ComplexMPC	symengine/complex_mpc.h	/^class ComplexMPC : public ComplexBase$/;"	c	namespace:SymEngine
ConditionSet	symengine/sets.cpp	/^ConditionSet::ConditionSet(const RCP<const Basic> &sym,$/;"	f	class:SymEngine::ConditionSet
ConditionSet	symengine/sets.h	/^class ConditionSet : public Set$/;"	c	namespace:SymEngine
Conjugate	symengine/functions.cpp	/^Conjugate::Conjugate(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Conjugate
Conjugate	symengine/functions.h	/^class Conjugate : public OneArgFunction$/;"	c	namespace:SymEngine
ConstTypeTraits	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^class ConstTypeTraits {$/;"	c	namespace:Teuchos
Constant	symengine/constants.cpp	/^Constant::Constant(const std::string &name) : name_{name}$/;"	f	class:SymEngine::Constant
Constant	symengine/constants.h	/^class Constant : public Basic$/;"	c	namespace:SymEngine
ContainerBaseIter	symengine/polys/upolybase.h	/^    ContainerBaseIter(RCP<const T> ptr, long x) : ptr_{ptr}, i_{x}$/;"	f	class:SymEngine::ContainerBaseIter
ContainerBaseIter	symengine/polys/upolybase.h	/^class ContainerBaseIter$/;"	c	namespace:SymEngine
ContainerForIter	symengine/polys/upolybase.h	/^    ContainerForIter(RCP<const T> ptr, long x)$/;"	f	class:SymEngine::ContainerForIter
ContainerForIter	symengine/polys/upolybase.h	/^class ContainerForIter : public ContainerBaseIter<T, Int>$/;"	c	namespace:SymEngine
ContainerRevIter	symengine/polys/upolybase.h	/^    ContainerRevIter(RCP<const T> ptr, long x)$/;"	f	class:SymEngine::ContainerRevIter
ContainerRevIter	symengine/polys/upolybase.h	/^class ContainerRevIter : public ContainerBaseIter<T, Int>$/;"	c	namespace:SymEngine
Contains	symengine/logic.cpp	/^Contains::Contains(const RCP<const Basic> &expr, const RCP<const Set> &set)$/;"	f	class:SymEngine::Contains
Contains	symengine/logic.h	/^class Contains : public Boolean$/;"	c	namespace:SymEngine
ContinueOnFailure	symengine/utilities/catch/catch.hpp	/^        ContinueOnFailure = 0x02,   \/\/ Failures fail test, but execution continues$/;"	e	enum:Catch::ResultDisposition::Flags
CopyableStream	symengine/utilities/catch/catch.hpp	/^        CopyableStream( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream
CopyableStream	symengine/utilities/catch/catch.hpp	/^        CopyableStream() {}$/;"	f	struct:Catch::CopyableStream
CopyableStream	symengine/utilities/catch/catch.hpp	/^    struct CopyableStream {$/;"	s	namespace:Catch
Cos	symengine/functions.cpp	/^Cos::Cos(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Cos
Cos	symengine/functions.h	/^class Cos : public TrigFunction$/;"	c	namespace:SymEngine
Cosh	symengine/functions.cpp	/^Cosh::Cosh(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Cosh
Cosh	symengine/functions.h	/^class Cosh : public HyperbolicFunction$/;"	c	namespace:SymEngine
Cot	symengine/functions.cpp	/^Cot::Cot(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Cot
Cot	symengine/functions.h	/^class Cot : public TrigFunction$/;"	c	namespace:SymEngine
Coth	symengine/functions.cpp	/^Coth::Coth(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Coth
Coth	symengine/functions.h	/^class Coth : public HyperbolicFunction$/;"	c	namespace:SymEngine
CountOpsVisitor	symengine/visitor.h	/^class CountOpsVisitor : public BaseVisitor<CountOpsVisitor>$/;"	c	namespace:SymEngine
Csc	symengine/functions.cpp	/^Csc::Csc(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Csc
Csc	symengine/functions.h	/^class Csc : public TrigFunction$/;"	c	namespace:SymEngine
Csch	symengine/functions.cpp	/^Csch::Csch(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Csch
Csch	symengine/functions.h	/^class Csch : public HyperbolicFunction$/;"	c	namespace:SymEngine
D	benchmarks/lwbench.cpp	/^double D()$/;"	f
D	benchmarks/lwbench_ginac.cpp	/^double D()$/;"	f
DEC	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#define DEC(/;"	d	file:
DEC	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define DEC(/;"	d	file:
DEFAULT_RECOVERY_MODE__	symengine/parser/parserbase.h	/^        DEFAULT_RECOVERY_MODE__,$/;"	e	enum:SymEngine::ParserBase::ErrorRecovery__
DEF_RED	symengine/parser/parser.cpp	/^  DEF_RED,    \/\/ state having default reduction$/;"	e	enum:__anon29::StateType	file:
DEF_RED	symengine/parser/parser.cpp	/^  DEF_RED,    \/\/ state having default reduction$/;"	e	enum:__anon8::StateType	file:
DOWNLOAD	bin/appveyor-download.cmd	/^:DOWNLOAD$/;"	l
DanglingReferenceError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class DanglingReferenceError : public ExceptionBase$/;"	c	namespace:Teuchos
DanglingReferenceError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:DanglingReferenceError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::DanglingReferenceError
Data	benchmarks/nonius.h++	/^    class Data$/;"	c	namespace:cpptempl
DataList	benchmarks/nonius.h++	/^        DataList(const data_list &items) : m_items(items){}$/;"	f	class:cpptempl::DataList
DataList	benchmarks/nonius.h++	/^    class DataList : public Data$/;"	c	namespace:cpptempl
DataMap	benchmarks/nonius.h++	/^        DataMap(const data_map &items) : m_items(items){}$/;"	f	class:cpptempl::DataMap
DataMap	benchmarks/nonius.h++	/^    class DataMap : public Data$/;"	c	namespace:cpptempl
DataType	symengine/parser/parserbase.h	/^    typedef typename TypeOf<tg_>::type DataType;$/;"	t	class:SymEngine::Meta__::Semantic
DataValue	benchmarks/nonius.h++	/^        DataValue(std::string value) : m_value(value){}$/;"	f	class:cpptempl::DataValue
DataValue	benchmarks/nonius.h++	/^    class DataValue : public Data$/;"	c	namespace:cpptempl
DeallocArrayDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class DeallocArrayDelete$/;"	c	namespace:Teuchos
DeallocDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class DeallocDelete$/;"	c	namespace:Teuchos
DeallocFunctorDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  DeallocFunctorDelete( DeleteFunctor deleteFunctor ) : deleteFunctor_(deleteFunctor) {}$/;"	f	class:Teuchos::DeallocFunctorDelete
DeallocFunctorDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class DeallocFunctorDelete$/;"	c	namespace:Teuchos
DeallocFunctorHandleDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  DeallocFunctorHandleDelete( DeleteHandleFunctor deleteHandleFunctor )$/;"	f	class:Teuchos::DeallocFunctorHandleDelete
DeallocFunctorHandleDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class DeallocFunctorHandleDelete$/;"	c	namespace:Teuchos
DeallocNull	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class DeallocNull$/;"	c	namespace:Teuchos
DecomposedExpression	symengine/utilities/catch/catch.hpp	/^    struct DecomposedExpression$/;"	s	namespace:Catch
DenseMatrix	symengine/dense_matrix.cpp	/^DenseMatrix::DenseMatrix()$/;"	f	class:SymEngine::DenseMatrix
DenseMatrix	symengine/dense_matrix.cpp	/^DenseMatrix::DenseMatrix(const DenseMatrix &x)$/;"	f	class:SymEngine::DenseMatrix
DenseMatrix	symengine/dense_matrix.cpp	/^DenseMatrix::DenseMatrix(const vec_basic &column_elements)$/;"	f	class:SymEngine::DenseMatrix
DenseMatrix	symengine/dense_matrix.cpp	/^DenseMatrix::DenseMatrix(unsigned row, unsigned col) : row_(row), col_(col)$/;"	f	class:SymEngine::DenseMatrix
DenseMatrix	symengine/dense_matrix.cpp	/^DenseMatrix::DenseMatrix(unsigned row, unsigned col, const vec_basic &l)$/;"	f	class:SymEngine::DenseMatrix
DenseMatrix	symengine/matrix.h	/^class DenseMatrix : public MatrixBase$/;"	c	namespace:SymEngine
Derivative	symengine/functions.cpp	/^Derivative::Derivative(const RCP<const Basic> &arg, const multiset_basic &x)$/;"	f	class:SymEngine::Derivative
Derivative	symengine/functions.h	/^class Derivative : public Basic$/;"	c	namespace:SymEngine
Detail	symengine/utilities/catch/catch.hpp	/^namespace Detail {$/;"	n	namespace:Catch
DictLess	symengine/fields.h	/^    struct DictLess {$/;"	s	class:SymEngine::GaloisFieldDict
DidntThrowException	symengine/utilities/catch/catch.hpp	/^        DidntThrowException = Exception | 2,$/;"	e	enum:Catch::ResultWas::OfType
DiffImplementation	symengine/derivative.cpp	/^class DiffImplementation$/;"	c	namespace:SymEngine	file:
Dirichlet_eta	symengine/functions.cpp	/^Dirichlet_eta::Dirichlet_eta(const RCP<const Basic> &s) : OneArgFunction(s)$/;"	f	class:SymEngine::Dirichlet_eta
Dirichlet_eta	symengine/functions.h	/^class Dirichlet_eta : public OneArgFunction$/;"	c	namespace:SymEngine
DivisionByZeroError	symengine/symengine_exception.h	/^    DivisionByZeroError(const std::string &msg)$/;"	f	class:SymEngine::DivisionByZeroError
DivisionByZeroError	symengine/symengine_exception.h	/^class DivisionByZeroError : public SymEngineException$/;"	c	namespace:SymEngine
DomainError	symengine/symengine_exception.h	/^    DomainError(const std::string &msg)$/;"	f	class:SymEngine::DomainError
DomainError	symengine/symengine_exception.h	/^class DomainError : public SymEngineException$/;"	c	namespace:SymEngine
Dummy	symengine/symbol.cpp	/^Dummy::Dummy() : Symbol("_Dummy_" + to_string(count_))$/;"	f	class:SymEngine::Dummy
Dummy	symengine/symbol.cpp	/^Dummy::Dummy(const std::string &name) : Symbol("_" + name)$/;"	f	class:SymEngine::Dummy
Dummy	symengine/symbol.h	/^class Dummy : public Symbol$/;"	c	namespace:SymEngine
DuplicateOwningRCPError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class DuplicateOwningRCPError : public ExceptionBase$/;"	c	namespace:Teuchos
DuplicateOwningRCPError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:DuplicateOwningRCPError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::DuplicateOwningRCPError
DuplicateParameterEntryException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^  DuplicateParameterEntryException(const std::string& what_arg):$/;"	f	class:Teuchos::DuplicateParameterEntryException
DuplicateParameterEntryException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class DuplicateParameterEntryException : public ExceptionBase {$/;"	c	namespace:Teuchos
DuplicateParameterEntryIDException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^  DuplicateParameterEntryIDException(const std::string& what_arg):$/;"	f	class:Teuchos::DuplicateParameterEntryIDException
DuplicateParameterEntryIDException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class DuplicateParameterEntryIDException : public ExceptionBase {$/;"	c	namespace:Teuchos
DuplicateValidatorIDException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^  DuplicateValidatorIDException(const std::string& what_arg):$/;"	f	class:Teuchos::DuplicateValidatorIDException
DuplicateValidatorIDException	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class DuplicateValidatorIDException : public ExceptionBase {$/;"	c	namespace:Teuchos
E	benchmarks/lwbench.cpp	/^double E()$/;"	f
E	benchmarks/lwbench_ginac.cpp	/^double E()$/;"	f
E	symengine/constants.cpp	/^RCP<const Constant> E = constant("E");$/;"	m	namespace:SymEngine	file:
ECHO_CH	symengine/parser/scannerbase.h	/^        ECHO_CH,    \/\/ echo ch itself (d_matched empty)$/;"	m	class:SymEngine::ScannerBase::ActionType__
ECHO_FIRST	symengine/parser/scannerbase.h	/^        ECHO_FIRST, \/\/ echo d_matched[0], push back the rest$/;"	m	class:SymEngine::ScannerBase::ActionType__
END	symengine/parser/scannerbase.h	/^        END,    \/\/ postCode called when lex__() ends$/;"	m	class:SymEngine::ScannerBase::PostEnum__
ENull	build/cmake/checkcxx11.cpp	/^enum ENull { null };$/;"	g	file:
ENull	cmake/checkcxx11.cpp	/^enum ENull { null };$/;"	g	file:
ENull	symengine/symengine_rcp.h	/^enum ENull { null };$/;"	g	namespace:SymEngine
ENull	symengine/utilities/teuchos/Teuchos_ENull.hpp	/^enum ENull { null };$/;"	g	namespace:Teuchos
EPrePostDestruction	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };$/;"	g	namespace:Teuchos
EQ	symengine/parser/parserbase.h	/^        EQ,$/;"	e	enum:SymEngine::ParserBase::Tokens__
EQUALS	build/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/benchmarks/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/basic/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/cwrapper/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/eval/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/expression/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/finitediff/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/logic/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/matrix/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/ntheory/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/polynomial/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/printing/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/tests/rcp/Makefile	/^EQUALS = =$/;"	m
EQUALS	build/symengine/utilities/catch/Makefile	/^EQUALS = =$/;"	m
ERCPNodeLookup	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPNodeLookup { RCP_ENABLE_NODE_LOOKUP, RCP_DISABLE_NODE_LOOKUP };$/;"	g	namespace:Teuchos
ERCPStrength	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPStrength { RCP_STRENGTH_INVALID=-1, RCP_STRONG=0, RCP_WEAK=1 };$/;"	g	namespace:Teuchos
ERCPUndefinedWeakNoDealloc	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPUndefinedWeakNoDealloc { RCP_UNDEFINED_WEAK_NO_DEALLOC };$/;"	g	namespace:Teuchos
ERCPUndefinedWithDealloc	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPUndefinedWithDealloc { RCP_UNDEFINED_WITH_DEALLOC };$/;"	g	namespace:Teuchos
ERCPWeakNoDealloc	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPWeakNoDealloc { RCP_WEAK_NO_DEALLOC };$/;"	g	namespace:Teuchos
ERROR	symengine/parser/parserbase.h	/^inline void ParserBase::ERROR() const$/;"	f	class:SymEngine::ParserBase
ERR_DEF	symengine/parser/parser.cpp	/^  ERR_DEF,    \/\/ ERR_ITEM | DEF_RED$/;"	e	enum:__anon29::StateType	file:
ERR_DEF	symengine/parser/parser.cpp	/^  ERR_DEF,    \/\/ ERR_ITEM | DEF_RED$/;"	e	enum:__anon8::StateType	file:
ERR_ITEM	symengine/parser/parser.cpp	/^  ERR_ITEM,$/;"	e	enum:__anon29::StateType	file:
ERR_ITEM	symengine/parser/parser.cpp	/^  ERR_ITEM,$/;"	e	enum:__anon8::StateType	file:
ERR_REQ	symengine/parser/parser.cpp	/^  ERR_REQ,    \/\/ ERR_ITEM | REQ_TOKEN$/;"	e	enum:__anon29::StateType	file:
ERR_REQ	symengine/parser/parser.cpp	/^  ERR_REQ,    \/\/ ERR_ITEM | REQ_TOKEN$/;"	e	enum:__anon8::StateType	file:
ERR_REQ_DEF	symengine/parser/parser.cpp	/^  ERR_REQ_DEF \/\/ ERR_ITEM | REQ_TOKEN | DEF_RED$/;"	e	enum:__anon29::StateType	file:
ERR_REQ_DEF	symengine/parser/parser.cpp	/^  ERR_REQ_DEF \/\/ ERR_ITEM | REQ_TOKEN | DEF_RED$/;"	e	enum:__anon8::StateType	file:
EmbeddedObjDealloc	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  EmbeddedObjDealloc($/;"	f	class:Teuchos::EmbeddedObjDealloc
EmbeddedObjDealloc	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class EmbeddedObjDealloc$/;"	c	namespace:Teuchos
EmptySet	symengine/sets.h	/^    EmptySet()$/;"	f	class:SymEngine::EmptySet
EmptySet	symengine/sets.h	/^class EmptySet : public Set$/;"	c	namespace:SymEngine
EnableRCPFromThis	symengine/symengine_rcp.h	/^    EnableRCPFromThis() : refcount_(0)$/;"	f	class:SymEngine::EnableRCPFromThis
EnableRCPFromThis	symengine/symengine_rcp.h	/^class EnableRCPFromThis$/;"	c	namespace:SymEngine
EnumStringMaker	symengine/utilities/catch/catch.hpp	/^    struct EnumStringMaker$/;"	s	namespace:Catch::Detail
EnumStringMaker	symengine/utilities/catch/catch.hpp	/^    struct EnumStringMaker<T,true>$/;"	s	namespace:Catch::Detail
Eq	symengine/logic.cpp	/^RCP<const Boolean> Eq(const RCP<const Basic> &lhs)$/;"	f	namespace:SymEngine
Eq	symengine/logic.cpp	/^RCP<const Boolean> Eq(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
Equality	symengine/logic.cpp	/^Equality::Equality(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	class:SymEngine::Equality
Equality	symengine/logic.h	/^class Equality : public Relational$/;"	c	namespace:SymEngine
Erf	symengine/functions.h	/^    Erf(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Erf
Erf	symengine/functions.h	/^class Erf : public OneArgFunction$/;"	c	namespace:SymEngine
Erfc	symengine/functions.h	/^    Erfc(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Erfc
Erfc	symengine/functions.h	/^class Erfc : public OneArgFunction$/;"	c	namespace:SymEngine
ErrorRecovery__	symengine/parser/parserbase.h	/^    enum ErrorRecovery__ {$/;"	g	class:SymEngine::ParserBase
EulerGamma	symengine/constants.cpp	/^RCP<const Constant> EulerGamma = constant("EulerGamma");$/;"	m	namespace:SymEngine	file:
EvalArbVisitor	symengine/eval_arb.cpp	/^    EvalArbVisitor(long precision) : prec_{precision}$/;"	f	class:SymEngine::EvalArbVisitor
EvalArbVisitor	symengine/eval_arb.cpp	/^class EvalArbVisitor : public BaseVisitor<EvalArbVisitor>$/;"	c	namespace:SymEngine	file:
EvalComplexDoubleVisitor	symengine/eval_double.cpp	/^class EvalComplexDoubleVisitor$/;"	c	namespace:SymEngine	file:
EvalDoubleVisitor	symengine/eval_double.cpp	/^class EvalDoubleVisitor : public BaseVisitor<C>$/;"	c	namespace:SymEngine	file:
EvalMPCVisitor	symengine/eval_mpc.cpp	/^    EvalMPCVisitor(mpfr_rnd_t rnd) : rnd_{rnd}$/;"	f	class:SymEngine::EvalMPCVisitor
EvalMPCVisitor	symengine/eval_mpc.cpp	/^class EvalMPCVisitor : public BaseVisitor<EvalMPCVisitor>$/;"	c	namespace:SymEngine	file:
EvalMPFRVisitor	symengine/eval_mpfr.cpp	/^    EvalMPFRVisitor(mpfr_rnd_t rnd) : rnd_{rnd}$/;"	f	class:SymEngine::EvalMPFRVisitor
EvalMPFRVisitor	symengine/eval_mpfr.cpp	/^class EvalMPFRVisitor : public BaseVisitor<EvalMPFRVisitor>$/;"	c	namespace:SymEngine	file:
EvalRealDoubleVisitor	symengine/eval_double.cpp	/^class EvalRealDoubleVisitor : public EvalDoubleVisitor<double, C>$/;"	c	namespace:SymEngine	file:
EvalRealDoubleVisitorFinal	symengine/eval_double.cpp	/^class EvalRealDoubleVisitorFinal$/;"	c	namespace:SymEngine	file:
EvalRealDoubleVisitorPattern	symengine/eval_double.cpp	/^class EvalRealDoubleVisitorPattern$/;"	c	namespace:SymEngine	file:
EvalVisitor	symengine/eval.cpp	/^    EvalVisitor(unsigned long bits) : bits(bits)$/;"	f	class:SymEngine::EvalVisitor
EvalVisitor	symengine/eval.cpp	/^class EvalVisitor : public BaseVisitor<EvalVisitor, TransformVisitor>$/;"	c	namespace:SymEngine	file:
EvalfDomain	symengine/eval.h	/^enum class EvalfDomain {$/;"	c	namespace:SymEngine
Evaluate	symengine/number.h	/^class Evaluate$/;"	c	namespace:SymEngine
EvaluateComplexDouble	symengine/real_double.cpp	/^class EvaluateComplexDouble : public EvaluateDouble<ComplexDouble>$/;"	c	namespace:SymEngine	file:
EvaluateDouble	symengine/real_double.cpp	/^class EvaluateDouble : public Evaluate$/;"	c	namespace:SymEngine	file:
EvaluateInfty	symengine/infinity.cpp	/^class EvaluateInfty : public Evaluate$/;"	c	namespace:SymEngine	file:
EvaluateMPC	symengine/complex_mpc.cpp	/^class EvaluateMPC : public Evaluate$/;"	c	namespace:SymEngine	file:
EvaluateMPFR	symengine/real_mpfr.cpp	/^class EvaluateMPFR : public Evaluate$/;"	c	namespace:SymEngine	file:
EvaluateNaN	symengine/nan.cpp	/^class EvaluateNaN : public Evaluate$/;"	c	namespace:SymEngine	file:
EvaluateRealDouble	symengine/real_double.cpp	/^class EvaluateRealDouble : public EvaluateDouble<RealDouble>$/;"	c	namespace:SymEngine	file:
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThan> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsGreaterThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThan> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsLessThanOrEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator<T1, T2, IsNotEqualTo> {$/;"	s	namespace:Catch::Internal
Evaluator	symengine/utilities/catch/catch.hpp	/^    struct Evaluator{};$/;"	s	namespace:Catch::Internal
Exception	symengine/utilities/catch/catch.hpp	/^        Exception = 0x100 | FailureBit,$/;"	e	enum:Catch::ResultWas::OfType
ExceptionBase	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class ExceptionBase : public std::logic_error$/;"	c	namespace:Teuchos
ExceptionBase	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:ExceptionBase(const std::string& what_arg) : std::logic_error(what_arg) {}};$/;"	f	class:Teuchos::ExceptionBase
ExpandVisitor	symengine/expand.cpp	/^    ExpandVisitor(bool deep_ = true) : deep(deep_)$/;"	f	class:SymEngine::ExpandVisitor
ExpandVisitor	symengine/expand.cpp	/^class ExpandVisitor : public BaseVisitor<ExpandVisitor>$/;"	c	namespace:SymEngine	file:
ExplicitFailure	symengine/utilities/catch/catch.hpp	/^        ExplicitFailure = FailureBit | 2,$/;"	e	enum:Catch::ResultWas::OfType
Expression	symengine/expression.h	/^    Expression($/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression() : m_basic(integer(0))$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(RCP<const T> &&o,$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(T n,$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(const RCP<const T> &o,$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(const integer_class &n) : m_basic(integer(n))$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(const rational_class &n) : m_basic(Rational::from_mpq(n))$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^    Expression(std::complex<T> n,$/;"	f	class:SymEngine::Expression
Expression	symengine/expression.h	/^class Expression$/;"	c	namespace:SymEngine
ExpressionFailed	symengine/utilities/catch/catch.hpp	/^        ExpressionFailed = FailureBit | 1,$/;"	e	enum:Catch::ResultWas::OfType
ExpressionParser	symengine/parser/parser_old.cpp	/^    ExpressionParser(bool convert_xor)$/;"	f	class:SymEngine::ExpressionParser
ExpressionParser	symengine/parser/parser_old.cpp	/^class ExpressionParser$/;"	c	namespace:SymEngine	file:
FFLDU	symengine/dense_matrix.cpp	/^void DenseMatrix::FFLDU(MatrixBase &L, MatrixBase &D, MatrixBase &U) const$/;"	f	class:SymEngine::DenseMatrix
FFLDU	symengine/sparse_matrix.cpp	/^void CSRMatrix::FFLDU(MatrixBase &L, MatrixBase &D, MatrixBase &U) const$/;"	f	class:SymEngine::CSRMatrix
FFLU	symengine/dense_matrix.cpp	/^void DenseMatrix::FFLU(MatrixBase &LU) const$/;"	f	class:SymEngine::DenseMatrix
FFLU	symengine/sparse_matrix.cpp	/^void CSRMatrix::FFLU(MatrixBase &LU) const$/;"	f	class:SymEngine::CSRMatrix
FORTRAN_DISABLED	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#    define FORTRAN_DISABLED$/;"	d
FailureBit	symengine/utilities/catch/catch.hpp	/^        FailureBit = 0x10,$/;"	e	enum:Catch::ResultWas::OfType
FalseTest	symengine/utilities/catch/catch.hpp	/^        FalseTest = 0x04,           \/\/ Prefix expression with !$/;"	e	enum:Catch::ResultDisposition::Flags
FalseType	symengine/utilities/catch/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	s	namespace:Catch::Detail
FatalErrorCondition	symengine/utilities/catch/catch.hpp	/^        FatalErrorCondition = 0x200 | FailureBit$/;"	e	enum:Catch::ResultWas::OfType
Final	symengine/parser/scannerbase.h	/^    struct Final {$/;"	s	class:SymEngine::ScannerBase
FinalData	symengine/parser/scannerbase.h	/^    struct FinalData {$/;"	s	class:SymEngine::ScannerBase
FiniteSet	symengine/sets.cpp	/^FiniteSet::FiniteSet(const set_basic &container) : container_(container)$/;"	f	class:SymEngine::FiniteSet
FiniteSet	symengine/sets.h	/^class FiniteSet : public Set$/;"	c	namespace:SymEngine
Flags	symengine/utilities/catch/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	g	struct:Catch::ResultDisposition
Floor	symengine/functions.cpp	/^Floor::Floor(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Floor
Floor	symengine/functions.h	/^class Floor : public OneArgFunction$/;"	c	namespace:SymEngine
FreeSymbolsVisitor	symengine/visitor.cpp	/^class FreeSymbolsVisitor : public BaseVisitor<FreeSymbolsVisitor>$/;"	c	namespace:SymEngine	file:
FuncArgTracker	symengine/cse.cpp	/^    FuncArgTracker($/;"	f	class:SymEngine::FuncArgTracker
FuncArgTracker	symengine/cse.cpp	/^class FuncArgTracker$/;"	c	namespace:SymEngine	file:
Function	symengine/functions.h	/^class Function : public Basic$/;"	c	namespace:SymEngine
FunctionSymbol	symengine/functions.cpp	/^FunctionSymbol::FunctionSymbol(std::string name, const RCP<const Basic> &arg)$/;"	f	class:SymEngine::FunctionSymbol
FunctionSymbol	symengine/functions.cpp	/^FunctionSymbol::FunctionSymbol(std::string name, const vec_basic &arg)$/;"	f	class:SymEngine::FunctionSymbol
FunctionSymbol	symengine/functions.h	/^class FunctionSymbol : public MultiArgFunction$/;"	c	namespace:SymEngine
FunctionWrapper	symengine/functions.cpp	/^FunctionWrapper::FunctionWrapper(std::string name, const RCP<const Basic> &arg)$/;"	f	class:SymEngine::FunctionWrapper
FunctionWrapper	symengine/functions.cpp	/^FunctionWrapper::FunctionWrapper(std::string name, const vec_basic &vec)$/;"	f	class:SymEngine::FunctionWrapper
FunctionWrapper	symengine/functions.h	/^class FunctionWrapper : public FunctionSymbol$/;"	c	namespace:SymEngine
GE	symengine/parser/parserbase.h	/^        GE,$/;"	e	enum:SymEngine::ParserBase::Tokens__
GIVEN	symengine/utilities/catch/catch.hpp	/^#define GIVEN(/;"	d
GaloisField	symengine/fields.cpp	/^GaloisField::GaloisField(const RCP<const Basic> &var, GaloisFieldDict &&dict)$/;"	f	class:SymEngine::GaloisField
GaloisField	symengine/fields.h	/^class GaloisField : public UIntPolyBase<GaloisFieldDict, GaloisField>$/;"	c	namespace:SymEngine
GaloisFieldDict	symengine/fields.cpp	/^GaloisFieldDict::GaloisFieldDict(const int &i, const integer_class &mod)$/;"	f	class:SymEngine::GaloisFieldDict
GaloisFieldDict	symengine/fields.cpp	/^GaloisFieldDict::GaloisFieldDict(const integer_class &i,$/;"	f	class:SymEngine::GaloisFieldDict
GaloisFieldDict	symengine/fields.cpp	/^GaloisFieldDict::GaloisFieldDict(const map_uint_mpz &p,$/;"	f	class:SymEngine::GaloisFieldDict
GaloisFieldDict	symengine/fields.h	/^class GaloisFieldDict$/;"	c	namespace:SymEngine
Gamma	symengine/functions.cpp	/^Gamma::Gamma(const RCP<const Basic> &arg) : OneArgFunction{arg}$/;"	f	class:SymEngine::Gamma
Gamma	symengine/functions.h	/^class Gamma : public OneArgFunction$/;"	c	namespace:SymEngine
Ge	symengine/logic.cpp	/^RCP<const Boolean> Ge(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
GetBaseObjVoidPtrImpl	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^class GetBaseObjVoidPtrImpl {};$/;"	c	namespace:Teuchos
GetBaseObjVoidPtrImpl	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^class GetBaseObjVoidPtrImpl<false, T> {$/;"	c	namespace:Teuchos
GetBaseObjVoidPtrImpl	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^class GetBaseObjVoidPtrImpl<true, T> {$/;"	c	namespace:Teuchos
GoldenRatio	symengine/constants.cpp	/^RCP<const Constant> GoldenRatio = constant("GoldenRatio");$/;"	m	namespace:SymEngine	file:
Gt	symengine/logic.cpp	/^RCP<const Boolean> Gt(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
HAS_TEUCHOS_GET_BASE_OBJ_VOID_PTR	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^#define HAS_TEUCHOS_GET_BASE_OBJ_VOID_PTR /;"	d
HAVE_COMPLEX	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#  define HAVE_COMPLEX$/;"	d
HAVE_DEFAULT_CONSTRUCTORS	build/symengine/symengine_config.h	/^#define HAVE_DEFAULT_CONSTRUCTORS$/;"	d
HAVE_SYMENGINE_GMP	build/symengine/symengine_config.h	/^#define HAVE_SYMENGINE_GMP$/;"	d
HAVE_SYMENGINE_IS_CONSTRUCTIBLE	build/symengine/symengine_config.h	/^#define HAVE_SYMENGINE_IS_CONSTRUCTIBLE$/;"	d
HAVE_SYMENGINE_NOEXCEPT	build/symengine/symengine_config.h	/^#define HAVE_SYMENGINE_NOEXCEPT$/;"	d
HAVE_SYMENGINE_RESERVE	build/symengine/symengine_config.h	/^#define HAVE_SYMENGINE_RESERVE$/;"	d
HAVE_SYMENGINE_STD_TO_STRING	build/symengine/symengine_config.h	/^#define HAVE_SYMENGINE_STD_TO_STRING$/;"	d
HAVE_TEUCHOS_ARRAY_BOUNDSCHECK	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#  define HAVE_TEUCHOS_ARRAY_BOUNDSCHECK$/;"	d
HEX	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#define HEX(/;"	d	file:
HEX	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define HEX(/;"	d	file:
HasSymbolVisitor	symengine/visitor.h	/^    HasSymbolVisitor(Ptr<const Symbol> x) : x_(x)$/;"	f	class:SymEngine::HasSymbolVisitor
HasSymbolVisitor	symengine/visitor.h	/^class HasSymbolVisitor : public BaseVisitor<HasSymbolVisitor, StopVisitor>$/;"	c	namespace:SymEngine
HyperbolicBase	symengine/functions.h	/^    HyperbolicBase(RCP<const Basic> arg) : OneArgFunction{arg} {};$/;"	f	class:SymEngine::HyperbolicBase
HyperbolicBase	symengine/functions.h	/^class HyperbolicBase : public OneArgFunction$/;"	c	namespace:SymEngine
HyperbolicFunction	symengine/functions.h	/^    HyperbolicFunction(RCP<const Basic> arg) : HyperbolicBase{arg} {};$/;"	f	class:SymEngine::HyperbolicFunction
HyperbolicFunction	symengine/functions.h	/^class HyperbolicFunction : public HyperbolicBase$/;"	c	namespace:SymEngine
I	symengine/constants.cpp	/^RCP<const Number> I = Complex::from_two_nums(*zero, *one);$/;"	m	namespace:SymEngine	file:
I18NSPHINXOPTS	doc/Makefile	/^I18NSPHINXOPTS  = $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .$/;"	m
IContext	symengine/utilities/catch/catch.hpp	/^    struct IContext$/;"	s	namespace:Catch
IDENTIFIER	symengine/parser/parserbase.h	/^        IDENTIFIER = 257,$/;"	e	enum:SymEngine::ParserBase::Tokens__
ID_VOID_MAIN	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define ID_VOID_MAIN$/;"	d	file:
IGeneratorInfo	symengine/utilities/catch/catch.hpp	/^    struct IGeneratorInfo {$/;"	s	namespace:Catch
IGeneratorsForTest	symengine/utilities/catch/catch.hpp	/^    struct IGeneratorsForTest {$/;"	s	namespace:Catch
IMPLEMENT_DIFF	symengine/derivative.cpp	/^#define IMPLEMENT_DIFF(/;"	d	file:
IMPLEMENT_ONE_ARG_FUNC	symengine/cwrapper.cpp	/^#define IMPLEMENT_ONE_ARG_FUNC(/;"	d	file:
IMPLEMENT_TYPEID	symengine/basic.h	/^#define IMPLEMENT_TYPEID(/;"	d
IMPLICIT_MUL	symengine/parser/parserbase.h	/^        IMPLICIT_MUL,$/;"	e	enum:SymEngine::ParserBase::Tokens__
IMutableContext	symengine/utilities/catch/catch.hpp	/^    struct IMutableContext : IContext$/;"	s	namespace:Catch
INITIAL	symengine/parser/scannerbase.h	/^        INITIAL,$/;"	m	class:SymEngine::ScannerBase::StartCondition__
INTERNAL_CATCH_ELSE	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_ELSE(/;"	d
INTERNAL_CATCH_GENERATE	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_GENERATE(/;"	d
INTERNAL_CATCH_IF	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_IF(/;"	d
INTERNAL_CATCH_INFO	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_INFO(/;"	d
INTERNAL_CATCH_LINESTR	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_LINESTR(/;"	d
INTERNAL_CATCH_LINESTR2	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_LINESTR2(/;"	d
INTERNAL_CATCH_METHOD_AS_TEST_CASE	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_METHOD_AS_TEST_CASE(/;"	d
INTERNAL_CATCH_MSG	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_MSG(/;"	d
INTERNAL_CATCH_NO_THROW	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_NO_THROW(/;"	d
INTERNAL_CATCH_REACT	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_REACT(/;"	d
INTERNAL_CATCH_REGISTER_LEGACY_REPORTER	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_LEGACY_REPORTER(/;"	d
INTERNAL_CATCH_REGISTER_LISTENER	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_LISTENER(/;"	d
INTERNAL_CATCH_REGISTER_REPORTER	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_REGISTER_REPORTER(/;"	d
INTERNAL_CATCH_REGISTER_TESTCASE	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_REGISTER_TESTCASE(/;"	d
INTERNAL_CATCH_SECTION	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_SECTION(/;"	d
INTERNAL_CATCH_STRINGIFY	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_STRINGIFY(/;"	d
INTERNAL_CATCH_STRINGIFY2	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_STRINGIFY2(/;"	d
INTERNAL_CATCH_TEST	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_TEST(/;"	d
INTERNAL_CATCH_TESTCASE	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_TESTCASE(/;"	d
INTERNAL_CATCH_TESTCASE2	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_TESTCASE2(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_TEST_CASE_METHOD(/;"	d
INTERNAL_CATCH_TEST_CASE_METHOD2	symengine/utilities/catch/catch.hpp	/^    #define INTERNAL_CATCH_TEST_CASE_METHOD2(/;"	d
INTERNAL_CATCH_TEST_NO_TRY	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_TEST_NO_TRY(/;"	d
INTERNAL_CATCH_THROWS	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_THROWS(/;"	d
INTERNAL_CATCH_THROWS_AS	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_THROWS_AS(/;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_TRANSLATE_EXCEPTION(/;"	d
INTERNAL_CATCH_TRANSLATE_EXCEPTION2	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_TRANSLATE_EXCEPTION2(/;"	d
INTERNAL_CATCH_UNIQUE_NAME	symengine/utilities/catch/catch.hpp	/^#  define INTERNAL_CATCH_UNIQUE_NAME(/;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_UNIQUE_NAME_LINE(/;"	d
INTERNAL_CATCH_UNIQUE_NAME_LINE2	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CATCH_UNIQUE_NAME_LINE2(/;"	d
INTERNAL_CHECK_THAT	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CHECK_THAT(/;"	d
INTERNAL_CHECK_THAT_NO_TRY	symengine/utilities/catch/catch.hpp	/^#define INTERNAL_CHECK_THAT_NO_TRY(/;"	d
IRBuilder	symengine/llvm_double.cpp	/^class IRBuilder : public llvm::IRBuilder<>$/;"	c	namespace:SymEngine	file:
IShared	symengine/utilities/catch/catch.hpp	/^    struct IShared : NonCopyable {$/;"	s	namespace:Catch
ITestCase	symengine/utilities/catch/catch.hpp	/^    struct ITestCase : IShared {$/;"	s	namespace:Catch
ITestCaseRegistry	symengine/utilities/catch/catch.hpp	/^    struct ITestCaseRegistry {$/;"	s	namespace:Catch
ImageSet	symengine/sets.cpp	/^ImageSet::ImageSet(const RCP<const Basic> &sym, const RCP<const Basic> &expr,$/;"	f	class:SymEngine::ImageSet
ImageSet	symengine/sets.h	/^class ImageSet : public Set$/;"	c	namespace:SymEngine
Impl	symengine/utilities/catch/catch.hpp	/^    namespace Impl {$/;"	n	namespace:Catch::Matchers
IncompatibleIteratorsError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class IncompatibleIteratorsError : public ExceptionBase$/;"	c	namespace:Teuchos
IncompatibleIteratorsError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:IncompatibleIteratorsError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::IncompatibleIteratorsError
Inf	symengine/constants.cpp	/^RCP<const Infty> Inf = Infty::from_int(1);$/;"	m	namespace:SymEngine	file:
Info	symengine/utilities/catch/catch.hpp	/^        Info = 1,$/;"	e	enum:Catch::ResultWas::OfType
Infty	symengine/infinity.cpp	/^Infty::Infty(const Infty &inf)$/;"	f	class:SymEngine::Infty
Infty	symengine/infinity.cpp	/^Infty::Infty(const RCP<const Number> &direction)$/;"	f	class:SymEngine::Infty
Infty	symengine/infinity.h	/^class Infty : public Number$/;"	c	namespace:SymEngine
Initializer	symengine/parser/parserbase.h	/^struct Initializer {$/;"	s	namespace:SymEngine::Meta__
Initializer	symengine/parser/parserbase.h	/^struct Initializer<false, Type> {$/;"	s	namespace:SymEngine::Meta__
Input	symengine/parser/scanner.cpp	/^ScannerBase::Input::Input() : d_in(0), d_lineNr(1)$/;"	f	class:SymEngine::ScannerBase::Input
Input	symengine/parser/scanner.cpp	/^ScannerBase::Input::Input(std::istream *iStream, size_t lineNr)$/;"	f	class:SymEngine::ScannerBase::Input
Input	symengine/parser/scannerbase.h	/^    class Input$/;"	c	class:SymEngine::ScannerBase
Integer	symengine/integer.h	/^    Integer(const integer_class &_i) : i(_i)$/;"	f	class:SymEngine::Integer
Integer	symengine/integer.h	/^    Integer(integer_class &&_i) : i(std::move(_i))$/;"	f	class:SymEngine::Integer
Integer	symengine/integer.h	/^class Integer : public Number$/;"	c	namespace:SymEngine
Internal	symengine/utilities/catch/catch.hpp	/^namespace Internal {$/;"	n	namespace:Catch
Interval	symengine/sets.cpp	/^Interval::Interval(const RCP<const Number> &start, const RCP<const Number> &end,$/;"	f	class:SymEngine::Interval
Interval	symengine/sets.h	/^class Interval : public Set$/;"	c	namespace:SymEngine
InverseHyperbolicFunction	symengine/functions.h	/^    InverseHyperbolicFunction(RCP<const Basic> arg) : HyperbolicBase{arg} {};$/;"	f	class:SymEngine::InverseHyperbolicFunction
InverseHyperbolicFunction	symengine/functions.h	/^class InverseHyperbolicFunction : public HyperbolicBase$/;"	c	namespace:SymEngine
InverseTrigFunction	symengine/functions.h	/^    InverseTrigFunction(RCP<const Basic> arg) : TrigBase(arg){};$/;"	f	class:SymEngine::InverseTrigFunction
InverseTrigFunction	symengine/functions.h	/^class InverseTrigFunction : public TrigBase$/;"	c	namespace:SymEngine
InvertComplexVisitor	symengine/solve.cpp	/^    InvertComplexVisitor(RCP<const Set> gY, RCP<const Dummy> nD,$/;"	f	class:SymEngine::InvertComplexVisitor
InvertComplexVisitor	symengine/solve.cpp	/^class InvertComplexVisitor : public BaseVisitor<InvertComplexVisitor>$/;"	c	namespace:SymEngine	file:
IsALinearArgTrigVisitor	symengine/solve.cpp	/^    IsALinearArgTrigVisitor(Ptr<const Symbol> x) : x_(x)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
IsALinearArgTrigVisitor	symengine/solve.cpp	/^class IsALinearArgTrigVisitor$/;"	c	namespace:SymEngine	file:
IsEqualTo	symengine/utilities/catch/catch.hpp	/^        IsEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThan	symengine/utilities/catch/catch.hpp	/^        IsGreaterThan,$/;"	e	enum:Catch::Internal::Operator
IsGreaterThanOrEqualTo	symengine/utilities/catch/catch.hpp	/^        IsGreaterThanOrEqualTo$/;"	e	enum:Catch::Internal::Operator
IsLessThan	symengine/utilities/catch/catch.hpp	/^        IsLessThan,$/;"	e	enum:Catch::Internal::Operator
IsLessThanOrEqualTo	symengine/utilities/catch/catch.hpp	/^        IsLessThanOrEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsNotEqualTo	symengine/utilities/catch/catch.hpp	/^        IsNotEqualTo,$/;"	e	enum:Catch::Internal::Operator
IsStreamInsertable	symengine/utilities/catch/catch.hpp	/^    class IsStreamInsertable {$/;"	c	namespace:Catch::Detail
IsStreamInsertable	symengine/utilities/catch/catch.hpp	/^    struct IsStreamInsertable {$/;"	s	namespace:Catch::Detail
JSCodePrinter	symengine/printers/codegen.h	/^class JSCodePrinter : public BaseVisitor<JSCodePrinter, CodePrinter>$/;"	c	namespace:SymEngine
JuliaStrPrinter	symengine/printers/strprinter.h	/^class JuliaStrPrinter : public BaseVisitor<JuliaStrPrinter, StrPrinter>$/;"	c	namespace:SymEngine
KroneckerDelta	symengine/functions.cpp	/^KroneckerDelta::KroneckerDelta(const RCP<const Basic> &i,$/;"	f	class:SymEngine::KroneckerDelta
KroneckerDelta	symengine/functions.h	/^class KroneckerDelta : public TwoArgFunction$/;"	c	namespace:SymEngine
LATEX_H	symengine/printers/latex.h	/^#define LATEX_H$/;"	d
LDL	symengine/dense_matrix.cpp	/^void DenseMatrix::LDL(MatrixBase &L, MatrixBase &D) const$/;"	f	class:SymEngine::DenseMatrix
LDL	symengine/dense_matrix.cpp	/^void LDL(const DenseMatrix &A, DenseMatrix &L, DenseMatrix &D)$/;"	f	namespace:SymEngine
LDL	symengine/sparse_matrix.cpp	/^void CSRMatrix::LDL(MatrixBase &L, MatrixBase &D) const$/;"	f	class:SymEngine::CSRMatrix
LDL_solve	symengine/dense_matrix.cpp	/^void LDL_solve(const DenseMatrix &A, const DenseMatrix &b, DenseMatrix &x)$/;"	f	namespace:SymEngine
LE	symengine/parser/parserbase.h	/^        LE,$/;"	e	enum:SymEngine::ParserBase::Tokens__
LLVMDoubleVisitor	symengine/llvm_double.h	/^class LLVMDoubleVisitor : public BaseVisitor<LLVMDoubleVisitor>$/;"	c	namespace:SymEngine
LU	symengine/dense_matrix.cpp	/^void DenseMatrix::LU(MatrixBase &L, MatrixBase &U) const$/;"	f	class:SymEngine::DenseMatrix
LU	symengine/dense_matrix.cpp	/^void LU(const DenseMatrix &A, DenseMatrix &L, DenseMatrix &U)$/;"	f	namespace:SymEngine
LU	symengine/sparse_matrix.cpp	/^void CSRMatrix::LU(MatrixBase &L, MatrixBase &U) const$/;"	f	class:SymEngine::CSRMatrix
LU_solve	symengine/dense_matrix.cpp	/^void DenseMatrix::LU_solve(const MatrixBase &b, MatrixBase &x) const$/;"	f	class:SymEngine::DenseMatrix
LU_solve	symengine/dense_matrix.cpp	/^void LU_solve(const DenseMatrix &A, const DenseMatrix &b, DenseMatrix &x)$/;"	f	namespace:SymEngine
LU_solve	symengine/sparse_matrix.cpp	/^void CSRMatrix::LU_solve(const MatrixBase &b, MatrixBase &x) const$/;"	f	class:SymEngine::CSRMatrix
LambdaComplexDoubleVisitor	symengine/lambda_double.h	/^class LambdaComplexDoubleVisitor$/;"	c	namespace:SymEngine
LambdaDoubleVisitor	symengine/lambda_double.h	/^class LambdaDoubleVisitor : public BaseVisitor<LambdaDoubleVisitor<T>>$/;"	c	namespace:SymEngine
LambdaRealDoubleVisitor	symengine/lambda_double.h	/^class LambdaRealDoubleVisitor$/;"	c	namespace:SymEngine
LambertW	symengine/functions.cpp	/^LambertW::LambertW(const RCP<const Basic> &arg) : OneArgFunction{arg}$/;"	f	class:SymEngine::LambertW
LambertW	symengine/functions.h	/^class LambertW : public OneArgFunction$/;"	c	namespace:SymEngine
LatexPrinter	symengine/printers/latex.h	/^class LatexPrinter : public BaseVisitor<LatexPrinter, StrPrinter>$/;"	c	namespace:SymEngine
Le	symengine/logic.cpp	/^RCP<const Boolean> Le(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
Leave__	symengine/parser/scannerbase.h	/^    enum Leave__ {};$/;"	g	class:SymEngine::ScannerBase
LessThan	symengine/logic.cpp	/^LessThan::LessThan(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	class:SymEngine::LessThan
LessThan	symengine/logic.h	/^class LessThan : public Relational$/;"	c	namespace:SymEngine
LeviCivita	symengine/functions.cpp	/^LeviCivita::LeviCivita(const vec_basic &&arg) : MultiArgFunction(std::move(arg))$/;"	f	class:SymEngine::LeviCivita
LeviCivita	symengine/functions.h	/^class LeviCivita : public MultiArgFunction$/;"	c	namespace:SymEngine
LocalStopVisitor	symengine/visitor.h	/^class LocalStopVisitor : public StopVisitor$/;"	c	namespace:SymEngine
Log	symengine/functions.cpp	/^Log::Log(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Log
Log	symengine/functions.h	/^class Log : public OneArgFunction$/;"	c	namespace:SymEngine
LogGamma	symengine/functions.h	/^    LogGamma(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::LogGamma
LogGamma	symengine/functions.h	/^class LogGamma : public OneArgFunction$/;"	c	namespace:SymEngine
Lopen	symengine/sets.cpp	/^RCP<const Set> Interval::Lopen() const$/;"	f	class:SymEngine::Interval
LowerGamma	symengine/functions.cpp	/^LowerGamma::LowerGamma(const RCP<const Basic> &s, const RCP<const Basic> &x)$/;"	f	class:SymEngine::LowerGamma
LowerGamma	symengine/functions.h	/^class LowerGamma : public TwoArgFunction$/;"	c	namespace:SymEngine
Lt	symengine/logic.cpp	/^RCP<const Boolean> Lt(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
MATCH	symengine/parser/scannerbase.h	/^        MATCH,      \/\/ matched a rule$/;"	m	class:SymEngine::ScannerBase::ActionType__
MExprDict	symengine/polys/msymenginepoly.h	/^    MExprDict(const umap_vec_expr &p, unsigned int sz) : UDictWrapper(p, sz)$/;"	f	class:SymEngine::MExprDict
MExprDict	symengine/polys/msymenginepoly.h	/^    MExprDict(umap_vec_expr &&p, unsigned int sz)$/;"	f	class:SymEngine::MExprDict
MExprDict	symengine/polys/msymenginepoly.h	/^class MExprDict : public UDictWrapper<vec_int, Expression, MExprDict>$/;"	c	namespace:SymEngine
MExprPoly	symengine/polys/msymenginepoly.h	/^    MExprPoly(const set_basic &vars, MExprDict &&dict)$/;"	f	class:SymEngine::MExprPoly
MExprPoly	symengine/polys/msymenginepoly.h	/^class MExprPoly : public MSymEnginePoly<MExprDict, MExprPoly>$/;"	c	namespace:SymEngine
MIntDict	symengine/polys/msymenginepoly.h	/^    MIntDict(const umap_uvec_mpz &p, unsigned int sz) : UDictWrapper(p, sz)$/;"	f	class:SymEngine::MIntDict
MIntDict	symengine/polys/msymenginepoly.h	/^    MIntDict(umap_uvec_mpz &&p, unsigned int sz)$/;"	f	class:SymEngine::MIntDict
MIntDict	symengine/polys/msymenginepoly.h	/^class MIntDict : public UDictWrapper<vec_uint, integer_class, MIntDict>$/;"	c	namespace:SymEngine
MIntPoly	symengine/polys/msymenginepoly.h	/^    MIntPoly(const set_basic &vars, MIntDict &&dict)$/;"	f	class:SymEngine::MIntPoly
MIntPoly	symengine/polys/msymenginepoly.h	/^class MIntPoly : public MSymEnginePoly<MIntDict, MIntPoly>$/;"	c	namespace:SymEngine
MSubsVisitor	symengine/subs.h	/^    MSubsVisitor(const map_basic_basic &d)$/;"	f	class:SymEngine::MSubsVisitor
MSubsVisitor	symengine/subs.h	/^class MSubsVisitor : public BaseVisitor<MSubsVisitor, XReplaceVisitor>$/;"	c	namespace:SymEngine
MSymEnginePoly	symengine/polys/msymenginepoly.h	/^    MSymEnginePoly(const set_basic &vars, Container &&dict)$/;"	f	class:SymEngine::MSymEnginePoly
MSymEnginePoly	symengine/polys/msymenginepoly.h	/^class MSymEnginePoly : public Basic$/;"	c	namespace:SymEngine
MatchAllOf	symengine/utilities/catch/catch.hpp	/^        struct MatchAllOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchAnyOf	symengine/utilities/catch/catch.hpp	/^        struct MatchAnyOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatchNotOf	symengine/utilities/catch/catch.hpp	/^            MatchNotOf( MatcherBase<ArgT> const& underlyingMatcher ) : m_underlyingMatcher( underlyingMatcher ) {}$/;"	f	struct:Catch::Matchers::Impl::MatchNotOf
MatchNotOf	symengine/utilities/catch/catch.hpp	/^        struct MatchNotOf : MatcherBase<ArgT> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherBase	symengine/utilities/catch/catch.hpp	/^        struct MatcherBase : MatcherUntypedBase, MatcherMethod<ObjectT> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherMethod	symengine/utilities/catch/catch.hpp	/^        struct MatcherMethod {$/;"	s	namespace:Catch::Matchers::Impl
MatcherMethod	symengine/utilities/catch/catch.hpp	/^        struct MatcherMethod<PtrT*> {$/;"	s	namespace:Catch::Matchers::Impl
MatcherUntypedBase	symengine/utilities/catch/catch.hpp	/^        class MatcherUntypedBase {$/;"	c	namespace:Catch::Matchers::Impl
Matchers	symengine/utilities/catch/catch.hpp	/^namespace Matchers {$/;"	n	namespace:Catch
MathMLPrinter	symengine/printers/mathml.h	/^class MathMLPrinter : public BaseVisitor<MathMLPrinter, StrPrinter>$/;"	c	namespace:SymEngine
MatrixBase	symengine/matrix.h	/^class MatrixBase$/;"	c	namespace:SymEngine
Max	symengine/functions.cpp	/^Max::Max(const vec_basic &&arg) : MultiArgFunction(std::move(arg))$/;"	f	class:SymEngine::Max
Max	symengine/functions.h	/^class Max : public MultiArgFunction$/;"	c	namespace:SymEngine
Mesh	symengine/tests/rcp/test_rcp.cpp	/^class Mesh : public EnableRCPFromThis<Mesh>$/;"	c	file:
Mesh2	symengine/tests/rcp/test_rcp.cpp	/^class Mesh2 : public EnableRCPFromThis<const Mesh2>$/;"	c	file:
Meta__	symengine/parser/parserbase.h	/^namespace Meta__$/;"	n	namespace:SymEngine
MethodTestCase	symengine/utilities/catch/catch.hpp	/^    MethodTestCase( void (C::*method)() ) : m_method( method ) {}$/;"	f	class:Catch::MethodTestCase
MethodTestCase	symengine/utilities/catch/catch.hpp	/^class MethodTestCase : public SharedImpl<ITestCase> {$/;"	c	namespace:Catch
Min	symengine/functions.cpp	/^Min::Min(const vec_basic &&arg) : MultiArgFunction(std::move(arg))$/;"	f	class:SymEngine::Min
Min	symengine/functions.h	/^class Min : public MultiArgFunction$/;"	c	namespace:SymEngine
Mul	symengine/mul.cpp	/^Mul::Mul(const RCP<const Number> &coef, map_basic_basic &&dict)$/;"	f	class:SymEngine::Mul
Mul	symengine/mul.h	/^class Mul : public Basic$/;"	c	namespace:SymEngine
Mul	symengine/printers/strprinter.h	/^enum class PrecedenceEnum { Relational, Add, Mul, Pow, Atom };$/;"	m	class:SymEngine::PrecedenceEnum
MultiArgFunction	symengine/functions.h	/^    MultiArgFunction(const vec_basic &arg) : arg_{arg} {};$/;"	f	class:SymEngine::MultiArgFunction
MultiArgFunction	symengine/functions.h	/^class MultiArgFunction : public Function$/;"	c	namespace:SymEngine
MySin	symengine/tests/basic/test_functions.cpp	/^    MySin(RCP<const Basic> arg) : FunctionWrapper("MySin", arg)$/;"	f	class:MySin
MySin	symengine/tests/basic/test_functions.cpp	/^class MySin : public FunctionWrapper$/;"	c	file:
MyStrPrinter	symengine/tests/printing/test_printing.cpp	/^class MyStrPrinter : public BaseVisitor<MyStrPrinter, StrPrinter>$/;"	c	namespace:SymEngine	file:
NOMINMAX	symengine/utilities/catch/catch.hpp	/^#  define NOMINMAX$/;"	d
NOMINMAX	symengine/utilities/catch/catch.hpp	/^#  undef NOMINMAX$/;"	d
NONIUS_ARGPARSE_HPP	benchmarks/nonius.h++	/^#define NONIUS_ARGPARSE_HPP$/;"	d
NONIUS_BENCHMARK	benchmarks/nonius.h++	/^#define NONIUS_BENCHMARK(/;"	d
NONIUS_BENCHMARK_HPP	benchmarks/nonius.h++	/^#define NONIUS_BENCHMARK_HPP$/;"	d
NONIUS_BENCHMARK_RESULTS_HPP	benchmarks/nonius.h++	/^#define NONIUS_BENCHMARK_RESULTS_HPP$/;"	d
NONIUS_CHRONOMETER_HPP	benchmarks/nonius.h++	/^#define NONIUS_CHRONOMETER_HPP$/;"	d
NONIUS_CLOCK_HPP	benchmarks/nonius.h++	/^#define NONIUS_CLOCK_HPP$/;"	d
NONIUS_CONFIGURATION_HPP	benchmarks/nonius.h++	/^#define NONIUS_CONFIGURATION_HPP$/;"	d
NONIUS_CONSTRUCTOR_HPP	benchmarks/nonius.h++	/^#define NONIUS_CONSTRUCTOR_HPP$/;"	d
NONIUS_DETAIL_ANALYSE_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_ANALYSE_HPP$/;"	d
NONIUS_DETAIL_ANALYSIS_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_ANALYSIS_HPP$/;"	d
NONIUS_DETAIL_BENCHMARK_FUNCTION_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_BENCHMARK_FUNCTION_HPP$/;"	d
NONIUS_DETAIL_COMPLETE_INVOKE_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_COMPLETE_INVOKE_HPP$/;"	d
NONIUS_DETAIL_ENVIRONMENT_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_ENVIRONMENT_HPP$/;"	d
NONIUS_DETAIL_ESCAPE_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_ESCAPE_HPP$/;"	d
NONIUS_DETAIL_MEASURE_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_MEASURE_HPP$/;"	d
NONIUS_DETAIL_MISMATCH_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_MISMATCH_HPP$/;"	d
NONIUS_DETAIL_NOEXCEPT_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_NOEXCEPT_HPP$/;"	d
NONIUS_DETAIL_REPEAT_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_REPEAT_HPP$/;"	d
NONIUS_DETAIL_TIMING_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_TIMING_HPP$/;"	d
NONIUS_DETAIL_UNIQUE_NAME	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_UNIQUE_NAME(/;"	d
NONIUS_DETAIL_UNIQUE_NAME_HPP	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_UNIQUE_NAME_HPP$/;"	d
NONIUS_DETAIL_UNIQUE_NAME_LINE	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_UNIQUE_NAME_LINE(/;"	d
NONIUS_DETAIL_UNIQUE_NAME_LINE_CAT	benchmarks/nonius.h++	/^#define NONIUS_DETAIL_UNIQUE_NAME_LINE_CAT(/;"	d
NONIUS_ENVIRONMENT_HPP	benchmarks/nonius.h++	/^#define NONIUS_ENVIRONMENT_HPP$/;"	d
NONIUS_ESTIMATE_HPP	benchmarks/nonius.h++	/^#define NONIUS_ESTIMATE_HPP$/;"	d
NONIUS_EXECUTION_PLAN_HPP	benchmarks/nonius.h++	/^#define NONIUS_EXECUTION_PLAN_HPP$/;"	d
NONIUS_GO_HPP	benchmarks/nonius.h++	/^#define NONIUS_GO_HPP$/;"	d
NONIUS_HPP	benchmarks/nonius.h++	/^#define NONIUS_HPP$/;"	d
NONIUS_MAIN_HPP	benchmarks/nonius.h++	/^#define NONIUS_MAIN_HPP$/;"	d
NONIUS_NOEXCEPT	benchmarks/nonius.h++	/^#define NONIUS_NOEXCEPT /;"	d
NONIUS_OUTLIERS_HPP	benchmarks/nonius.h++	/^#define NONIUS_OUTLIERS_HPP$/;"	d
NONIUS_PRETTY_PRINT_HPP	benchmarks/nonius.h++	/^#define NONIUS_PRETTY_PRINT_HPP$/;"	d
NONIUS_REPORTER	benchmarks/nonius.h++	/^#define NONIUS_REPORTER(/;"	d
NONIUS_REPORTERS_CSV_REPORTER_HPP	benchmarks/nonius.h++	/^#define NONIUS_REPORTERS_CSV_REPORTER_HPP$/;"	d
NONIUS_REPORTERS_HTML_ALL_REPORTER_HPP	benchmarks/nonius.h++	/^#define NONIUS_REPORTERS_HTML_ALL_REPORTER_HPP$/;"	d
NONIUS_REPORTERS_JUNIT_REPORTER_HPP	benchmarks/nonius.h++	/^#define NONIUS_REPORTERS_JUNIT_REPORTER_HPP$/;"	d
NONIUS_REPORTERS_STANDARD_REPORTER_HPP	benchmarks/nonius.h++	/^#define NONIUS_REPORTERS_STANDARD_REPORTER_HPP$/;"	d
NONIUS_REPORTER_HPP	benchmarks/nonius.h++	/^#define NONIUS_REPORTER_HPP$/;"	d
NONIUS_RUNNER	benchmarks/bench.cpp	/^#define NONIUS_RUNNER$/;"	d	file:
NONIUS_RUNNER	benchmarks/bench_eval_double.cpp	/^#define NONIUS_RUNNER$/;"	d	file:
NONIUS_RUN_FOR_AT_LEAST_HPP	benchmarks/nonius.h++	/^#define NONIUS_RUN_FOR_AT_LEAST_HPP$/;"	d
NONIUS_SINGLE_INCLUDE_HPP	benchmarks/nonius.h++	/^#define NONIUS_SINGLE_INCLUDE_HPP$/;"	d
NONIUS_TIMEOUT_ERROR_HPP	benchmarks/nonius.h++	/^#define NONIUS_TIMEOUT_ERROR_HPP$/;"	d
NONIUS_USE_BOOST_CHRONO	benchmarks/nonius.h++	/^#define NONIUS_USE_BOOST_CHRONO$/;"	d
NORMAL	symengine/parser/parser.cpp	/^{ NORMAL,$/;"	e	enum:__anon29::StateType	file:
NORMAL	symengine/parser/parser.cpp	/^{ NORMAL,$/;"	e	enum:__anon8::StateType	file:
NOT	symengine/parser/parserbase.h	/^        NOT,$/;"	e	enum:SymEngine::ParserBase::Tokens__
NUMERIC	symengine/parser/parserbase.h	/^        NUMERIC,$/;"	e	enum:SymEngine::ParserBase::Tokens__
NaN	symengine/nan.cpp	/^NaN::NaN()$/;"	f	class:SymEngine::NaN
NaN	symengine/nan.h	/^class NaN : public Number$/;"	c	namespace:SymEngine
NameAndDesc	symengine/utilities/catch/catch.hpp	/^    NameAndDesc( const char* _name = "", const char* _description= "" )$/;"	f	struct:Catch::NameAndDesc
NameAndDesc	symengine/utilities/catch/catch.hpp	/^struct NameAndDesc {$/;"	s	namespace:Catch
Nan	symengine/constants.cpp	/^RCP<const NaN> Nan = make_rcp<NaN>();$/;"	m	namespace:SymEngine	file:
Ne	symengine/logic.cpp	/^RCP<const Boolean> Ne(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	namespace:SymEngine
NeedsSymbolicExpansionVisitor	symengine/series_visitor.h	/^class NeedsSymbolicExpansionVisitor$/;"	c	namespace:SymEngine
NegInf	symengine/constants.cpp	/^RCP<const Infty> NegInf = Infty::from_int(-1);$/;"	m	namespace:SymEngine	file:
No	symengine/utilities/catch/catch.hpp	/^        No$/;"	e	enum:Catch::CaseSensitive::Choice
NonConstType	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^  typedef typename UnConst<T>::Result NonConstType;$/;"	t	class:Teuchos::ConstTypeTraits
NonCopyable	symengine/utilities/catch/catch.hpp	/^        NonCopyable() {}$/;"	f	class:Catch::NonCopyable
NonCopyable	symengine/utilities/catch/catch.hpp	/^    class NonCopyable {$/;"	c	namespace:Catch
NonconstAccessError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class NonconstAccessError : public ExceptionBase$/;"	c	namespace:Teuchos
NonconstAccessError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:NonconstAccessError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::NonconstAccessError
Normal	symengine/utilities/catch/catch.hpp	/^        Normal = 0x01,$/;"	e	enum:Catch::ResultDisposition::Flags
Not	symengine/logic.cpp	/^Not::Not(const RCP<const Boolean> &in) : arg_{in}$/;"	f	class:SymEngine::Not
Not	symengine/logic.h	/^class Not : public Boolean$/;"	c	namespace:SymEngine
Not	symengine/utilities/catch/catch.hpp	/^    Impl::MatchNotOf<T> Not( Impl::MatcherBase<T> const& underlyingMatcher ) {$/;"	f	namespace:Catch::Matchers
NotImplementedError	symengine/symengine_exception.h	/^    NotImplementedError(const std::string &msg)$/;"	f	class:SymEngine::NotImplementedError
NotImplementedError	symengine/symengine_exception.h	/^class NotImplementedError : public SymEngineException$/;"	c	namespace:SymEngine
NotImplementedException	symengine/utilities/catch/catch.hpp	/^    class NotImplementedException : public std::exception$/;"	c	namespace:Catch
NullIteratorTraits	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^class NullIteratorTraits {$/;"	c	namespace:Teuchos
NullIteratorTraits	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^class NullIteratorTraits<std::reverse_iterator<Iter> > {$/;"	c	namespace:Teuchos
NullIteratorTraits	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class NullIteratorTraits<RCP<T> > {$/;"	c	namespace:Teuchos
NullReferenceError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class NullReferenceError : public ExceptionBase$/;"	c	namespace:Teuchos
NullReferenceError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:NullReferenceError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::NullReferenceError
Number	symengine/number.h	/^class Number : public Basic$/;"	c	namespace:SymEngine
NumberWrapper	symengine/number.h	/^    NumberWrapper()$/;"	f	class:SymEngine::NumberWrapper
NumberWrapper	symengine/number.h	/^class NumberWrapper : public Number$/;"	c	namespace:SymEngine
NumerDenomVisitor	symengine/numer_denom.cpp	/^    NumerDenomVisitor(const Ptr<RCP<const Basic>> &numer,$/;"	f	class:SymEngine::NumerDenomVisitor
NumerDenomVisitor	symengine/numer_denom.cpp	/^class NumerDenomVisitor : public BaseVisitor<NumerDenomVisitor>$/;"	c	namespace:SymEngine	file:
OC_TEST_CASE	symengine/utilities/catch/catch.hpp	/^#define OC_TEST_CASE(/;"	d
ODictWrapper	symengine/polys/upolybase.h	/^    ODictWrapper(const Value &p)$/;"	f	class:SymEngine::ODictWrapper
ODictWrapper	symengine/polys/upolybase.h	/^    ODictWrapper(const int &i)$/;"	f	class:SymEngine::ODictWrapper
ODictWrapper	symengine/polys/upolybase.h	/^    ODictWrapper(const std::map<Key, Value> &p)$/;"	f	class:SymEngine::ODictWrapper
ODictWrapper	symengine/polys/upolybase.h	/^    ODictWrapper(std::map<Key, Value> &&p)$/;"	f	class:SymEngine::ODictWrapper
ODictWrapper	symengine/polys/upolybase.h	/^    ODictWrapper(std::string s)$/;"	f	class:SymEngine::ODictWrapper
ODictWrapper	symengine/polys/upolybase.h	/^class ODictWrapper$/;"	c	namespace:SymEngine
ONE_ARG_EXTERNAL_FUNCTION	symengine/llvm_double.cpp	/^#define ONE_ARG_EXTERNAL_FUNCTION(/;"	d	file:
OPERATORS	symengine/parser/parser_old.cpp	/^    std::set<std::string> OPERATORS$/;"	m	class:SymEngine::ExpressionParser	file:
OfType	symengine/utilities/catch/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	g	struct:Catch::ResultWas
Ok	symengine/utilities/catch/catch.hpp	/^        Ok = 0,$/;"	e	enum:Catch::ResultWas::OfType
OneArgFunction	symengine/functions.h	/^    OneArgFunction(const RCP<const Basic> &arg) : arg_{arg} {};$/;"	f	class:SymEngine::OneArgFunction
OneArgFunction	symengine/functions.h	/^class OneArgFunction : public Function$/;"	c	namespace:SymEngine
Operator	symengine/utilities/catch/catch.hpp	/^    enum Operator {$/;"	g	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	s	namespace:Catch::Internal
OperatorTraits	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	s	namespace:Catch::Internal
OptsCSEVisitor	symengine/cse.cpp	/^    OptsCSEVisitor(umap_basic_basic &opt_subs_) : opt_subs(opt_subs_)$/;"	f	class:SymEngine::OptsCSEVisitor
OptsCSEVisitor	symengine/cse.cpp	/^class OptsCSEVisitor : public BaseVisitor<OptsCSEVisitor>$/;"	c	namespace:SymEngine	file:
Or	symengine/logic.cpp	/^Or::Or(const set_boolean &s) : container_{s}$/;"	f	class:SymEngine::Or
Or	symengine/logic.h	/^class Or : public Boolean$/;"	c	namespace:SymEngine
Ordinal	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^namespace Teuchos { typedef Teuchos_Ordinal Ordinal; }$/;"	t	namespace:Teuchos
PAPER	doc/Makefile	/^PAPER         =$/;"	m
PAPEROPT_a4	doc/Makefile	/^PAPEROPT_a4     = -D latex_paper_size=a4$/;"	m
PAPEROPT_letter	doc/Makefile	/^PAPEROPT_letter = -D latex_paper_size=letter$/;"	m
PARSE_ABORT__	symengine/parser/parserbase.h	/^        PARSE_ABORT__ = 1$/;"	e	enum:SymEngine::ParserBase::Return__
PARSE_ACCEPT	symengine/parser/parser.cpp	/^    PARSE_ACCEPT = 0, \/\/ `ACCEPT' TRANSITION$/;"	e	enum:__anon29::ReservedTokens	file:
PARSE_ACCEPT	symengine/parser/parser.cpp	/^    PARSE_ACCEPT = 0, \/\/ `ACCEPT' TRANSITION$/;"	e	enum:__anon8::ReservedTokens	file:
PARSE_ACCEPT__	symengine/parser/parserbase.h	/^        PARSE_ACCEPT__ = 0, \/\/ values used as parse()'s return values$/;"	e	enum:SymEngine::ParserBase::Return__
PI__	symengine/parser/parser.cpp	/^struct PI__ \/\/ Production Info$/;"	s	namespace:__anon29	file:
PI__	symengine/parser/parser.cpp	/^struct PI__ \/\/ Production Info$/;"	s	namespace:__anon8	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define PLATFORM_ID$/;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define PLATFORM_ID /;"	d	file:
PLATFORM_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^# define PLATFORM_ID$/;"	d	file:
POP	symengine/parser/scannerbase.h	/^        POP,    \/\/ postCode called after switching files$/;"	m	class:SymEngine::ScannerBase::PostEnum__
POST_DESTROY	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };$/;"	e	enum:Teuchos::EPrePostDestruction
POW	symengine/parser/parserbase.h	/^        POW,$/;"	e	enum:SymEngine::ParserBase::Tokens__
PRE_DESTROY	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum EPrePostDestruction { PRE_DESTROY, POST_DESTROY };$/;"	e	enum:Teuchos::EPrePostDestruction
ParseError	symengine/symengine_exception.h	/^    ParseError(const std::string &msg)$/;"	f	class:SymEngine::ParseError
ParseError	symengine/symengine_exception.h	/^class ParseError : public SymEngineException$/;"	c	namespace:SymEngine
Parser	symengine/parser/parser.h	/^    inline Parser(const std::string &input, bool convert_xor_)$/;"	f	class:SymEngine::Parser
Parser	symengine/parser/parser.h	/^#undef Parser$/;"	d
Parser	symengine/parser/parser.h	/^class Parser : public ParserBase$/;"	c	namespace:SymEngine
Parser	symengine/parser/parserbase.h	/^#define Parser /;"	d
ParserBase	symengine/parser/parser.cpp	/^ParserBase::ParserBase()$/;"	f	class:SymEngine::ParserBase
ParserBase	symengine/parser/parserbase.h	/^class ParserBase$/;"	c	namespace:SymEngine
Piecewise	symengine/logic.cpp	/^Piecewise::Piecewise(PiecewiseVec &&vec) : vec_(vec)$/;"	f	class:SymEngine::Piecewise
Piecewise	symengine/logic.h	/^class Piecewise : public Basic$/;"	c	namespace:SymEngine
PiecewiseVec	symengine/logic.h	/^    PiecewiseVec;$/;"	t	namespace:SymEngine
PiranhaForIter	symengine/polys/uintpoly_piranha.h	/^    PiranhaForIter(ptr_type ptr) : ptr_{ptr}$/;"	f	class:SymEngine::PiranhaForIter
PiranhaForIter	symengine/polys/uintpoly_piranha.h	/^class PiranhaForIter$/;"	c	namespace:SymEngine
PolyGamma	symengine/functions.h	/^    PolyGamma(const RCP<const Basic> &n, const RCP<const Basic> &x)$/;"	f	class:SymEngine::PolyGamma
PolyGamma	symengine/functions.h	/^class PolyGamma : public TwoArgFunction$/;"	c	namespace:SymEngine
PolyGeneratorVisitor	symengine/polys/basic_conversions.cpp	/^class PolyGeneratorVisitor : public BaseVisitor<PolyGeneratorVisitor>$/;"	c	namespace:SymEngine	file:
PolyGeneratorVisitorPow	symengine/polys/basic_conversions.cpp	/^class PolyGeneratorVisitorPow : public BaseVisitor<PolyGeneratorVisitorPow>$/;"	c	namespace:SymEngine	file:
PostEnum__	symengine/parser/scannerbase.h	/^    enum class PostEnum__ {$/;"	c	class:SymEngine::ScannerBase
Pow	symengine/pow.cpp	/^Pow::Pow(const RCP<const Basic> &base, const RCP<const Basic> &exp)$/;"	f	class:SymEngine::Pow
Pow	symengine/pow.h	/^class Pow : public Basic$/;"	c	namespace:SymEngine
Pow	symengine/printers/strprinter.h	/^enum class PrecedenceEnum { Relational, Add, Mul, Pow, Atom };$/;"	m	class:SymEngine::PrecedenceEnum
Precedence	symengine/printers/strprinter.h	/^class Precedence : public BaseVisitor<Precedence>$/;"	c	namespace:SymEngine
PrecedenceEnum	symengine/printers/strprinter.h	/^enum class PrecedenceEnum { Relational, Add, Mul, Pow, Atom };$/;"	c	namespace:SymEngine
PrinterBasicCmp	symengine/printers/strprinter.cpp	/^struct PrinterBasicCmp {$/;"	s	namespace:SymEngine	file:
Ptr	build/cmake/checkcxx11.cpp	/^    inline Ptr(const Ptr<T>& ptr) : ptr_(ptr.ptr_) {}$/;"	f	class:Ptr
Ptr	build/cmake/checkcxx11.cpp	/^    inline explicit Ptr( T *ptr ) : ptr_(ptr) {$/;"	f	class:Ptr
Ptr	build/cmake/checkcxx11.cpp	/^    template<class T2> inline Ptr(const Ptr<T2>& ptr) : ptr_(ptr.get()) {}$/;"	f	class:Ptr
Ptr	build/cmake/checkcxx11.cpp	/^class Ptr {$/;"	c	file:
Ptr	cmake/checkcxx11.cpp	/^    inline Ptr(const Ptr<T>& ptr) : ptr_(ptr.ptr_) {}$/;"	f	class:Ptr
Ptr	cmake/checkcxx11.cpp	/^    inline explicit Ptr( T *ptr ) : ptr_(ptr) {$/;"	f	class:Ptr
Ptr	cmake/checkcxx11.cpp	/^    template<class T2> inline Ptr(const Ptr<T2>& ptr) : ptr_(ptr.get()) {}$/;"	f	class:Ptr
Ptr	cmake/checkcxx11.cpp	/^class Ptr {$/;"	c	file:
Ptr	symengine/symengine_rcp.h	/^    inline Ptr(const Ptr<T2> &ptr) : ptr_(ptr.get())$/;"	f	class:SymEngine::Ptr
Ptr	symengine/symengine_rcp.h	/^    inline Ptr(const Ptr<T> &ptr) : ptr_(ptr.ptr_)$/;"	f	class:SymEngine::Ptr
Ptr	symengine/symengine_rcp.h	/^    inline explicit Ptr(T *ptr) : ptr_(ptr)$/;"	f	class:SymEngine::Ptr
Ptr	symengine/symengine_rcp.h	/^class Ptr$/;"	c	namespace:SymEngine
Ptr	symengine/utilities/catch/catch.hpp	/^        Ptr( Ptr const& other ) : m_p( other.m_p ){$/;"	f	class:Catch::Ptr
Ptr	symengine/utilities/catch/catch.hpp	/^        Ptr( T* p ) : m_p( p ){$/;"	f	class:Catch::Ptr
Ptr	symengine/utilities/catch/catch.hpp	/^        Ptr() : m_p( CATCH_NULL ){}$/;"	f	class:Catch::Ptr
Ptr	symengine/utilities/catch/catch.hpp	/^    class Ptr {$/;"	c	namespace:Catch
Ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>::Ptr( ENull \/*null_in*\/ )$/;"	f	class:Teuchos::Ptr
Ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>::Ptr( T *ptr_in )$/;"	f	class:Teuchos::Ptr
Ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>::Ptr( const RCP<T> &p )$/;"	f	class:Teuchos::Ptr
Ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>::Ptr(const Ptr<T2>& ptr_in)$/;"	f	class:Teuchos::Ptr
Ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>::Ptr(const Ptr<T>& ptr_in)$/;"	f	class:Teuchos::Ptr
Ptr	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^class Ptr {$/;"	c	namespace:Teuchos
PtrPrivateUtilityPack	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^namespace PtrPrivateUtilityPack {$/;"	n	namespace:Teuchos
QR	symengine/dense_matrix.cpp	/^void QR(const DenseMatrix &A, DenseMatrix &Q, DenseMatrix &R)$/;"	f	namespace:SymEngine
R1	benchmarks/symbench.cpp	/^double R1()$/;"	f
R1	benchmarks/symbench_ginac.cpp	/^double R1()$/;"	f
R2	benchmarks/symbench.cpp	/^double R2()$/;"	f
R2	benchmarks/symbench_ginac.cpp	/^double R2()$/;"	f
R3	benchmarks/symbench.cpp	/^double R3()$/;"	f
R3	benchmarks/symbench_ginac.cpp	/^double R3()$/;"	f
R5	benchmarks/symbench.cpp	/^double R5()$/;"	f
R5	benchmarks/symbench_ginac.cpp	/^double R5()$/;"	f
R7	benchmarks/symbench.cpp	/^double R7()$/;"	f
R7	benchmarks/symbench_ginac.cpp	/^double R7()$/;"	f
R8	benchmarks/symbench.cpp	/^double R8()$/;"	f
R8	benchmarks/symbench_ginac.cpp	/^double R8()$/;"	f
RCP	build/cmake/checkcxx11.cpp	/^    RCP(ENull null_arg = null) : ptr_(NULL) {}$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^    RCP(RCP<T> &&rp) : ptr_(rp.ptr_) {$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^    RCP(const RCP<T> &rp) : ptr_(rp.ptr_) {$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^    explicit RCP(T *p) : ptr_(p) {$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^    template<class T2> RCP(RCP<T2>&& r_ptr) : ptr_(r_ptr.get()) {$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^    template<class T2> RCP(const RCP<T2>& r_ptr) : ptr_(r_ptr.get()) {$/;"	f	class:RCP
RCP	build/cmake/checkcxx11.cpp	/^class RCP {$/;"	c	file:
RCP	cmake/checkcxx11.cpp	/^    RCP(ENull null_arg = null) : ptr_(NULL) {}$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^    RCP(RCP<T> &&rp) : ptr_(rp.ptr_) {$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^    RCP(const RCP<T> &rp) : ptr_(rp.ptr_) {$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^    explicit RCP(T *p) : ptr_(p) {$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^    template<class T2> RCP(RCP<T2>&& r_ptr) : ptr_(r_ptr.get()) {$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^    template<class T2> RCP(const RCP<T2>& r_ptr) : ptr_(r_ptr.get()) {$/;"	f	class:RCP
RCP	cmake/checkcxx11.cpp	/^class RCP {$/;"	c	file:
RCP	symengine/symengine_rcp.h	/^    RCP(ENull null_arg = null) : ptr_(nullptr)$/;"	f	class:SymEngine::RCP
RCP	symengine/symengine_rcp.h	/^    RCP(const RCP<T2> &r_ptr) : ptr_(r_ptr.get())$/;"	f	class:SymEngine::RCP
RCP	symengine/symengine_rcp.h	/^    RCP(const RCP<T> &rp) : ptr_(rp.ptr_)$/;"	f	class:SymEngine::RCP
RCP	symengine/symengine_rcp.h	/^    explicit RCP(T *p) : ptr_(p)$/;"	f	class:SymEngine::RCP
RCP	symengine/symengine_rcp.h	/^class RCP$/;"	c	namespace:SymEngine
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( ENull )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, Dealloc_T dealloc, ERCPUndefinedWithDealloc, bool has_ownership_in )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, Dealloc_T dealloc, bool has_ownership_in )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, ERCPUndefinedWeakNoDealloc )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, ERCPWeakNoDealloc )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, bool has_ownership_in )$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP( T* p, const RCPNodeHandle& node)$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP(const RCP<T2>& r_ptr)$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::RCP(const RCP<T>& r_ptr)$/;"	f	class:Teuchos::RCP
RCP	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^class RCP {$/;"	c	namespace:Teuchos
RCPBasicHash	symengine/basic.h	/^struct RCPBasicHash {$/;"	s	namespace:SymEngine
RCPBasicKeyEq	symengine/basic.h	/^struct RCPBasicKeyEq {$/;"	s	namespace:SymEngine
RCPBasicKeyLess	symengine/basic.h	/^struct RCPBasicKeyLess {$/;"	s	namespace:SymEngine
RCPComp	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^struct RCPComp {$/;"	s	namespace:Teuchos
RCPConstComp	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^struct RCPConstComp {$/;"	s	namespace:Teuchos
RCPIntegerKeyLess	symengine/integer.h	/^struct RCPIntegerKeyLess {$/;"	s	namespace:SymEngine
RCPNode	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNode(bool has_ownership_in)$/;"	f	class:Teuchos::RCPNode
RCPNode	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT RCPNode {$/;"	c	namespace:Teuchos
RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle( RCPNode* node, ERCPStrength strength_in = RCP_STRONG,$/;"	f	class:Teuchos::RCPNodeHandle
RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle(ENull null_arg = null)$/;"	f	class:Teuchos::RCPNodeHandle
RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle(RCPNode* node, T *p, const std::string &T_name,$/;"	f	class:Teuchos::RCPNodeHandle
RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle(const RCPNodeHandle& node_ref)$/;"	f	class:Teuchos::RCPNodeHandle
RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT RCPNodeHandle {$/;"	c	namespace:Teuchos
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  RCPNodeInfo() : nodePtr(0) {}$/;"	f	struct:__anon20::RCPNodeInfo
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  RCPNodeInfo() : nodePtr(0) {}$/;"	f	struct:__anon41::RCPNodeInfo
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  RCPNodeInfo(const std::string &info_in, Teuchos::RCPNode* nodePtr_in)$/;"	f	struct:__anon20::RCPNodeInfo
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  RCPNodeInfo(const std::string &info_in, Teuchos::RCPNode* nodePtr_in)$/;"	f	struct:__anon41::RCPNodeInfo
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^struct RCPNodeInfo {$/;"	s	namespace:__anon20	file:
RCPNodeInfo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^struct RCPNodeInfo {$/;"	s	namespace:__anon41	file:
RCPNodeInfoListPred	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^class RCPNodeInfoListPred {$/;"	c	namespace:__anon20	file:
RCPNodeInfoListPred	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^class RCPNodeInfoListPred {$/;"	c	namespace:__anon41	file:
RCPNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    RCPNodeStatistics()$/;"	f	struct:Teuchos::RCPNodeTracer::RCPNodeStatistics
RCPNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  struct RCPNodeStatistics {$/;"	s	class:Teuchos::RCPNodeTracer
RCPNodeThrowDeleter	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeThrowDeleter(RCPNode *node)$/;"	f	class:Teuchos::RCPNodeThrowDeleter
RCPNodeThrowDeleter	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT RCPNodeThrowDeleter {$/;"	c	namespace:Teuchos
RCPNodeTmpl	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeTmpl(T* p, Dealloc_T dealloc, bool has_ownership_in)$/;"	f	class:Teuchos::RCPNodeTmpl
RCPNodeTmpl	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeTmpl(T* p, Dealloc_T dealloc, bool has_ownership_in, ENull)$/;"	f	class:Teuchos::RCPNodeTmpl
RCPNodeTmpl	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class RCPNodeTmpl : public RCPNode {$/;"	c	namespace:Teuchos
RCPNodeTracer	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT RCPNodeTracer {$/;"	c	namespace:Teuchos
RCP_DISABLE_NODE_LOOKUP	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPNodeLookup { RCP_ENABLE_NODE_LOOKUP, RCP_DISABLE_NODE_LOOKUP };$/;"	e	enum:Teuchos::ERCPNodeLookup
RCP_ENABLE_NODE_LOOKUP	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPNodeLookup { RCP_ENABLE_NODE_LOOKUP, RCP_DISABLE_NODE_LOOKUP };$/;"	e	enum:Teuchos::ERCPNodeLookup
RCP_STRENGTH_INVALID	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPStrength { RCP_STRENGTH_INVALID=-1, RCP_STRONG=0, RCP_WEAK=1 };$/;"	e	enum:Teuchos::ERCPStrength
RCP_STRONG	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPStrength { RCP_STRENGTH_INVALID=-1, RCP_STRONG=0, RCP_WEAK=1 };$/;"	e	enum:Teuchos::ERCPStrength
RCP_UNDEFINED_WEAK_NO_DEALLOC	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPUndefinedWeakNoDealloc { RCP_UNDEFINED_WEAK_NO_DEALLOC };$/;"	e	enum:Teuchos::ERCPUndefinedWeakNoDealloc
RCP_UNDEFINED_WITH_DEALLOC	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPUndefinedWithDealloc { RCP_UNDEFINED_WITH_DEALLOC };$/;"	e	enum:Teuchos::ERCPUndefinedWithDealloc
RCP_WEAK	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^enum ERCPStrength { RCP_STRENGTH_INVALID=-1, RCP_STRONG=0, RCP_WEAK=1 };$/;"	e	enum:Teuchos::ERCPStrength
RCP_WEAK_NO_DEALLOC	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^enum ERCPWeakNoDealloc { RCP_WEAK_NO_DEALLOC };$/;"	e	enum:Teuchos::ERCPWeakNoDealloc
RCP_createNewDeallocRCPNodeRawPtr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNode* RCP_createNewDeallocRCPNodeRawPtr($/;"	f	namespace:Teuchos
RCP_createNewDeallocRCPNodeRawPtrUndefined	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNode* RCP_createNewDeallocRCPNodeRawPtrUndefined($/;"	f	namespace:Teuchos
RCP_createNewRCPNodeRawPtr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNode* RCP_createNewRCPNodeRawPtr( T* p, bool has_ownership_in )$/;"	f	namespace:Teuchos
RCP_createNewRCPNodeRawPtrNonowned	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNode* RCP_createNewRCPNodeRawPtrNonowned( T* p )$/;"	f	namespace:Teuchos
RCP_createNewRCPNodeRawPtrNonownedUndefined	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNode* RCP_createNewRCPNodeRawPtrNonownedUndefined( T* p )$/;"	f	namespace:Teuchos
REFCOUNTPTR_INLINE	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^#  define REFCOUNTPTR_INLINE /;"	d
REFCOUNTPTR_INLINE	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^#  define REFCOUNTPTR_INLINE$/;"	d
REQ_DEF	symengine/parser/parser.cpp	/^  REQ_DEF,    \/\/ REQ_TOKEN | DEF_RED$/;"	e	enum:__anon29::StateType	file:
REQ_DEF	symengine/parser/parser.cpp	/^  REQ_DEF,    \/\/ REQ_TOKEN | DEF_RED$/;"	e	enum:__anon8::StateType	file:
REQ_TOKEN	symengine/parser/parser.cpp	/^  REQ_TOKEN,$/;"	e	enum:__anon29::StateType	file:
REQ_TOKEN	symengine/parser/parser.cpp	/^  REQ_TOKEN,$/;"	e	enum:__anon8::StateType	file:
RETURN	symengine/parser/scannerbase.h	/^        RETURN,     \/\/ no further continuation, lex returns 0.$/;"	m	class:SymEngine::ScannerBase::ActionType__
RETURN	symengine/parser/scannerbase.h	/^        RETURN, \/\/ postCode called when lex__() returns$/;"	m	class:SymEngine::ScannerBase::PostEnum__
RM	build/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/benchmarks/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/basic/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/cwrapper/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/eval/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/expression/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/finitediff/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/logic/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/matrix/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/ntheory/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/polynomial/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/printing/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/tests/rcp/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RM	build/symengine/utilities/catch/Makefile	/^RM = \/usr\/local\/Cellar\/cmake\/3.13.3\/bin\/cmake -E remove -f$/;"	m
RangeError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^class RangeError : public ExceptionBase$/;"	c	namespace:Teuchos
RangeError	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^{public:RangeError(const std::string& what_arg) : ExceptionBase(what_arg) {}};$/;"	f	class:Teuchos::RangeError
Rational	symengine/rational.h	/^    Rational(rational_class &&_i) : i(std::move(_i))$/;"	f	class:SymEngine::Rational
Rational	symengine/rational.h	/^class Rational : public Number$/;"	c	namespace:SymEngine
Real	symengine/eval.h	/^    Real = 1,$/;"	m	class:SymEngine::EvalfDomain
RealDouble	symengine/real_double.cpp	/^RealDouble::RealDouble(double i)$/;"	f	class:SymEngine::RealDouble
RealDouble	symengine/real_double.h	/^class RealDouble : public Number$/;"	c	namespace:SymEngine
RealImagVisitor	symengine/as_real_imag.cpp	/^    RealImagVisitor(const Ptr<RCP<const Basic>> &real,$/;"	f	class:SymEngine::RealImagVisitor
RealImagVisitor	symengine/as_real_imag.cpp	/^class RealImagVisitor : public BaseVisitor<RealImagVisitor>$/;"	c	namespace:SymEngine	file:
RealMPFR	symengine/real_mpfr.cpp	/^RealMPFR::RealMPFR(mpfr_class i) : i{std::move(i)}$/;"	f	class:SymEngine::RealMPFR
RealMPFR	symengine/real_mpfr.h	/^class RealMPFR : public Number$/;"	c	namespace:SymEngine
RebuildVisitor	symengine/cse.cpp	/^    RebuildVisitor(umap_basic_basic &subs_, umap_basic_basic &opt_subs_,$/;"	f	class:SymEngine::RebuildVisitor
RebuildVisitor	symengine/cse.cpp	/^class RebuildVisitor : public BaseVisitor<RebuildVisitor, TransformVisitor>$/;"	c	namespace:SymEngine	file:
Relational	symengine/logic.cpp	/^Relational::Relational(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	class:SymEngine::Relational
Relational	symengine/logic.h	/^class Relational : public TwoArgBasic<Boolean>$/;"	c	namespace:SymEngine
Relational	symengine/printers/strprinter.h	/^enum class PrecedenceEnum { Relational, Add, Mul, Pow, Atom };$/;"	m	class:SymEngine::PrecedenceEnum
ReservedTokens	symengine/parser/parser.cpp	/^enum ReservedTokens {$/;"	g	namespace:__anon29	file:
ReservedTokens	symengine/parser/parser.cpp	/^enum ReservedTokens {$/;"	g	namespace:__anon8	file:
Result	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^  { typedef U Result; };$/;"	t	struct:Teuchos::ConstTypeTraits::UnConst
ResultBuilder	symengine/utilities/catch/catch.hpp	/^    class ResultBuilder : public DecomposedExpression {$/;"	c	namespace:Catch
ResultDisposition	symengine/utilities/catch/catch.hpp	/^    struct ResultDisposition { enum Flags {$/;"	s	namespace:Catch
ResultWas	symengine/utilities/catch/catch.hpp	/^    struct ResultWas { enum OfType {$/;"	s	namespace:Catch
Return__	symengine/parser/parserbase.h	/^    enum Return__ {$/;"	g	class:SymEngine::ParserBase
RewriteAsExp	symengine/rewrite.cpp	/^    RewriteAsExp() : BaseVisitor<RewriteAsExp, TransformVisitor>()$/;"	f	class:SymEngine::RewriteAsExp
RewriteAsExp	symengine/rewrite.cpp	/^class RewriteAsExp : public BaseVisitor<RewriteAsExp, TransformVisitor>$/;"	c	namespace:SymEngine	file:
Ropen	symengine/sets.cpp	/^RCP<const Set> Interval::Ropen() const$/;"	f	class:SymEngine::Interval
S1	benchmarks/symbench.cpp	/^double S1()$/;"	f
S1	benchmarks/symbench_ginac.cpp	/^double S1()$/;"	f
S2	benchmarks/symbench.cpp	/^double S2()$/;"	f
S2	benchmarks/symbench_ginac.cpp	/^double S2()$/;"	f
S3	benchmarks/symbench.cpp	/^double S3()$/;"	f
S3	benchmarks/symbench_ginac.cpp	/^double S3()$/;"	f
S3a	benchmarks/symbench.cpp	/^double S3a()$/;"	f
S3a	benchmarks/symbench_ginac.cpp	/^double S3a()$/;"	f
SC	symengine/parser/scannerbase.h	/^inline ScannerBase::StartCondition__ constexpr ScannerBase::SC(int sc)$/;"	f	class:SymEngine::ScannerBase
SC	symengine/parser/scannerbase.h	/^inline int constexpr ScannerBase::SC(StartCondition__ sc)$/;"	f	class:SymEngine::ScannerBase
SCENARIO	symengine/utilities/catch/catch.hpp	/^#define SCENARIO(/;"	d
SCENARIO_METHOD	symengine/utilities/catch/catch.hpp	/^#define SCENARIO_METHOD(/;"	d
SET_RCPNODE_TRACING	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^#  define SET_RCPNODE_TRACING(/;"	d
SHELL	build/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/benchmarks/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/basic/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/cwrapper/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/eval/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/expression/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/finitediff/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/logic/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/matrix/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/ntheory/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/polynomial/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/printing/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/tests/rcp/Makefile	/^SHELL = \/bin\/sh$/;"	m
SHELL	build/symengine/utilities/catch/Makefile	/^SHELL = \/bin\/sh$/;"	m
SIMULATE_ID	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_ID /;"	d	file:
SIMULATE_ID	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_ID /;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_VERSION_MAJOR /;"	d	file:
SIMULATE_VERSION_MAJOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_VERSION_MAJOR /;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#  define SIMULATE_VERSION_MINOR /;"	d	file:
SIMULATE_VERSION_MINOR	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#  define SIMULATE_VERSION_MINOR /;"	d	file:
SPHINXBUILD	doc/Makefile	/^SPHINXBUILD   = sphinx-build$/;"	m
SPHINXOPTS	doc/Makefile	/^SPHINXOPTS    =$/;"	m
SR__	symengine/parser/parser.cpp	/^struct SR__ \/\/ Shift Reduce info, see its description above$/;"	s	namespace:__anon29	file:
SR__	symengine/parser/parser.cpp	/^struct SR__ \/\/ Shift Reduce info, see its description above$/;"	s	namespace:__anon8	file:
SSubsVisitor	symengine/subs.h	/^    SSubsVisitor(const map_basic_basic &d)$/;"	f	class:SymEngine::SSubsVisitor
SSubsVisitor	symengine/subs.h	/^class SSubsVisitor : public BaseVisitor<SSubsVisitor, SubsVisitor>$/;"	c	namespace:SymEngine
STACK_EXPANSION	symengine/parser/parser.cpp	/^    STACK_EXPANSION = 5 \/\/ size to expand the state-stack with when$/;"	e	enum:__anon29::__anon30	file:
STACK_EXPANSION	symengine/parser/parser.cpp	/^    STACK_EXPANSION = 5 \/\/ size to expand the state-stack with when$/;"	e	enum:__anon8::__anon9	file:
STITCH_CLARA_CLOSE_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#define STITCH_CLARA_CLOSE_NAMESPACE$/;"	d
STITCH_CLARA_CLOSE_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#undef STITCH_CLARA_CLOSE_NAMESPACE$/;"	d
STITCH_CLARA_OPEN_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#define STITCH_CLARA_OPEN_NAMESPACE /;"	d
STITCH_CLARA_OPEN_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#define STITCH_CLARA_OPEN_NAMESPACE$/;"	d
STITCH_CLARA_OPEN_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#undef STITCH_CLARA_OPEN_NAMESPACE$/;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#define STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE /;"	d
STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE	symengine/utilities/catch/catch.hpp	/^#undef STITCH_TBC_TEXT_FORMAT_OPEN_NAMESPACE$/;"	d
STRINGIFY	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#define STRINGIFY(/;"	d	file:
STRINGIFY	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define STRINGIFY(/;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^#define STRINGIFY_HELPER(/;"	d	file:
STRINGIFY_HELPER	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^#define STRINGIFY_HELPER(/;"	d	file:
STYPE__	symengine/parser/parserbase.h	/^    typedef Meta__::SType STYPE__;$/;"	t	class:SymEngine::ParserBase
SType	symengine/parser/parserbase.h	/^inline SType::SType()$/;"	f	class:SymEngine::Meta__::SType
SType	symengine/parser/parserbase.h	/^struct SType : public std::shared_ptr<Base> {$/;"	s	namespace:SymEngine::Meta__
SUFFIXES	build/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/benchmarks/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/basic/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/cwrapper/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/eval/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/expression/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/finitediff/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/logic/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/matrix/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/ntheory/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/polynomial/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/printing/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/tests/rcp/Makefile	/^SUFFIXES =$/;"	m
SUFFIXES	build/symengine/utilities/catch/Makefile	/^SUFFIXES =$/;"	m
SYMENGINE_ADD_H	symengine/add.h	/^#define SYMENGINE_ADD_H$/;"	d
SYMENGINE_ASSERT	symengine/symengine_assert.h	/^#define SYMENGINE_ASSERT(/;"	d
SYMENGINE_ASSERT_H	symengine/symengine_assert.h	/^#define SYMENGINE_ASSERT_H$/;"	d
SYMENGINE_ASSIGN_TYPEID	symengine/basic.h	/^#define SYMENGINE_ASSIGN_TYPEID(/;"	d
SYMENGINE_BASIC_CONVERSIONS_H	symengine/polys/basic_conversions.h	/^#define SYMENGINE_BASIC_CONVERSIONS_H$/;"	d
SYMENGINE_BASIC_H	symengine/basic.h	/^#define SYMENGINE_BASIC_H$/;"	d
SYMENGINE_BASIC_INL_H	symengine/basic-inl.h	/^#define SYMENGINE_BASIC_INL_H$/;"	d
SYMENGINE_BOOSTMP	build/symengine/symengine_config.h	/^#define SYMENGINE_BOOSTMP /;"	d
SYMENGINE_CASTS_H	symengine/symengine_casts.h	/^#define SYMENGINE_CASTS_H$/;"	d
SYMENGINE_CODEGEN_H	symengine/printers/codegen.h	/^#define SYMENGINE_CODEGEN_H$/;"	d
SYMENGINE_COMPLEX_DOUBLE_H	symengine/complex_double.h	/^#define SYMENGINE_COMPLEX_DOUBLE_H$/;"	d
SYMENGINE_COMPLEX_H	symengine/complex.h	/^#define SYMENGINE_COMPLEX_H$/;"	d
SYMENGINE_CONFIG_CLING_HPP	build/symengine/symengine_config_cling.h	/^#define SYMENGINE_CONFIG_CLING_HPP$/;"	d
SYMENGINE_CONFIG_HPP	build/symengine/symengine_config.h	/^#define SYMENGINE_CONFIG_HPP$/;"	d
SYMENGINE_CONSTANTS_H	symengine/constants.h	/^#define SYMENGINE_CONSTANTS_H$/;"	d
SYMENGINE_C_ASSERT	symengine/cwrapper.h	/^#define SYMENGINE_C_ASSERT(/;"	d
SYMENGINE_DEPRECATED	build/symengine/symengine_export.h	/^#  define SYMENGINE_DEPRECATED /;"	d
SYMENGINE_DEPRECATED_EXPORT	build/symengine/symengine_export.h	/^#  define SYMENGINE_DEPRECATED_EXPORT /;"	d
SYMENGINE_DEPRECATED_NO_EXPORT	build/symengine/symengine_export.h	/^#  define SYMENGINE_DEPRECATED_NO_EXPORT /;"	d
SYMENGINE_DERIVATIVE_H	symengine/derivative.h	/^#define SYMENGINE_DERIVATIVE_H$/;"	d
SYMENGINE_DICT_H	symengine/dict.h	/^#define SYMENGINE_DICT_H$/;"	d
SYMENGINE_DIOPHANTINE_H	symengine/diophantine.h	/^#define SYMENGINE_DIOPHANTINE_H$/;"	d
SYMENGINE_DIV_BY_ZERO	symengine/symengine_exception.h	/^    SYMENGINE_DIV_BY_ZERO = 2,$/;"	e	enum:__anon2
SYMENGINE_DIV_BY_ZERO	symengine/symengine_exception.h	/^    SYMENGINE_DIV_BY_ZERO = 2,$/;"	e	enum:__anon23
SYMENGINE_DOMAIN_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_DOMAIN_ERROR = 4,$/;"	e	enum:__anon2
SYMENGINE_DOMAIN_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_DOMAIN_ERROR = 4,$/;"	e	enum:__anon23
SYMENGINE_ENUM	symengine/basic.h	/^#define SYMENGINE_ENUM(/;"	d
SYMENGINE_ENUM	symengine/basic.h	/^#undef SYMENGINE_ENUM$/;"	d
SYMENGINE_ENUM	symengine/cwrapper.cpp	/^#define SYMENGINE_ENUM(/;"	d	file:
SYMENGINE_ENUM	symengine/cwrapper.cpp	/^#undef SYMENGINE_ENUM$/;"	d	file:
SYMENGINE_ENUM	symengine/cwrapper.h	/^#define SYMENGINE_ENUM(/;"	d
SYMENGINE_ENUM	symengine/cwrapper.h	/^#undef SYMENGINE_ENUM$/;"	d
SYMENGINE_ENUM	symengine/derivative.cpp	/^#define SYMENGINE_ENUM(/;"	d	file:
SYMENGINE_ENUM	symengine/derivative.cpp	/^#undef SYMENGINE_ENUM$/;"	d	file:
SYMENGINE_ENUM	symengine/eval_double.cpp	/^#define SYMENGINE_ENUM(/;"	d	file:
SYMENGINE_ENUM	symengine/eval_double.cpp	/^#undef SYMENGINE_ENUM$/;"	d	file:
SYMENGINE_ENUM	symengine/visitor.cpp	/^#define SYMENGINE_ENUM(/;"	d	file:
SYMENGINE_ENUM	symengine/visitor.cpp	/^#undef SYMENGINE_ENUM$/;"	d	file:
SYMENGINE_ENUM	symengine/visitor.h	/^#define SYMENGINE_ENUM(/;"	d
SYMENGINE_ENUM	symengine/visitor.h	/^#undef SYMENGINE_ENUM$/;"	d
SYMENGINE_ERROR	symengine/symengine_assert.h	/^#define SYMENGINE_ERROR(/;"	d
SYMENGINE_EVAL_ARB_H	symengine/eval_arb.h	/^#define SYMENGINE_EVAL_ARB_H$/;"	d
SYMENGINE_EVAL_DOUBLE_H	symengine/eval_double.h	/^#define SYMENGINE_EVAL_DOUBLE_H$/;"	d
SYMENGINE_EVAL_H	symengine/eval.h	/^#define SYMENGINE_EVAL_H$/;"	d
SYMENGINE_EVAL_MPC_H	symengine/eval_mpc.h	/^#define SYMENGINE_EVAL_MPC_H$/;"	d
SYMENGINE_EVAL_MPFR_H	symengine/eval_mpfr.h	/^#define SYMENGINE_EVAL_MPFR_H$/;"	d
SYMENGINE_EXCEPTION_H	symengine/symengine_exception.h	/^#define SYMENGINE_EXCEPTION_H$/;"	d
SYMENGINE_EXPORT	build/symengine/symengine_export.h	/^#      define SYMENGINE_EXPORT /;"	d
SYMENGINE_EXPORT	build/symengine/symengine_export.h	/^#  define SYMENGINE_EXPORT$/;"	d
SYMENGINE_EXPORT_H	build/symengine/symengine_export.h	/^#define SYMENGINE_EXPORT_H$/;"	d
SYMENGINE_EXPRESSION_H	symengine/expression.h	/^#define SYMENGINE_EXPRESSION_H$/;"	d
SYMENGINE_FIELDS_H	symengine/fields.h	/^#define SYMENGINE_FIELDS_H$/;"	d
SYMENGINE_FINITEDIFF_H	symengine/finitediff.h	/^#define SYMENGINE_FINITEDIFF_H$/;"	d
SYMENGINE_FLINT	build/symengine/symengine_config.h	/^#define SYMENGINE_FLINT /;"	d
SYMENGINE_FLINT_WRAPPER_H	symengine/flint_wrapper.h	/^#define SYMENGINE_FLINT_WRAPPER_H$/;"	d
SYMENGINE_FUNCTIONS_H	symengine/functions.h	/^#define SYMENGINE_FUNCTIONS_H$/;"	d
SYMENGINE_GMP	build/symengine/symengine_config.h	/^#define SYMENGINE_GMP /;"	d
SYMENGINE_GMPXX	build/symengine/symengine_config.h	/^#define SYMENGINE_GMPXX /;"	d
SYMENGINE_INCLUDE_ALL	symengine/basic.h	/^#define SYMENGINE_INCLUDE_ALL$/;"	d
SYMENGINE_INCLUDE_ALL	symengine/basic.h	/^#undef SYMENGINE_INCLUDE_ALL$/;"	d
SYMENGINE_INCLUDE_ALL	symengine/cwrapper.cpp	/^#define SYMENGINE_INCLUDE_ALL$/;"	d	file:
SYMENGINE_INCLUDE_ALL	symengine/cwrapper.cpp	/^#undef SYMENGINE_INCLUDE_ALL$/;"	d	file:
SYMENGINE_INCLUDE_ALL	symengine/cwrapper.h	/^#define SYMENGINE_INCLUDE_ALL$/;"	d
SYMENGINE_INCLUDE_ALL	symengine/cwrapper.h	/^#undef SYMENGINE_INCLUDE_ALL$/;"	d
SYMENGINE_INFINITY_H	symengine/infinity.h	/^#define SYMENGINE_INFINITY_H$/;"	d
SYMENGINE_INTEGER_CLASS	build/symengine/symengine_config.h	/^#define SYMENGINE_INTEGER_CLASS /;"	d
SYMENGINE_INTEGER_CLASS_H	symengine/mp_class.h	/^#define SYMENGINE_INTEGER_CLASS_H$/;"	d
SYMENGINE_INTEGER_H	symengine/integer.h	/^#define SYMENGINE_INTEGER_H$/;"	d
SYMENGINE_LAMBDA_DOUBLE_H	symengine/lambda_double.h	/^#define SYMENGINE_LAMBDA_DOUBLE_H$/;"	d
SYMENGINE_LLVM_DOUBLE_H	symengine/llvm_double.h	/^#define SYMENGINE_LLVM_DOUBLE_H$/;"	d
SYMENGINE_LOGIC_FUNCTION	symengine/llvm_double.cpp	/^#define SYMENGINE_LOGIC_FUNCTION(/;"	d	file:
SYMENGINE_LOGIC_H	symengine/logic.h	/^#define SYMENGINE_LOGIC_H$/;"	d
SYMENGINE_MAJOR_VERSION	build/symengine/symengine_config.h	/^#define SYMENGINE_MAJOR_VERSION /;"	d
SYMENGINE_MATHML_H	symengine/printers/mathml.h	/^#define SYMENGINE_MATHML_H$/;"	d
SYMENGINE_MATRIX_H	symengine/matrix.h	/^#define SYMENGINE_MATRIX_H$/;"	d
SYMENGINE_MINOR_VERSION	build/symengine/symengine_config.h	/^#define SYMENGINE_MINOR_VERSION /;"	d
SYMENGINE_MONOMIALS_H	symengine/monomials.h	/^#define SYMENGINE_MONOMIALS_H$/;"	d
SYMENGINE_MPZ_WRAPPER_IMPLEMENT_COMMUTATIVE	symengine/mp_wrapper.h	/^#define SYMENGINE_MPZ_WRAPPER_IMPLEMENT_COMMUTATIVE(/;"	d
SYMENGINE_MPZ_WRAPPER_IMPLEMENT_IN_PLACE	symengine/mp_wrapper.h	/^#define SYMENGINE_MPZ_WRAPPER_IMPLEMENT_IN_PLACE(/;"	d
SYMENGINE_MPZ_WRAPPER_IMPLEMENT_NON_COMMUTATIVE	symengine/mp_wrapper.h	/^#define SYMENGINE_MPZ_WRAPPER_IMPLEMENT_NON_COMMUTATIVE(/;"	d
SYMENGINE_MPZ_WRAPPER_IMPLEMENT_RELATIONAL	symengine/mp_wrapper.h	/^#define SYMENGINE_MPZ_WRAPPER_IMPLEMENT_RELATIONAL(/;"	d
SYMENGINE_MP_WRAPPER_H	symengine/mp_wrapper.h	/^#define SYMENGINE_MP_WRAPPER_H$/;"	d
SYMENGINE_MUL_H	symengine/mul.h	/^#define SYMENGINE_MUL_H$/;"	d
SYMENGINE_NAN_H	symengine/nan.h	/^#define SYMENGINE_NAN_H$/;"	d
SYMENGINE_NOEXCEPT	build/symengine/symengine_config.h	/^#  define SYMENGINE_NOEXCEPT /;"	d
SYMENGINE_NOEXCEPT	build/symengine/symengine_config.h	/^#  define SYMENGINE_NOEXCEPT$/;"	d
SYMENGINE_NOT_IMPLEMENTED	symengine/symengine_exception.h	/^    SYMENGINE_NOT_IMPLEMENTED = 3,$/;"	e	enum:__anon2
SYMENGINE_NOT_IMPLEMENTED	symengine/symengine_exception.h	/^    SYMENGINE_NOT_IMPLEMENTED = 3,$/;"	e	enum:__anon23
SYMENGINE_NO_EXCEPTION	symengine/symengine_exception.h	/^    SYMENGINE_NO_EXCEPTION = 0,$/;"	e	enum:__anon2
SYMENGINE_NO_EXCEPTION	symengine/symengine_exception.h	/^    SYMENGINE_NO_EXCEPTION = 0,$/;"	e	enum:__anon23
SYMENGINE_NO_EXPORT	build/symengine/symengine_export.h	/^#    define SYMENGINE_NO_EXPORT /;"	d
SYMENGINE_NO_EXPORT	build/symengine/symengine_export.h	/^#  define SYMENGINE_NO_EXPORT$/;"	d
SYMENGINE_NTHEORY_H	symengine/ntheory.h	/^#define SYMENGINE_NTHEORY_H$/;"	d
SYMENGINE_NUMBER_H	symengine/number.h	/^#define SYMENGINE_NUMBER_H$/;"	d
SYMENGINE_PARSER_H	symengine/parser.h	/^#define SYMENGINE_PARSER_H$/;"	d
SYMENGINE_PARSE_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_PARSE_ERROR = 5,$/;"	e	enum:__anon2
SYMENGINE_PARSE_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_PARSE_ERROR = 5,$/;"	e	enum:__anon23
SYMENGINE_PATCH_VERSION	build/symengine/symengine_config.h	/^#define SYMENGINE_PATCH_VERSION /;"	d
SYMENGINE_PIRANHA	build/symengine/symengine_config.h	/^#define SYMENGINE_PIRANHA /;"	d
SYMENGINE_POLYNOMIALS_MULTIVARIATE	symengine/polys/msymenginepoly.h	/^#define SYMENGINE_POLYNOMIALS_MULTIVARIATE$/;"	d
SYMENGINE_POW_H	symengine/pow.h	/^#define SYMENGINE_POW_H$/;"	d
SYMENGINE_PRINTER_H	symengine/printers.h	/^#define SYMENGINE_PRINTER_H$/;"	d
SYMENGINE_RATIONAL_H	symengine/rational.h	/^#define SYMENGINE_RATIONAL_H$/;"	d
SYMENGINE_RCP_H	symengine/symengine_rcp.h	/^#define SYMENGINE_RCP_H$/;"	d
SYMENGINE_REAL_DOUBLE_H	symengine/real_double.h	/^#define SYMENGINE_REAL_DOUBLE_H$/;"	d
SYMENGINE_REAL_MPC_H	symengine/complex_mpc.h	/^#define SYMENGINE_REAL_MPC_H$/;"	d
SYMENGINE_REAL_MPFR_H	symengine/real_mpfr.h	/^#define SYMENGINE_REAL_MPFR_H$/;"	d
SYMENGINE_RELATIONAL_FUNCTION	symengine/llvm_double.cpp	/^#define SYMENGINE_RELATIONAL_FUNCTION(/;"	d	file:
SYMENGINE_RINGS_H	symengine/rings.h	/^#define SYMENGINE_RINGS_H$/;"	d
SYMENGINE_RUNTIME_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_RUNTIME_ERROR = 1,$/;"	e	enum:__anon2
SYMENGINE_RUNTIME_ERROR	symengine/symengine_exception.h	/^    SYMENGINE_RUNTIME_ERROR = 1,$/;"	e	enum:__anon23
SYMENGINE_SCANNER_H	symengine/parser/scanner.h	/^#define SYMENGINE_SCANNER_H$/;"	d
SYMENGINE_SERIES_FLINT_H	symengine/series_flint.h	/^#define SYMENGINE_SERIES_FLINT_H$/;"	d
SYMENGINE_SERIES_GENERIC_H	symengine/series_generic.h	/^#define SYMENGINE_SERIES_GENERIC_H$/;"	d
SYMENGINE_SERIES_H	symengine/series.h	/^#define SYMENGINE_SERIES_H$/;"	d
SYMENGINE_SERIES_PIRANHA_H	symengine/series_piranha.h	/^#define SYMENGINE_SERIES_PIRANHA_H$/;"	d
SYMENGINE_SERIES_VISITOR_H	symengine/series_visitor.h	/^#define SYMENGINE_SERIES_VISITOR_H$/;"	d
SYMENGINE_SETS_H	symengine/sets.h	/^#define SYMENGINE_SETS_H$/;"	d
SYMENGINE_SI	symengine/mp_wrapper.h	/^#define SYMENGINE_SI(/;"	d
SYMENGINE_SOLVE_H	symengine/solve.h	/^#define SYMENGINE_SOLVE_H$/;"	d
SYMENGINE_STR_PRINTER_H	symengine/printers/strprinter.h	/^#define SYMENGINE_STR_PRINTER_H$/;"	d
SYMENGINE_SUBS_H	symengine/subs.h	/^#define SYMENGINE_SUBS_H$/;"	d
SYMENGINE_SYMBOL_H	symengine/symbol.h	/^#define SYMENGINE_SYMBOL_H$/;"	d
SYMENGINE_TypeID_Count	symengine/cwrapper.h	/^    SYMENGINE_TypeID_Count$/;"	e	enum:__anon24
SYMENGINE_TypeID_Count	symengine/cwrapper.h	/^    SYMENGINE_TypeID_Count$/;"	e	enum:__anon3
SYMENGINE_UEXPRPOLY_H	symengine/polys/uexprpoly.h	/^#define SYMENGINE_UEXPRPOLY_H$/;"	d
SYMENGINE_UI	symengine/mp_wrapper.h	/^#define SYMENGINE_UI(/;"	d
SYMENGINE_UINTPOLY_FLINT_H	symengine/polys/uintpoly_flint.h	/^#define SYMENGINE_UINTPOLY_FLINT_H$/;"	d
SYMENGINE_UINTPOLY_H	symengine/polys/uintpoly.h	/^#define SYMENGINE_UINTPOLY_H$/;"	d
SYMENGINE_UINTPOLY_PIRANHA_H	symengine/polys/uintpoly_piranha.h	/^#define SYMENGINE_UINTPOLY_PIRANHA_H$/;"	d
SYMENGINE_UINT_BASE_H	symengine/polys/upolybase.h	/^#define SYMENGINE_UINT_BASE_H$/;"	d
SYMENGINE_URATPOLY_H	symengine/polys/uratpoly.h	/^#define SYMENGINE_URATPOLY_H$/;"	d
SYMENGINE_USYMENGINEPOLY_H	symengine/polys/usymenginepoly.h	/^#define SYMENGINE_USYMENGINEPOLY_H$/;"	d
SYMENGINE_VERSION	build/symengine/symengine_config.h	/^#define SYMENGINE_VERSION /;"	d
SYMENGINE_VISITOR_H	symengine/visitor.h	/^#define SYMENGINE_VISITOR_H$/;"	d
SafeBool	symengine/utilities/catch/catch.hpp	/^    class SafeBool {$/;"	c	namespace:Catch
Scanner	symengine/parser/scanner.h	/^class Scanner : public ScannerBase$/;"	c	namespace:SymEngine
Scanner	symengine/parser/scanner.h	/^inline Scanner::Scanner(std::istream &in, std::ostream &out)$/;"	f	class:SymEngine::Scanner
Scanner	symengine/parser/scanner.h	/^inline Scanner::Scanner(std::string const &infile, std::string const &outfile)$/;"	f	class:SymEngine::Scanner
ScannerBase	symengine/parser/scanner.cpp	/^ScannerBase::ScannerBase(std::istream &in, std::ostream &out)$/;"	f	class:SymEngine::ScannerBase
ScannerBase	symengine/parser/scanner.cpp	/^ScannerBase::ScannerBase(std::string const &infilename,$/;"	f	class:SymEngine::ScannerBase
ScannerBase	symengine/parser/scannerbase.h	/^class ScannerBase$/;"	c	namespace:SymEngine
Sec	symengine/functions.cpp	/^Sec::Sec(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Sec
Sec	symengine/functions.h	/^class Sec : public TrigFunction$/;"	c	namespace:SymEngine
Sech	symengine/functions.cpp	/^Sech::Sech(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Sech
Sech	symengine/functions.h	/^class Sech : public HyperbolicFunction$/;"	c	namespace:SymEngine
Semantic	symengine/parser/parserbase.h	/^class Semantic : public Base$/;"	c	namespace:SymEngine::Meta__
Semantic	symengine/parser/parserbase.h	/^inline Semantic<tg_>::Semantic(Params &&... params)$/;"	f	class:SymEngine::Meta__::Semantic
SeriesBase	symengine/series.h	/^    inline SeriesBase(Poly p, std::string var, unsigned degree)$/;"	f	class:SymEngine::SeriesBase
SeriesBase	symengine/series.h	/^class SeriesBase : public SeriesCoeffInterface$/;"	c	namespace:SymEngine
SeriesCoeffInterface	symengine/series.h	/^class SeriesCoeffInterface : public Number$/;"	c	namespace:SymEngine
SeriesVisitor	symengine/series_visitor.h	/^    inline SeriesVisitor(const Poly &var_, const std::string &varname_,$/;"	f	class:SymEngine::SeriesVisitor
SeriesVisitor	symengine/series_visitor.h	/^class SeriesVisitor : public BaseVisitor<SeriesVisitor<Poly, Coeff, Series>>$/;"	c	namespace:SymEngine
Set	symengine/sets.h	/^class Set : public Basic$/;"	c	namespace:SymEngine
SetTracingActiveNodesStack	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  SetTracingActiveNodesStack()$/;"	f	class:Teuchos::SetTracingActiveNodesStack
SetTracingActiveNodesStack	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class SetTracingActiveNodesStack {$/;"	c	namespace:Teuchos
SharedImpl	symengine/utilities/catch/catch.hpp	/^        SharedImpl() : m_rc( 0 ){}$/;"	f	struct:Catch::SharedImpl
SharedImpl	symengine/utilities/catch/catch.hpp	/^    struct SharedImpl : T {$/;"	s	namespace:Catch
Sieve	symengine/ntheory.h	/^class Sieve$/;"	c	namespace:SymEngine
Sign	symengine/functions.cpp	/^Sign::Sign(const RCP<const Basic> &arg) : OneArgFunction(arg)$/;"	f	class:SymEngine::Sign
Sign	symengine/functions.h	/^class Sign : public OneArgFunction$/;"	c	namespace:SymEngine
Sin	symengine/functions.cpp	/^Sin::Sin(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Sin
Sin	symengine/functions.h	/^class Sin : public TrigFunction$/;"	c	namespace:SymEngine
Sinh	symengine/functions.cpp	/^Sinh::Sinh(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Sinh
Sinh	symengine/functions.h	/^class Sinh : public HyperbolicFunction$/;"	c	namespace:SymEngine
SourceLineInfo	symengine/utilities/catch/catch.hpp	/^    struct SourceLineInfo {$/;"	s	namespace:Catch
StacktraceAddresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  StacktraceAddresses(void *const *_stacktrace_buffer, int _size, int _impl_stacktrace_depth)$/;"	f	class:__anon22::StacktraceAddresses
StacktraceAddresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  StacktraceAddresses(void *const *_stacktrace_buffer, int _size, int _impl_stacktrace_depth)$/;"	f	class:__anon43::StacktraceAddresses
StacktraceAddresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^class StacktraceAddresses {$/;"	c	namespace:__anon22	file:
StacktraceAddresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^class StacktraceAddresses {$/;"	c	namespace:__anon43	file:
StartCondition__	symengine/parser/scannerbase.h	/^    enum class StartCondition__ {$/;"	c	class:SymEngine::ScannerBase
StateType	symengine/parser/parser.cpp	/^enum StateType \/\/ modify statetype\/data.cc when this enum changes$/;"	g	namespace:__anon29	file:
StateType	symengine/parser/parser.cpp	/^enum StateType \/\/ modify statetype\/data.cc when this enum changes$/;"	g	namespace:__anon8	file:
StopVisitor	symengine/visitor.h	/^class StopVisitor : public Visitor$/;"	c	namespace:SymEngine
StrPrinter	symengine/printers/strprinter.h	/^class StrPrinter : public BaseVisitor<StrPrinter>$/;"	c	namespace:SymEngine
StreamEndStop	symengine/utilities/catch/catch.hpp	/^    struct StreamEndStop {$/;"	s	namespace:Catch
StreamStruct	symengine/parser/scannerbase.h	/^    struct StreamStruct {$/;"	s	class:SymEngine::ScannerBase
StrictLessThan	symengine/logic.cpp	/^StrictLessThan::StrictLessThan(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::StrictLessThan
StrictLessThan	symengine/logic.h	/^class StrictLessThan : public Relational$/;"	c	namespace:SymEngine
StringMaker	symengine/utilities/catch/catch.hpp	/^struct StringMaker :$/;"	s	namespace:Catch
StringMaker	symengine/utilities/catch/catch.hpp	/^struct StringMaker<R C::*> {$/;"	s	namespace:Catch
StringMaker	symengine/utilities/catch/catch.hpp	/^struct StringMaker<T*> {$/;"	s	namespace:Catch
StringMakerBase	symengine/utilities/catch/catch.hpp	/^    struct StringMakerBase {$/;"	s	namespace:Catch::Detail
StringMakerBase	symengine/utilities/catch/catch.hpp	/^    struct StringMakerBase<true> {$/;"	s	namespace:Catch::Detail
Subs	symengine/functions.cpp	/^Subs::Subs(const RCP<const Basic> &arg, const map_basic_basic &dict)$/;"	f	class:SymEngine::Subs
Subs	symengine/functions.h	/^class Subs : public Basic$/;"	c	namespace:SymEngine
SubsVisitor	symengine/subs.h	/^    SubsVisitor(const map_basic_basic &subs_dict_)$/;"	f	class:SymEngine::SubsVisitor
SubsVisitor	symengine/subs.h	/^class SubsVisitor : public BaseVisitor<SubsVisitor, XReplaceVisitor>$/;"	c	namespace:SymEngine
SuppressFail	symengine/utilities/catch/catch.hpp	/^        SuppressFail = 0x08         \/\/ Failures are reported but do not fail the test$/;"	e	enum:Catch::ResultDisposition::Flags
SymEngine	symengine/add.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/add.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/as_real_imag.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/basic-inl.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/basic.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/basic.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/complex.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/complex.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/complex_double.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/complex_double.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/complex_mpc.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/complex_mpc.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/constants.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/constants.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/cse.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/cwrapper.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/dense_matrix.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/derivative.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/derivative.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/dict.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/dict.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/diophantine.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/diophantine.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/eval.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/eval.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/eval_arb.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/eval_arb.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/eval_double.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/eval_double.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/eval_mpc.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/eval_mpc.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/eval_mpfr.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/eval_mpfr.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/expand.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/expression.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/expression.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/fields.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/fields.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/finitediff.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/finitediff.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/flint_wrapper.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/functions.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/functions.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/infinity.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/infinity.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/integer.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/integer.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/lambda_double.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/llvm_double.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/llvm_double.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/logic.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/logic.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/matrix.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/matrix.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/monomials.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/monomials.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/mp_boost.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/mp_class.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/mp_wrapper.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/mp_wrapper.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/mul.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/mul.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/nan.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/nan.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/ntheory.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/ntheory.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/number.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/number.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/numer_denom.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/parser.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/parser/parser.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/parser/parser.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/parser/parser_old.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/parser/parserbase.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/parser/scanner.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/parser/scanner.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/parser/scannerbase.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/basic_conversions.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/basic_conversions.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/msymenginepoly.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/msymenginepoly.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/uexprpoly.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/uexprpoly.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/uintpoly.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/uintpoly.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/uintpoly_flint.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/uintpoly_flint.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/uintpoly_piranha.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/uintpoly_piranha.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/upolybase.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/uratpoly.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/polys/uratpoly.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/polys/usymenginepoly.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/pow.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/pow.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/printers.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/printers/codegen.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/printers/codegen.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/printers/latex.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/printers/latex.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/printers/mathml.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/printers/mathml.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/printers/strprinter.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/printers/strprinter.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/rational.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/rational.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/real_double.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/real_double.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/real_mpfr.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/real_mpfr.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/rewrite.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/rings.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/rings.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/series.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/series.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/series_flint.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/series_flint.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/series_generic.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/series_generic.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/series_piranha.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/series_piranha.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/series_visitor.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/sets.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/sets.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/solve.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/solve.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/sparse_matrix.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/subs.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/symbol.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/symbol.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/symengine_casts.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/symengine_exception.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/symengine_rcp.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/symengine_rcp.h	/^namespace SymEngine$/;"	n
SymEngine	symengine/tests/printing/test_printing.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/visitor.cpp	/^namespace SymEngine$/;"	n	file:
SymEngine	symengine/visitor.h	/^namespace SymEngine$/;"	n
SymEngineException	symengine/symengine_exception.h	/^    SymEngineException(const std::string &msg)$/;"	f	class:SymEngine::SymEngineException
SymEngineException	symengine/symengine_exception.h	/^    SymEngineException(const std::string &msg, symengine_exceptions_t error)$/;"	f	class:SymEngine::SymEngineException
SymEngineException	symengine/symengine_exception.h	/^class SymEngineException : public std::exception$/;"	c	namespace:SymEngine
SymEngineParserBase_h_included	symengine/parser/parserbase.h	/^#define SymEngineParserBase_h_included$/;"	d
SymEngineScannerBASE_H_INCLUDED	symengine/parser/scannerbase.h	/^#define SymEngineScannerBASE_H_INCLUDED$/;"	d
Symbol	symengine/symbol.cpp	/^Symbol::Symbol(const std::string &name) : name_{name}$/;"	f	class:SymEngine::Symbol
Symbol	symengine/symbol.h	/^class Symbol : public Basic$/;"	c	namespace:SymEngine
Symbolic	symengine/eval.h	/^    Symbolic = 2,$/;"	m	class:SymEngine::EvalfDomain
TBC_TEXT_FORMAT_CONSOLE_WIDTH	symengine/utilities/catch/catch.hpp	/^#define TBC_TEXT_FORMAT_CONSOLE_WIDTH /;"	d
TBC_TEXT_FORMAT_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TBC_TEXT_FORMAT_H_INCLUDED$/;"	d
TEMPLATE_FRIENDS_NOT_SUPPORTED	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#    define TEMPLATE_FRIENDS_NOT_SUPPORTED$/;"	d
TEST_FOR_EXCEPT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPT(/;"	d
TEST_FOR_EXCEPTION	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPTION(/;"	d
TEST_FOR_EXCEPTION_CLASS_FUNC	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPTION_CLASS_FUNC(/;"	d
TEST_FOR_EXCEPTION_CLASS_FUNC_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPTION_CLASS_FUNC_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPTION_PRINT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPTION_PRINT(/;"	d
TEST_FOR_EXCEPTION_PRINT_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPTION_PRINT_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPTION_PURE_MSG	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPTION_PURE_MSG(/;"	d
TEST_FOR_EXCEPTION_PURE_MSG_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPTION_PURE_MSG_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPTION_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPTION_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPT_MSG	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPT_MSG(/;"	d
TEST_FOR_EXCEPT_MSG_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPT_MSG_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPT_PRINT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEST_FOR_EXCEPT_PRINT(/;"	d
TEST_FOR_EXCEPT_PRINT_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPT_PRINT_this_macro_is_deprecated() {}$/;"	f
TEST_FOR_EXCEPT_this_macro_is_deprecated	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^TEUCHOS_DEPRECATED inline void TEST_FOR_EXCEPT_this_macro_is_deprecated() {}$/;"	f
TEUCHOS_ANY_HPP	symengine/utilities/teuchos/Teuchos_any.hpp	/^#define TEUCHOS_ANY_HPP$/;"	d
TEUCHOS_ASSERT	symengine/utilities/teuchos/Teuchos_Assert.hpp	/^#define TEUCHOS_ASSERT(/;"	d
TEUCHOS_ASSERT_EQUALITY	symengine/utilities/teuchos/Teuchos_Assert.hpp	/^#define TEUCHOS_ASSERT_EQUALITY(/;"	d
TEUCHOS_ASSERT_HPP	symengine/utilities/teuchos/Teuchos_Assert.hpp	/^#define TEUCHOS_ASSERT_HPP$/;"	d
TEUCHOS_ASSERT_INEQUALITY	symengine/utilities/teuchos/Teuchos_Assert.hpp	/^#define TEUCHOS_ASSERT_INEQUALITY(/;"	d
TEUCHOS_ASSERT_IN_RANGE_UPPER_EXCLUSIVE	symengine/utilities/teuchos/Teuchos_Assert.hpp	/^#define TEUCHOS_ASSERT_IN_RANGE_UPPER_EXCLUSIVE(/;"	d
TEUCHOS_CHK_ERR	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_CHK_ERR(/;"	d
TEUCHOS_CHK_ERR	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#undef TEUCHOS_CHK_ERR$/;"	d
TEUCHOS_CHK_PTR	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_CHK_PTR(/;"	d
TEUCHOS_CHK_PTR	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#undef TEUCHOS_CHK_PTR$/;"	d
TEUCHOS_CHK_REF	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_CHK_REF(/;"	d
TEUCHOS_CHK_REF	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#undef TEUCHOS_CHK_REF$/;"	d
TEUCHOS_CONFIGDEFS_HPP	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_CONFIGDEFS_HPP$/;"	d
TEUCHOS_CONST_TYPE_TRAITS_HPP	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^#define TEUCHOS_CONST_TYPE_TRAITS_HPP$/;"	d
TEUCHOS_DEBUG	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#  define TEUCHOS_DEBUG$/;"	d
TEUCHOS_DYN_CAST_HPP	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^#define TEUCHOS_DYN_CAST_HPP$/;"	d
TEUCHOS_ENULL_HPP	symengine/utilities/teuchos/Teuchos_ENull.hpp	/^#define TEUCHOS_ENULL_HPP$/;"	d
TEUCHOS_EXCEPTIONS_HPP	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^#define TEUCHOS_EXCEPTIONS_HPP$/;"	d
TEUCHOS_GET_BASE_OBJ_VOID_PTR	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^#define TEUCHOS_GET_BASE_OBJ_VOID_PTR$/;"	d
TEUCHOS_LIB_DLL_EXPORT	symengine/utilities/teuchos/Teuchos_DLLExportMacro.h	/^#    define TEUCHOS_LIB_DLL_EXPORT /;"	d
TEUCHOS_LIB_DLL_EXPORT	symengine/utilities/teuchos/Teuchos_DLLExportMacro.h	/^#  define TEUCHOS_LIB_DLL_EXPORT$/;"	d
TEUCHOS_MAP_H	symengine/utilities/teuchos/Teuchos_map.hpp	/^#define TEUCHOS_MAP_H$/;"	d
TEUCHOS_MAX	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_MAX(/;"	d
TEUCHOS_MIN	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_MIN(/;"	d
TEUCHOS_NO_ZERO_ITERATOR_CONVERSION	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#  define TEUCHOS_NO_ZERO_ITERATOR_CONVERSION$/;"	d
TEUCHOS_NULL_ITERATOR_TRAITS_HPP	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^#define TEUCHOS_NULL_ITERATOR_TRAITS_HPP$/;"	d
TEUCHOS_OSTRINGSTREAM_GET_C_STR	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_OSTRINGSTREAM_GET_C_STR(/;"	d
TEUCHOS_PRIVIATE_DELETE_NOT_SUPPORTED	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#    define TEUCHOS_PRIVIATE_DELETE_NOT_SUPPORTED$/;"	d
TEUCHOS_PTR_DECL_HPP	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^#define TEUCHOS_PTR_DECL_HPP$/;"	d
TEUCHOS_PTR_HPP	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^#define TEUCHOS_PTR_HPP$/;"	d
TEUCHOS_RCPNODE_REMOVE_RCPNODE	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^#define TEUCHOS_RCPNODE_REMOVE_RCPNODE(/;"	d	file:
TEUCHOS_RCP_DECL_HPP	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^#define TEUCHOS_RCP_DECL_HPP$/;"	d
TEUCHOS_RCP_HPP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^#define TEUCHOS_RCP_HPP$/;"	d
TEUCHOS_RCP_INSERION_NUMBER_STR	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^#  define TEUCHOS_RCP_INSERION_NUMBER_STR(/;"	d
TEUCHOS_RCP_NODE_HPP	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^#define TEUCHOS_RCP_NODE_HPP$/;"	d
TEUCHOS_REFCOUNTPTR_ASSERT_NONNULL	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^#  define TEUCHOS_REFCOUNTPTR_ASSERT_NONNULL$/;"	d
TEUCHOS_SGN	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^#define TEUCHOS_SGN(/;"	d
TEUCHOS_STACKTRACE_HPP	symengine/utilities/teuchos/Teuchos_stacktrace.hpp	/^#define TEUCHOS_STACKTRACE_HPP$/;"	d
TEUCHOS_STORE_STACKTRACE	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#  define TEUCHOS_STORE_STACKTRACE(/;"	d
TEUCHOS_TEST_FOR_EXCEPT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPT(/;"	d
TEUCHOS_TEST_FOR_EXCEPTION	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPTION(/;"	d
TEUCHOS_TEST_FOR_EXCEPTION_CLASS_FUNC	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPTION_CLASS_FUNC(/;"	d
TEUCHOS_TEST_FOR_EXCEPTION_H	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPTION_H$/;"	d
TEUCHOS_TEST_FOR_EXCEPTION_PRINT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPTION_PRINT(/;"	d
TEUCHOS_TEST_FOR_EXCEPTION_PURE_MSG	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPTION_PURE_MSG(/;"	d
TEUCHOS_TEST_FOR_EXCEPT_MSG	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPT_MSG(/;"	d
TEUCHOS_TEST_FOR_EXCEPT_PRINT	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TEST_FOR_EXCEPT_PRINT(/;"	d
TEUCHOS_TO_STRING_HPP	symengine/utilities/teuchos/Teuchos_toString.hpp	/^#define TEUCHOS_TO_STRING_HPP$/;"	d
TEUCHOS_TRACE	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^#define TEUCHOS_TRACE(/;"	d
TEUCHOS_TYPE_NAME_TRAITS_BUILTIN_TYPE_SPECIALIZATION	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^#define TEUCHOS_TYPE_NAME_TRAITS_BUILTIN_TYPE_SPECIALIZATION(/;"	d
TEUCHOS_TYPE_NAME_TRAITS_OLD_IBM	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^# define TEUCHOS_TYPE_NAME_TRAITS_OLD_IBM$/;"	d
THEN	symengine/utilities/catch/catch.hpp	/^#define THEN(/;"	d
TOKEN_TYPE_ENDFOR	benchmarks/nonius.h++	/^        TOKEN_TYPE_ENDFOR,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_ENDFOR	benchmarks/nonius.h++	/^        TOKEN_TYPE_ENDFOR,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_ENDIF	benchmarks/nonius.h++	/^        TOKEN_TYPE_ENDIF,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_ENDIF	benchmarks/nonius.h++	/^        TOKEN_TYPE_ENDIF,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_FOR	benchmarks/nonius.h++	/^        TOKEN_TYPE_FOR,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_FOR	benchmarks/nonius.h++	/^        TOKEN_TYPE_FOR,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_IF	benchmarks/nonius.h++	/^        TOKEN_TYPE_IF,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_IF	benchmarks/nonius.h++	/^        TOKEN_TYPE_IF,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_NONE	benchmarks/nonius.h++	/^        TOKEN_TYPE_NONE,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_NONE	benchmarks/nonius.h++	/^        TOKEN_TYPE_NONE,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_TEXT	benchmarks/nonius.h++	/^        TOKEN_TYPE_TEXT,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_TEXT	benchmarks/nonius.h++	/^        TOKEN_TYPE_TEXT,$/;"	e	enum:cpptempl::__anon44
TOKEN_TYPE_VAR	benchmarks/nonius.h++	/^        TOKEN_TYPE_VAR,$/;"	e	enum:cpptempl::__anon1
TOKEN_TYPE_VAR	benchmarks/nonius.h++	/^        TOKEN_TYPE_VAR,$/;"	e	enum:cpptempl::__anon44
TStorage	benchmarks/nonius.h++	/^            typedef typename std::aligned_storage<sizeof(T), std::alignment_of<T>::value>::type TStorage;$/;"	t	struct:nonius::detail::object_storage
TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_APPROX_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_ASSERTIONRESULT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CAPTURE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CLARA_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CLARA_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMANDLINE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMON_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMMON_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMMON_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_COMPILER_CAPABILITIES_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONFIG_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONSOLE_COLOUR_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONTEXT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_CONTEXT_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEBUGGER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEBUGGER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_DEFAULT_MAIN_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_ERRNO_GUARD_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_ERRNO_GUARD_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_EVALUATE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_EXCEPTION_TRANSLATOR_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_EXPRESSION_LHS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_FATAL_CONDITION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_GENERATORS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_GENERATORS_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_CAPTURE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_CONFIG_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_EXCEPTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_GENERATORS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_REGISTRY_HUB_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_REPORTER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_RUNNER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_TAG_ALIAS_REGISTRY_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_INTERFACES_TESTCASE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_LEGACY_REPORTER_ADAPTER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_LIST_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_MATCHERS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_MATCHERS_STRING_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_MATCHERS_VECTOR_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_MESSAGE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_MESSAGE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_NOTIMPLEMENTED_EXCEPTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_OBJC_ARC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_OBJC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_OPTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_PLATFORM_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_PTR_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REENABLE_WARNINGS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REGISTRY_HUB_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_BASES_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_COMPACT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_CONSOLE_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_JUNIT_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_MULTI_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_REGISTRARS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_REPORTER_XML_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_BUILDER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_BUILDER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_RESULT_TYPE_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_RUNNER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_RUNNER_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_SECTION_INFO_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAMBUF_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAM_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_STREAM_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_STREAM_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TAG_ALIAS_REGISTRY_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_INFO_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_REGISTRY_IMPL_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_CASE_TRACKER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_REGISTRY_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_SPEC_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEST_SPEC_PARSER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TEXT_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TEXT_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TIMER_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TIMER_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOSTRING_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOSTRING_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_TOTALS_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_VERSION_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_VERSION_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_VERSION_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_WILDCARD_PATTERN_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_WINDOWS_H_PROXY_H_INCLUDED$/;"	d
TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CATCH_XMLWRITER_HPP_INCLUDED$/;"	d
TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CLARA_COMPILERS_H_INCLUDED$/;"	d
TWOBLUECUBES_CLARA_H_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_CLARA_H_INCLUDED$/;"	d
TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED	symengine/utilities/catch/catch.hpp	/^#define TWOBLUECUBES_SINGLE_INCLUDE_CATCH_HPP_INCLUDED$/;"	d
TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED	symengine/utilities/catch/catch.hpp	/^#   define TWOBLUECUBES_TEXT_FORMAT_H_ALREADY_INCLUDED$/;"	d
T_ptr	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  typedef T* T_ptr;$/;"	t	class:Teuchos::TypeNameTraits
TagOf	symengine/parser/parserbase.h	/^struct TagOf<RCP<const Basic>> {$/;"	s	namespace:SymEngine::Meta__
TagOf	symengine/parser/parserbase.h	/^struct TagOf<std::string> {$/;"	s	namespace:SymEngine::Meta__
TagOf	symengine/parser/parserbase.h	/^struct TagOf<vec_basic> {$/;"	s	namespace:SymEngine::Meta__
Tag__	symengine/parser/parserbase.h	/^enum class Tag__ {$/;"	c	namespace:SymEngine
Tan	symengine/functions.cpp	/^Tan::Tan(const RCP<const Basic> &arg) : TrigFunction(arg)$/;"	f	class:SymEngine::Tan
Tan	symengine/functions.h	/^class Tan : public TrigFunction$/;"	c	namespace:SymEngine
Tanh	symengine/functions.cpp	/^Tanh::Tanh(const RCP<const Basic> &arg) : HyperbolicFunction(arg)$/;"	f	class:SymEngine::Tanh
Tanh	symengine/functions.h	/^class Tanh : public HyperbolicFunction$/;"	c	namespace:SymEngine
TemplateException	benchmarks/nonius.h++	/^        TemplateException(std::string reason) : m_reason(std::move(reason)){}$/;"	f	class:cpptempl::TemplateException
TemplateException	benchmarks/nonius.h++	/^    class TemplateException : public std::exception$/;"	c	namespace:cpptempl
TestFailureException	symengine/utilities/catch/catch.hpp	/^    struct TestFailureException{};$/;"	s	namespace:Catch
TestForException_break	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^void Teuchos::TestForException_break( const std::string &errorMsg )$/;"	f	class:Teuchos
TestForException_break	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^void TestForException_break( const std::string &msg )$/;"	f
TestForException_getEnableStacktrace	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^bool Teuchos::TestForException_getEnableStacktrace()$/;"	f	class:Teuchos
TestForException_getEnableStacktrace	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^bool TestForException_getEnableStacktrace()$/;"	f
TestForException_getThrowNumber	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^int Teuchos::TestForException_getThrowNumber()$/;"	f	class:Teuchos
TestForException_getThrowNumber	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^int TestForException_getThrowNumber()$/;"	f
TestForException_incrThrowNumber	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^void Teuchos::TestForException_incrThrowNumber()$/;"	f	class:Teuchos
TestForException_incrThrowNumber	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^void TestForException_incrThrowNumber()$/;"	f
TestForException_setEnableStacktrace	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^void Teuchos::TestForException_setEnableStacktrace(bool enableStrackTrace)$/;"	f	class:Teuchos
TestForException_setEnableStacktrace	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^void TestForException_setEnableStacktrace(bool enableStrackTrace)$/;"	f
TestFunction	symengine/utilities/catch/catch.hpp	/^typedef void(*TestFunction)();$/;"	t	namespace:Catch
Teuchos	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^namespace Teuchos { class DummyDummyClass; }$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^namespace Teuchos { typedef Teuchos_Ordinal Ordinal; }$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_ENull.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_Exceptions.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^namespace Teuchos {$/;"	n	file:
Teuchos	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_TestForException.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^namespace  Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_any.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_map.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_stacktrace.hpp	/^namespace Teuchos {$/;"	n
Teuchos	symengine/utilities/teuchos/Teuchos_toString.hpp	/^namespace Teuchos {$/;"	n
TeuchosOStringStream	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^typedef std::ostringstream TeuchosOStringStream;$/;"	t
Teuchos_DefaultTracebackMode	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^const int Teuchos_DefaultTracebackMode = 1; \/* Default value for traceback behavior *\/$/;"	v
Teuchos_Index	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^typedef Teuchos_Ordinal Teuchos_Index;$/;"	t
Teuchos_MaxDouble	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^const double Teuchos_MaxDouble = 1.0E+100;$/;"	v
Teuchos_MinDouble	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^const double Teuchos_MinDouble = 1.0E-100;$/;"	v
Teuchos_Ordinal	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^typedef TEUCHOS_ORDINAL_TYPE Teuchos_Ordinal;$/;"	t
Teuchos_Overflow	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^const double Teuchos_Overflow = 1.79E308; \/\/ Used to test if equilibration should be done.$/;"	v
Teuchos_Underflow	symengine/utilities/teuchos/Teuchos_ConfigDefs.hpp	/^const double Teuchos_Underflow = 2.23E-308;$/;"	v
ThrewException	symengine/utilities/catch/catch.hpp	/^        ThrewException = Exception | 1,$/;"	e	enum:Catch::ResultWas::OfType
ToStringTraits	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^class TEUCHOS_LIB_DLL_EXPORT ToStringTraits<ERCPStrength> {$/;"	c	namespace:Teuchos
ToStringTraits	symengine/utilities/teuchos/Teuchos_toString.hpp	/^class ToStringTraits {$/;"	c	namespace:Teuchos
ToStringTraits	symengine/utilities/teuchos/Teuchos_toString.hpp	/^class ToStringTraits<bool> {$/;"	c	namespace:Teuchos
ToStringTraits	symengine/utilities/teuchos/Teuchos_toString.hpp	/^class ToStringTraits<std::string> {$/;"	c	namespace:Teuchos
Token	benchmarks/nonius.h++	/^    class Token$/;"	c	namespace:cpptempl
TokenEnd	benchmarks/nonius.h++	/^        TokenEnd(std::string text) : m_type(text){}$/;"	f	class:cpptempl::TokenEnd
TokenEnd	benchmarks/nonius.h++	/^    class TokenEnd : public Token \/\/ end of control block$/;"	c	namespace:cpptempl
TokenFor	benchmarks/nonius.h++	/^    class TokenFor : public Token$/;"	c	namespace:cpptempl
TokenFor	benchmarks/nonius.h++	/^    inline TokenFor::TokenFor(std::string expr)$/;"	f	class:cpptempl::TokenFor
TokenIf	benchmarks/nonius.h++	/^        TokenIf(std::string expr) : m_expr(expr){}$/;"	f	class:cpptempl::TokenIf
TokenIf	benchmarks/nonius.h++	/^    class TokenIf : public Token$/;"	c	namespace:cpptempl
TokenText	benchmarks/nonius.h++	/^        TokenText(std::string text) : m_text(text){}$/;"	f	class:cpptempl::TokenText
TokenText	benchmarks/nonius.h++	/^    class TokenText : public Token$/;"	c	namespace:cpptempl
TokenType	benchmarks/nonius.h++	/^    } TokenType;$/;"	t	namespace:cpptempl	typeref:enum:cpptempl::__anon1
TokenType	benchmarks/nonius.h++	/^    } TokenType;$/;"	t	namespace:cpptempl	typeref:enum:cpptempl::__anon44
TokenVar	benchmarks/nonius.h++	/^        TokenVar(std::string key) : m_key(key){}$/;"	f	class:cpptempl::TokenVar
TokenVar	benchmarks/nonius.h++	/^    class TokenVar : public Token$/;"	c	namespace:cpptempl
Tokens__	symengine/parser/parserbase.h	/^    enum Tokens__ {$/;"	g	class:SymEngine::ParserBase
TransformVisitor	symengine/visitor.h	/^    TransformVisitor()$/;"	f	class:SymEngine::TransformVisitor
TransformVisitor	symengine/visitor.h	/^class TransformVisitor : public BaseVisitor<TransformVisitor>$/;"	c	namespace:SymEngine
TrigBase	symengine/functions.h	/^    TrigBase(RCP<const Basic> arg) : OneArgFunction(arg){};$/;"	f	class:SymEngine::TrigBase
TrigBase	symengine/functions.h	/^class TrigBase : public OneArgFunction$/;"	c	namespace:SymEngine
TrigFunction	symengine/functions.h	/^    TrigFunction(RCP<const Basic> arg) : TrigBase(arg){};$/;"	f	class:SymEngine::TrigFunction
TrigFunction	symengine/functions.h	/^class TrigFunction : public TrigBase$/;"	c	namespace:SymEngine
TrueType	symengine/utilities/catch/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	s	namespace:Catch::Detail
TupleDetail	symengine/utilities/catch/catch.hpp	/^namespace TupleDetail {$/;"	n	namespace:Catch
TwoArgBasic	symengine/functions.h	/^    TwoArgBasic(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	class:SymEngine::TwoArgBasic
TwoArgBasic	symengine/functions.h	/^class TwoArgBasic : public BaseClass$/;"	c	namespace:SymEngine
TwoArgFunction	symengine/functions.h	/^typedef TwoArgBasic<Function> TwoArgFunction;$/;"	t	namespace:SymEngine
TypeID	symengine/basic.h	/^enum TypeID {$/;"	g	namespace:SymEngine
TypeID	symengine/cwrapper.h	/^} TypeID;$/;"	t	typeref:enum:__anon24
TypeID	symengine/cwrapper.h	/^} TypeID;$/;"	t	typeref:enum:__anon3
TypeID_Count	symengine/basic.h	/^    TypeID_Count$/;"	e	enum:SymEngine::TypeID
TypeNameTraits	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^class TEUCHOS_LIB_DLL_EXPORT TypeNameTraits<T*> {$/;"	c	namespace:Teuchos
TypeNameTraits	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^class TEUCHOS_LIB_DLL_EXPORT TypeNameTraits<std::complex<T> > {$/;"	c	namespace:Teuchos
TypeNameTraits	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^class TEUCHOS_LIB_DLL_EXPORT TypeNameTraits<std::string> {$/;"	c	namespace:Teuchos
TypeNameTraits	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^class TEUCHOS_LIB_DLL_EXPORT TypeNameTraits<void*> {$/;"	c	namespace:Teuchos
TypeNameTraits	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^class TypeNameTraits {$/;"	c	namespace:Teuchos
TypeOf	symengine/parser/parserbase.h	/^struct TypeOf<Tag__::basic> {$/;"	s	namespace:SymEngine::Meta__
TypeOf	symengine/parser/parserbase.h	/^struct TypeOf<Tag__::basic_vec> {$/;"	s	namespace:SymEngine::Meta__
TypeOf	symengine/parser/parserbase.h	/^struct TypeOf<Tag__::string> {$/;"	s	namespace:SymEngine::Meta__
UDictWrapper	symengine/polys/msymenginepoly.h	/^    MExprDict(unsigned int s) SYMENGINE_NOEXCEPT : UDictWrapper(s)$/;"	f	class:SymEngine::MExprDict
UDictWrapper	symengine/polys/msymenginepoly.h	/^    MIntDict(unsigned int s) SYMENGINE_NOEXCEPT : UDictWrapper(s)$/;"	f	class:SymEngine::MIntDict
UDictWrapper	symengine/polys/msymenginepoly.h	/^    UDictWrapper(Dict &&p, unsigned int sz)$/;"	f	class:SymEngine::UDictWrapper
UDictWrapper	symengine/polys/msymenginepoly.h	/^    UDictWrapper(const Dict &p, unsigned int sz)$/;"	f	class:SymEngine::UDictWrapper
UDictWrapper	symengine/polys/msymenginepoly.h	/^class UDictWrapper$/;"	c	namespace:SymEngine
UExprDict	symengine/polys/uexprpoly.h	/^    UExprDict(const Expression &expr) : ODictWrapper(expr)$/;"	f	class:SymEngine::UExprDict
UExprDict	symengine/polys/uexprpoly.h	/^    UExprDict(const int &i) : ODictWrapper(i)$/;"	f	class:SymEngine::UExprDict
UExprDict	symengine/polys/uexprpoly.h	/^    UExprDict(const map_int_Expr &p) : ODictWrapper(p)$/;"	f	class:SymEngine::UExprDict
UExprDict	symengine/polys/uexprpoly.h	/^    UExprDict(const std::string &s) : ODictWrapper(s)$/;"	f	class:SymEngine::UExprDict
UExprDict	symengine/polys/uexprpoly.h	/^class UExprDict : public ODictWrapper<int, Expression, UExprDict>$/;"	c	namespace:SymEngine
UExprPoly	symengine/polys/uexprpoly.cpp	/^UExprPoly::UExprPoly(const RCP<const Basic> &var, UExprDict &&dict)$/;"	f	class:SymEngine::UExprPoly
UExprPoly	symengine/polys/uexprpoly.h	/^class UExprPoly : public USymEnginePoly<UExprDict, UExprPolyBase, UExprPoly>$/;"	c	namespace:SymEngine
UExprPolyBase	symengine/polys/upolybase.h	/^    UExprPolyBase(const RCP<const Basic> &var, Cont &&container)$/;"	f	class:SymEngine::UExprPolyBase
UExprPolyBase	symengine/polys/upolybase.h	/^class UExprPolyBase : public UPolyBase<Cont, Poly>$/;"	c	namespace:SymEngine
UFlintPoly	symengine/polys/uintpoly_flint.h	/^    UFlintPoly(const RCP<const Basic> &var, Container &&dict)$/;"	f	class:SymEngine::UFlintPoly
UFlintPoly	symengine/polys/uintpoly_flint.h	/^class UFlintPoly : public BaseType<Container, Poly>$/;"	c	namespace:SymEngine
UIntDict	symengine/polys/uintpoly.h	/^    UIntDict(const int &i) : ODictWrapper(i)$/;"	f	class:SymEngine::UIntDict
UIntDict	symengine/polys/uintpoly.h	/^    UIntDict(const integer_class &i) : ODictWrapper(i)$/;"	f	class:SymEngine::UIntDict
UIntDict	symengine/polys/uintpoly.h	/^    UIntDict(const map_uint_mpz &p) : ODictWrapper(p)$/;"	f	class:SymEngine::UIntDict
UIntDict	symengine/polys/uintpoly.h	/^class UIntDict : public ODictWrapper<unsigned int, integer_class, UIntDict>$/;"	c	namespace:SymEngine
UIntPoly	symengine/polys/uintpoly.cpp	/^UIntPoly::UIntPoly(const RCP<const Basic> &var, UIntDict &&dict)$/;"	f	class:SymEngine::UIntPoly
UIntPoly	symengine/polys/uintpoly.h	/^class UIntPoly : public USymEnginePoly<UIntDict, UIntPolyBase, UIntPoly>$/;"	c	namespace:SymEngine
UIntPolyBase	symengine/polys/upolybase.h	/^    UIntPolyBase(const RCP<const Basic> &var, Container &&container)$/;"	f	class:SymEngine::UIntPolyBase
UIntPolyBase	symengine/polys/upolybase.h	/^class UIntPolyBase : public UNonExprPoly<Container, Poly, integer_class>$/;"	c	namespace:SymEngine
UIntPolyFlint	symengine/polys/uintpoly_flint.cpp	/^UIntPolyFlint::UIntPolyFlint(const RCP<const Basic> &var, fzp_t &&dict)$/;"	f	class:SymEngine::UIntPolyFlint
UIntPolyFlint	symengine/polys/uintpoly_flint.h	/^class UIntPolyFlint : public UFlintPoly<fzp_t, UIntPolyBase, UIntPolyFlint>$/;"	c	namespace:SymEngine
UIntPolyPiranha	symengine/polys/uintpoly_piranha.cpp	/^UIntPolyPiranha::UIntPolyPiranha(const RCP<const Basic> &var, pintpoly &&dict)$/;"	f	class:SymEngine::UIntPolyPiranha
UIntPolyPiranha	symengine/polys/uintpoly_piranha.h	/^class UIntPolyPiranha$/;"	c	namespace:SymEngine
UMINUS	symengine/parser/parserbase.h	/^        UMINUS,$/;"	e	enum:SymEngine::ParserBase::Tokens__
UNARY_PRECEDORS	symengine/parser/parser_old.cpp	/^    std::set<std::string> UNARY_PRECEDORS$/;"	m	class:SymEngine::ExpressionParser	file:
UNEXPECTED_TOKEN__	symengine/parser/parserbase.h	/^        UNEXPECTED_TOKEN__,$/;"	e	enum:SymEngine::ParserBase::ErrorRecovery__
UNonExprPoly	symengine/polys/upolybase.h	/^    UNonExprPoly(const RCP<const Basic> &var, Container &&container)$/;"	f	class:SymEngine::UNonExprPoly
UNonExprPoly	symengine/polys/upolybase.h	/^class UNonExprPoly : public UPolyBase<Container, Poly>$/;"	c	namespace:SymEngine
UPSeriesPiranha	symengine/series_piranha.cpp	/^UPSeriesPiranha::UPSeriesPiranha(p_expr p, const std::string varname,$/;"	f	class:SymEngine::UPSeriesPiranha
UPSeriesPiranha	symengine/series_piranha.h	/^class UPSeriesPiranha : public SeriesBase<p_expr, Expression, UPSeriesPiranha>$/;"	c	namespace:SymEngine
UPiranhaPoly	symengine/polys/uintpoly_piranha.h	/^    UPiranhaPoly(const RCP<const Basic> &var, Container &&dict)$/;"	f	class:SymEngine::UPiranhaPoly
UPiranhaPoly	symengine/polys/uintpoly_piranha.h	/^class UPiranhaPoly : public BaseType<Container, Poly>$/;"	c	namespace:SymEngine
UPolyBase	symengine/polys/upolybase.h	/^    UPolyBase(const RCP<const Basic> &var, Container &&container)$/;"	f	class:SymEngine::UPolyBase
UPolyBase	symengine/polys/upolybase.h	/^class UPolyBase : public Basic$/;"	c	namespace:SymEngine
URatDict	symengine/polys/uratpoly.h	/^    URatDict(const int &i) : ODictWrapper(i)$/;"	f	class:SymEngine::URatDict
URatDict	symengine/polys/uratpoly.h	/^    URatDict(const map_uint_mpq &p) : ODictWrapper(p)$/;"	f	class:SymEngine::URatDict
URatDict	symengine/polys/uratpoly.h	/^    URatDict(const rational_class &i) : ODictWrapper(i)$/;"	f	class:SymEngine::URatDict
URatDict	symengine/polys/uratpoly.h	/^class URatDict : public ODictWrapper<unsigned int, rational_class, URatDict>$/;"	c	namespace:SymEngine
URatPSeriesFlint	symengine/series_flint.cpp	/^URatPSeriesFlint::URatPSeriesFlint(fqp_t p, const std::string varname,$/;"	f	class:SymEngine::URatPSeriesFlint
URatPSeriesFlint	symengine/series_flint.h	/^class URatPSeriesFlint$/;"	c	namespace:SymEngine
URatPSeriesPiranha	symengine/series_piranha.cpp	/^URatPSeriesPiranha::URatPSeriesPiranha(pp_t p, const std::string varname,$/;"	f	class:SymEngine::URatPSeriesPiranha
URatPSeriesPiranha	symengine/series_piranha.h	/^class URatPSeriesPiranha$/;"	c	namespace:SymEngine
URatPoly	symengine/polys/uratpoly.cpp	/^URatPoly::URatPoly(const RCP<const Basic> &var, URatDict &&dict)$/;"	f	class:SymEngine::URatPoly
URatPoly	symengine/polys/uratpoly.h	/^class URatPoly : public USymEnginePoly<URatDict, URatPolyBase, URatPoly>$/;"	c	namespace:SymEngine
URatPolyBase	symengine/polys/upolybase.h	/^    URatPolyBase(const RCP<const Basic> &var, Container &&container)$/;"	f	class:SymEngine::URatPolyBase
URatPolyBase	symengine/polys/upolybase.h	/^class URatPolyBase : public UNonExprPoly<Container, Poly, rational_class>$/;"	c	namespace:SymEngine
URatPolyFlint	symengine/polys/uintpoly_flint.cpp	/^URatPolyFlint::URatPolyFlint(const RCP<const Basic> &var, fqp_t &&dict)$/;"	f	class:SymEngine::URatPolyFlint
URatPolyFlint	symengine/polys/uintpoly_flint.h	/^class URatPolyFlint : public UFlintPoly<fqp_t, URatPolyBase, URatPolyFlint>$/;"	c	namespace:SymEngine
URatPolyPiranha	symengine/polys/uintpoly_piranha.cpp	/^URatPolyPiranha::URatPolyPiranha(const RCP<const Basic> &var, pratpoly &&dict)$/;"	f	class:SymEngine::URatPolyPiranha
URatPolyPiranha	symengine/polys/uintpoly_piranha.h	/^class URatPolyPiranha$/;"	c	namespace:SymEngine
USymEnginePoly	symengine/polys/usymenginepoly.h	/^    USymEnginePoly(const RCP<const Basic> &var, Container &&dict)$/;"	f	class:SymEngine::USymEnginePoly
USymEnginePoly	symengine/polys/usymenginepoly.h	/^class USymEnginePoly : public BaseType<Container, Poly>$/;"	c	namespace:SymEngine
UnConst	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^  template<class U> struct UnConst$/;"	s	class:Teuchos::ConstTypeTraits
UnConst	symengine/utilities/teuchos/Teuchos_ConstTypeTraits.hpp	/^  template<class U> struct UnConst<const U>$/;"	s	class:Teuchos::ConstTypeTraits
Unequality	symengine/logic.cpp	/^Unequality::Unequality(const RCP<const Basic> &lhs, const RCP<const Basic> &rhs)$/;"	f	class:SymEngine::Unequality
Unequality	symengine/logic.h	/^class Unequality : public Relational$/;"	c	namespace:SymEngine
Union	symengine/sets.cpp	/^Union::Union(const set_set &in) : container_(in)$/;"	f	class:SymEngine::Union
Union	symengine/sets.h	/^class Union : public Set$/;"	c	namespace:SymEngine
UnivariateSeries	symengine/series_generic.h	/^    UnivariateSeries(const UExprDict &sp, const std::string varname,$/;"	f	class:SymEngine::UnivariateSeries
UnivariateSeries	symengine/series_generic.h	/^class UnivariateSeries$/;"	c	namespace:SymEngine
UniversalSet	symengine/sets.h	/^    UniversalSet()$/;"	f	class:SymEngine::UniversalSet
UniversalSet	symengine/sets.h	/^class UniversalSet : public Set$/;"	c	namespace:SymEngine
Unknown	symengine/utilities/catch/catch.hpp	/^        Unknown = -1,$/;"	e	enum:Catch::ResultWas::OfType
UpperGamma	symengine/functions.cpp	/^UpperGamma::UpperGamma(const RCP<const Basic> &s, const RCP<const Basic> &x)$/;"	f	class:SymEngine::UpperGamma
UpperGamma	symengine/functions.h	/^class UpperGamma : public TwoArgFunction$/;"	c	namespace:SymEngine
VectorInt	symengine/parser/scannerbase.h	/^    typedef std::vector<int> VectorInt;$/;"	t	class:SymEngine::ScannerBase
Visitor	symengine/visitor.h	/^class Visitor$/;"	c	namespace:SymEngine
VoidPtrNodeRCPInfoPair_t	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^typedef std::pair<const void*, RCPNodeInfo> VoidPtrNodeRCPInfoPair_t;$/;"	t	namespace:__anon20	file:
VoidPtrNodeRCPInfoPair_t	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^typedef std::pair<const void*, RCPNodeInfo> VoidPtrNodeRCPInfoPair_t;$/;"	t	namespace:__anon41	file:
WHEN	symengine/utilities/catch/catch.hpp	/^#define WHEN(/;"	d
WIN32_LEAN_AND_MEAN	symengine/utilities/catch/catch.hpp	/^#  define WIN32_LEAN_AND_MEAN$/;"	d
WIN32_LEAN_AND_MEAN	symengine/utilities/catch/catch.hpp	/^#  undef WIN32_LEAN_AND_MEAN$/;"	d
WITH_SYMENGINE_RCP	build/symengine/symengine_config.h	/^#define WITH_SYMENGINE_RCP$/;"	d
Warning	symengine/utilities/catch/catch.hpp	/^        Warning = 2,$/;"	e	enum:Catch::ResultWas::OfType
X	symengine/tests/cwrapper/test_cwrapper.c	/^struct X {$/;"	s	file:
XReplaceVisitor	symengine/subs.h	/^    XReplaceVisitor(const map_basic_basic &subs_dict) : subs_dict_(subs_dict)$/;"	f	class:SymEngine::XReplaceVisitor
XReplaceVisitor	symengine/subs.h	/^class XReplaceVisitor : public BaseVisitor<XReplaceVisitor>$/;"	c	namespace:SymEngine
XSTR	symengine/symengine_assert.h	/^#define XSTR(/;"	d
Xor	symengine/logic.cpp	/^Xor::Xor(const vec_boolean &s) : container_{s}$/;"	f	class:SymEngine::Xor
Xor	symengine/logic.h	/^class Xor : public Boolean$/;"	c	namespace:SymEngine
Yes	symengine/utilities/catch/catch.hpp	/^        Yes,$/;"	e	enum:Catch::CaseSensitive::Choice
Zeta	symengine/functions.cpp	/^Zeta::Zeta(const RCP<const Basic> &s) : TwoArgFunction(s, one)$/;"	f	class:SymEngine::Zeta
Zeta	symengine/functions.cpp	/^Zeta::Zeta(const RCP<const Basic> &s, const RCP<const Basic> &a)$/;"	f	class:SymEngine::Zeta
Zeta	symengine/functions.h	/^class Zeta : public TwoArgFunction$/;"	c	namespace:SymEngine
_BSD_SOURCE	symengine/utilities/catch/catch.hpp	/^#   define _BSD_SOURCE$/;"	d
_EOF_	symengine/parser/parser.cpp	/^    _EOF_ = -1,$/;"	e	enum:__anon29::ReservedTokens	file:
_EOF_	symengine/parser/parser.cpp	/^    _EOF_ = -1,$/;"	e	enum:__anon8::ReservedTokens	file:
_TEUCHOS_TYPE_NAME_TRAITS_HPP_	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^#define _TEUCHOS_TYPE_NAME_TRAITS_HPP_$/;"	d
_UNDETERMINED_	symengine/parser/parser.cpp	/^    _UNDETERMINED_ = -2,$/;"	e	enum:__anon29::ReservedTokens	file:
_UNDETERMINED_	symengine/parser/parser.cpp	/^    _UNDETERMINED_ = -2,$/;"	e	enum:__anon8::ReservedTokens	file:
__GMPXX_USE_CXX11	symengine/mp_class.h	/^#define __GMPXX_USE_CXX11 /;"	d
__cmp__	symengine/basic.cpp	/^int Basic::__cmp__(const Basic &o) const$/;"	f	class:SymEngine::Basic
__eq__	symengine/add.cpp	/^bool Add::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Add
__eq__	symengine/complex.cpp	/^bool Complex::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Complex
__eq__	symengine/complex_double.cpp	/^bool ComplexDouble::__eq__(const Basic &o) const$/;"	f	class:SymEngine::ComplexDouble
__eq__	symengine/complex_mpc.cpp	/^bool ComplexMPC::__eq__(const Basic &o) const$/;"	f	class:SymEngine::ComplexMPC
__eq__	symengine/constants.cpp	/^bool Constant::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Constant
__eq__	symengine/functions.cpp	/^bool Derivative::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Derivative
__eq__	symengine/functions.cpp	/^bool FunctionSymbol::__eq__(const Basic &o) const$/;"	f	class:SymEngine::FunctionSymbol
__eq__	symengine/functions.cpp	/^bool Subs::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Subs
__eq__	symengine/functions.h	/^    virtual inline bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::MultiArgFunction
__eq__	symengine/functions.h	/^    virtual inline bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::OneArgFunction
__eq__	symengine/functions.h	/^    virtual inline bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::TwoArgBasic
__eq__	symengine/infinity.cpp	/^bool Infty::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Infty
__eq__	symengine/integer.cpp	/^bool Integer::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Integer
__eq__	symengine/logic.cpp	/^bool And::__eq__(const Basic &o) const$/;"	f	class:SymEngine::And
__eq__	symengine/logic.cpp	/^bool BooleanAtom::__eq__(const Basic &o) const$/;"	f	class:SymEngine::BooleanAtom
__eq__	symengine/logic.cpp	/^bool Contains::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Contains
__eq__	symengine/logic.cpp	/^bool Not::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Not
__eq__	symengine/logic.cpp	/^bool Or::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Or
__eq__	symengine/logic.cpp	/^bool Piecewise::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Piecewise
__eq__	symengine/logic.cpp	/^bool Xor::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Xor
__eq__	symengine/mul.cpp	/^bool Mul::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Mul
__eq__	symengine/nan.cpp	/^bool NaN::__eq__(const Basic &o) const$/;"	f	class:SymEngine::NaN
__eq__	symengine/polys/msymenginepoly.h	/^    bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::MSymEnginePoly
__eq__	symengine/polys/upolybase.h	/^    inline bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::UPolyBase
__eq__	symengine/pow.cpp	/^bool Pow::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Pow
__eq__	symengine/rational.cpp	/^bool Rational::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Rational
__eq__	symengine/real_double.cpp	/^bool RealDouble::__eq__(const Basic &o) const$/;"	f	class:SymEngine::RealDouble
__eq__	symengine/real_mpfr.cpp	/^bool RealMPFR::__eq__(const Basic &o) const$/;"	f	class:SymEngine::RealMPFR
__eq__	symengine/series.h	/^    inline virtual bool __eq__(const Basic &o) const$/;"	f	class:SymEngine::SeriesBase
__eq__	symengine/sets.cpp	/^bool Complement::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Complement
__eq__	symengine/sets.cpp	/^bool ConditionSet::__eq__(const Basic &o) const$/;"	f	class:SymEngine::ConditionSet
__eq__	symengine/sets.cpp	/^bool EmptySet::__eq__(const Basic &o) const$/;"	f	class:SymEngine::EmptySet
__eq__	symengine/sets.cpp	/^bool FiniteSet::__eq__(const Basic &o) const$/;"	f	class:SymEngine::FiniteSet
__eq__	symengine/sets.cpp	/^bool ImageSet::__eq__(const Basic &o) const$/;"	f	class:SymEngine::ImageSet
__eq__	symengine/sets.cpp	/^bool Interval::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Interval
__eq__	symengine/sets.cpp	/^bool Union::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Union
__eq__	symengine/sets.cpp	/^bool UniversalSet::__eq__(const Basic &o) const$/;"	f	class:SymEngine::UniversalSet
__eq__	symengine/symbol.cpp	/^bool Dummy::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Dummy
__eq__	symengine/symbol.cpp	/^bool Symbol::__eq__(const Basic &o) const$/;"	f	class:SymEngine::Symbol
__func__	symengine/tests/cwrapper/test_cwrapper.c	/^#define __func__ /;"	d	file:
__hash__	symengine/add.cpp	/^hash_t Add::__hash__() const$/;"	f	class:SymEngine::Add
__hash__	symengine/complex.cpp	/^hash_t Complex::__hash__() const$/;"	f	class:SymEngine::Complex
__hash__	symengine/complex_double.cpp	/^hash_t ComplexDouble::__hash__() const$/;"	f	class:SymEngine::ComplexDouble
__hash__	symengine/complex_mpc.cpp	/^hash_t ComplexMPC::__hash__() const$/;"	f	class:SymEngine::ComplexMPC
__hash__	symengine/constants.cpp	/^hash_t Constant::__hash__() const$/;"	f	class:SymEngine::Constant
__hash__	symengine/fields.cpp	/^hash_t GaloisField::__hash__() const$/;"	f	class:SymEngine::GaloisField
__hash__	symengine/functions.cpp	/^hash_t Derivative::__hash__() const$/;"	f	class:SymEngine::Derivative
__hash__	symengine/functions.cpp	/^hash_t FunctionSymbol::__hash__() const$/;"	f	class:SymEngine::FunctionSymbol
__hash__	symengine/functions.cpp	/^hash_t Subs::__hash__() const$/;"	f	class:SymEngine::Subs
__hash__	symengine/functions.h	/^    inline hash_t __hash__() const$/;"	f	class:SymEngine::MultiArgFunction
__hash__	symengine/functions.h	/^    inline hash_t __hash__() const$/;"	f	class:SymEngine::OneArgFunction
__hash__	symengine/functions.h	/^    inline hash_t __hash__() const$/;"	f	class:SymEngine::TwoArgBasic
__hash__	symengine/infinity.cpp	/^hash_t Infty::__hash__() const$/;"	f	class:SymEngine::Infty
__hash__	symengine/integer.cpp	/^hash_t Integer::__hash__() const$/;"	f	class:SymEngine::Integer
__hash__	symengine/logic.cpp	/^hash_t And::__hash__() const$/;"	f	class:SymEngine::And
__hash__	symengine/logic.cpp	/^hash_t BooleanAtom::__hash__() const$/;"	f	class:SymEngine::BooleanAtom
__hash__	symengine/logic.cpp	/^hash_t Contains::__hash__() const$/;"	f	class:SymEngine::Contains
__hash__	symengine/logic.cpp	/^hash_t Not::__hash__() const$/;"	f	class:SymEngine::Not
__hash__	symengine/logic.cpp	/^hash_t Or::__hash__() const$/;"	f	class:SymEngine::Or
__hash__	symengine/logic.cpp	/^hash_t Piecewise::__hash__() const$/;"	f	class:SymEngine::Piecewise
__hash__	symengine/logic.cpp	/^hash_t Xor::__hash__() const$/;"	f	class:SymEngine::Xor
__hash__	symengine/mul.cpp	/^hash_t Mul::__hash__() const$/;"	f	class:SymEngine::Mul
__hash__	symengine/nan.cpp	/^hash_t NaN::__hash__() const$/;"	f	class:SymEngine::NaN
__hash__	symengine/polys/msymenginepoly.cpp	/^hash_t MExprPoly::__hash__() const$/;"	f	class:SymEngine::MExprPoly
__hash__	symengine/polys/msymenginepoly.cpp	/^hash_t MIntPoly::__hash__() const$/;"	f	class:SymEngine::MIntPoly
__hash__	symengine/polys/uexprpoly.cpp	/^hash_t UExprPoly::__hash__() const$/;"	f	class:SymEngine::UExprPoly
__hash__	symengine/polys/uintpoly.cpp	/^hash_t UIntPoly::__hash__() const$/;"	f	class:SymEngine::UIntPoly
__hash__	symengine/polys/uintpoly_flint.cpp	/^hash_t UIntPolyFlint::__hash__() const$/;"	f	class:SymEngine::UIntPolyFlint
__hash__	symengine/polys/uintpoly_flint.cpp	/^hash_t URatPolyFlint::__hash__() const$/;"	f	class:SymEngine::URatPolyFlint
__hash__	symengine/polys/uintpoly_piranha.cpp	/^hash_t UIntPolyPiranha::__hash__() const$/;"	f	class:SymEngine::UIntPolyPiranha
__hash__	symengine/polys/uintpoly_piranha.cpp	/^hash_t URatPolyPiranha::__hash__() const$/;"	f	class:SymEngine::URatPolyPiranha
__hash__	symengine/polys/uratpoly.cpp	/^hash_t URatPoly::__hash__() const$/;"	f	class:SymEngine::URatPoly
__hash__	symengine/pow.cpp	/^hash_t Pow::__hash__() const$/;"	f	class:SymEngine::Pow
__hash__	symengine/rational.cpp	/^hash_t Rational::__hash__() const$/;"	f	class:SymEngine::Rational
__hash__	symengine/real_double.cpp	/^hash_t RealDouble::__hash__() const$/;"	f	class:SymEngine::RealDouble
__hash__	symengine/real_mpfr.cpp	/^hash_t RealMPFR::__hash__() const$/;"	f	class:SymEngine::RealMPFR
__hash__	symengine/series_flint.cpp	/^hash_t URatPSeriesFlint::__hash__() const$/;"	f	class:SymEngine::URatPSeriesFlint
__hash__	symengine/series_generic.cpp	/^hash_t UnivariateSeries::__hash__() const$/;"	f	class:SymEngine::UnivariateSeries
__hash__	symengine/series_piranha.cpp	/^hash_t UPSeriesPiranha::__hash__() const$/;"	f	class:SymEngine::UPSeriesPiranha
__hash__	symengine/series_piranha.cpp	/^hash_t URatPSeriesPiranha::__hash__() const$/;"	f	class:SymEngine::URatPSeriesPiranha
__hash__	symengine/sets.cpp	/^hash_t Complement::__hash__() const$/;"	f	class:SymEngine::Complement
__hash__	symengine/sets.cpp	/^hash_t ConditionSet::__hash__() const$/;"	f	class:SymEngine::ConditionSet
__hash__	symengine/sets.cpp	/^hash_t EmptySet::__hash__() const$/;"	f	class:SymEngine::EmptySet
__hash__	symengine/sets.cpp	/^hash_t FiniteSet::__hash__() const$/;"	f	class:SymEngine::FiniteSet
__hash__	symengine/sets.cpp	/^hash_t ImageSet::__hash__() const$/;"	f	class:SymEngine::ImageSet
__hash__	symengine/sets.cpp	/^hash_t Interval::__hash__() const$/;"	f	class:SymEngine::Interval
__hash__	symengine/sets.cpp	/^hash_t Union::__hash__() const$/;"	f	class:SymEngine::Union
__hash__	symengine/sets.cpp	/^hash_t UniversalSet::__hash__() const$/;"	f	class:SymEngine::UniversalSet
__hash__	symengine/symbol.cpp	/^hash_t Dummy::__hash__() const$/;"	f	class:SymEngine::Dummy
__hash__	symengine/symbol.cpp	/^hash_t Symbol::__hash__() const$/;"	f	class:SymEngine::Symbol
__neq__	symengine/basic-inl.h	/^inline bool Basic::__neq__(const Basic &o) const$/;"	f	class:SymEngine::Basic
__str__	symengine/basic.cpp	/^std::string Basic::__str__() const$/;"	f	class:SymEngine::Basic
__str__	symengine/matrix.cpp	/^std::string MatrixBase::__str__() const$/;"	f	class:SymEngine::MatrixBase
__str__	symengine/number.h	/^    virtual std::string __str__() const$/;"	f	class:SymEngine::NumberWrapper
__str__	symengine/polys/uexprpoly.h	/^    std::string __str__(const std::string name) const$/;"	f	class:SymEngine::UExprDict
_basic_to_mpoly	symengine/polys/basic_conversions.h	/^_basic_to_mpoly(const RCP<const Basic> &basic, const set_basic &gens)$/;"	f	namespace:SymEngine
_basic_to_upoly	symengine/polys/basic_conversions.h	/^_basic_to_upoly(const RCP<const Basic> &basic, const RCP<const Basic> &gen)$/;"	f	namespace:SymEngine
_bench_mertens	benchmarks/ntheorybench.cpp	/^void _bench_mertens(const unsigned long a)$/;"	f
_bench_mobius	benchmarks/ntheorybench.cpp	/^void _bench_mobius(const unsigned long a)$/;"	f
_bench_mp_sqrt	benchmarks/ntheorybench.cpp	/^void _bench_mp_sqrt(const unsigned long &a)$/;"	f
_bench_prime_factor_multiplicities	benchmarks/ntheorybench.cpp	/^void _bench_prime_factor_multiplicities(const unsigned long &a)$/;"	f
_clear	symengine/ntheory.cpp	/^bool Sieve::_clear = true;$/;"	m	class:SymEngine::Sieve	file:
_clear	symengine/ntheory.h	/^    static bool _clear;$/;"	m	class:SymEngine::Sieve
_coef_dict_add_term	symengine/expand.cpp	/^    inline void _coef_dict_add_term(const RCP<const Number> &c,$/;"	f	class:SymEngine::ExpandVisitor
_crt_cartesian	symengine/ntheory.cpp	/^void _crt_cartesian(std::vector<RCP<const Integer>> &R,$/;"	f	namespace:SymEngine::__anon15
_crt_cartesian	symengine/ntheory.cpp	/^void _crt_cartesian(std::vector<RCP<const Integer>> &R,$/;"	f	namespace:SymEngine::__anon36
_direction	symengine/infinity.h	/^    RCP<const Number> _direction;$/;"	m	class:SymEngine::Infty
_discrete_log	symengine/ntheory.cpp	/^void _discrete_log(integer_class &log, const integer_class &a,$/;"	f	namespace:SymEngine::__anon17
_discrete_log	symengine/ntheory.cpp	/^void _discrete_log(integer_class &log, const integer_class &a,$/;"	f	namespace:SymEngine::__anon38
_error_	symengine/parser/parser.cpp	/^    _error_ = 256$/;"	e	enum:__anon29::ReservedTokens	file:
_error_	symengine/parser/parser.cpp	/^    _error_ = 256$/;"	e	enum:__anon8::ReservedTokens	file:
_extend	symengine/ntheory.cpp	/^void Sieve::_extend(unsigned limit)$/;"	f	class:SymEngine::Sieve
_factor_lehman_method	symengine/ntheory.cpp	/^int _factor_lehman_method(integer_class &rop, const integer_class &n)$/;"	f	namespace:SymEngine::__anon12
_factor_lehman_method	symengine/ntheory.cpp	/^int _factor_lehman_method(integer_class &rop, const integer_class &n)$/;"	f	namespace:SymEngine::__anon33
_factor_pollard_pm1_method	symengine/ntheory.cpp	/^int _factor_pollard_pm1_method(integer_class &rop, const integer_class &n,$/;"	f	namespace:SymEngine::__anon13
_factor_pollard_pm1_method	symengine/ntheory.cpp	/^int _factor_pollard_pm1_method(integer_class &rop, const integer_class &n,$/;"	f	namespace:SymEngine::__anon34
_factor_pollard_rho_method	symengine/ntheory.cpp	/^int _factor_pollard_rho_method(integer_class &rop, const integer_class &n,$/;"	f	namespace:SymEngine::__anon14
_factor_pollard_rho_method	symengine/ntheory.cpp	/^int _factor_pollard_rho_method(integer_class &rop, const integer_class &n,$/;"	f	namespace:SymEngine::__anon35
_factor_trial_division_sieve	symengine/ntheory.cpp	/^int _factor_trial_division_sieve(integer_class &factor, const integer_class &N)$/;"	f	namespace:SymEngine::__anon12
_factor_trial_division_sieve	symengine/ntheory.cpp	/^int _factor_trial_division_sieve(integer_class &factor, const integer_class &N)$/;"	f	namespace:SymEngine::__anon33
_field_1_	symengine/parser/parser.cpp	/^        int _field_1_; \/\/ initializer, allowing initializations$/;"	m	union:__anon29::SR__::__anon31	file:
_field_1_	symengine/parser/parser.cpp	/^        int _field_1_; \/\/ initializer, allowing initializations$/;"	m	union:__anon8::SR__::__anon10	file:
_field_2_	symengine/parser/parser.cpp	/^        int _field_2_;$/;"	m	union:__anon29::SR__::__anon32	file:
_field_2_	symengine/parser/parser.cpp	/^        int _field_2_;$/;"	m	union:__anon8::SR__::__anon11	file:
_find_gens_poly	symengine/polys/basic_conversions.cpp	/^umap_basic_num _find_gens_poly(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
_find_gens_poly_pow	symengine/polys/basic_conversions.cpp	/^umap_basic_num _find_gens_poly_pow(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
_gf_pow_pnm1d2	symengine/fields.cpp	/^GaloisFieldDict::_gf_pow_pnm1d2(const GaloisFieldDict &f, const unsigned &n,$/;"	f	class:SymEngine::GaloisFieldDict
_gf_trace_map	symengine/fields.cpp	/^GaloisFieldDict::_gf_trace_map(const GaloisFieldDict &f, const unsigned long &n,$/;"	f	class:SymEngine::GaloisFieldDict
_imulnum	symengine/expand.cpp	/^inline void _imulnum(const Ptr<RCP<const Number>> &self,$/;"	f	namespace:SymEngine
_index	symengine/ntheory.h	/^        unsigned _index;$/;"	m	class:SymEngine::Sieve::iterator
_is_nthroot_mod1	symengine/ntheory.cpp	/^bool _is_nthroot_mod1(const integer_class &a, const integer_class &n,$/;"	f	namespace:SymEngine::__anon17
_is_nthroot_mod1	symengine/ntheory.cpp	/^bool _is_nthroot_mod1(const integer_class &a, const integer_class &n,$/;"	f	namespace:SymEngine::__anon38
_is_nthroot_mod_prime_power	symengine/ntheory.cpp	/^bool _is_nthroot_mod_prime_power(const integer_class &a, const integer_class &n,$/;"	f	namespace:SymEngine
_limit	symengine/ntheory.h	/^        unsigned _limit;$/;"	m	class:SymEngine::Sieve::iterator
_mul2	build/cmake/checkcxx11.cpp	/^long double operator "" _mul2(long double x) {$/;"	f
_mul2	cmake/checkcxx11.cpp	/^long double operator "" _mul2(long double x) {$/;"	f
_mulnum	symengine/expand.cpp	/^inline RCP<const Number> _mulnum(const RCP<const Number> &x,$/;"	f	namespace:SymEngine
_nthroot_mod1	symengine/ntheory.cpp	/^bool _nthroot_mod1(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon17
_nthroot_mod1	symengine/ntheory.cpp	/^bool _nthroot_mod1(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon38
_nthroot_mod_prime_power	symengine/ntheory.cpp	/^bool _nthroot_mod_prime_power(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon17
_nthroot_mod_prime_power	symengine/ntheory.cpp	/^bool _nthroot_mod_prime_power(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon38
_prime_power	symengine/ntheory.cpp	/^bool _prime_power(integer_class &p, integer_class &e, const integer_class &n)$/;"	f	namespace:SymEngine::__anon15
_prime_power	symengine/ntheory.cpp	/^bool _prime_power(integer_class &p, integer_class &e, const integer_class &n)$/;"	f	namespace:SymEngine::__anon36
_primes	symengine/ntheory.cpp	/^std::vector<unsigned> Sieve::_primes = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};$/;"	m	class:SymEngine::Sieve	file:
_primes	symengine/ntheory.h	/^    static std::vector<unsigned> _primes;$/;"	m	class:SymEngine::Sieve
_primitive_root	symengine/ntheory.cpp	/^void _primitive_root(integer_class &g, const integer_class &p,$/;"	f	namespace:SymEngine::__anon15
_primitive_root	symengine/ntheory.cpp	/^void _primitive_root(integer_class &g, const integer_class &p,$/;"	f	namespace:SymEngine::__anon36
_primitive_root_list	symengine/ntheory.cpp	/^void _primitive_root_list(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon16
_primitive_root_list	symengine/ntheory.cpp	/^void _primitive_root_list(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine::__anon37
_print_pow	symengine/printers/codegen.cpp	/^void C89CodePrinter::_print_pow(std::ostringstream &o,$/;"	f	class:SymEngine::C89CodePrinter
_print_pow	symengine/printers/codegen.cpp	/^void C99CodePrinter::_print_pow(std::ostringstream &o,$/;"	f	class:SymEngine::C99CodePrinter
_print_pow	symengine/printers/codegen.cpp	/^void JSCodePrinter::_print_pow(std::ostringstream &o, const RCP<const Basic> &a,$/;"	f	class:SymEngine::JSCodePrinter
_print_pow	symengine/printers/latex.cpp	/^void LatexPrinter::_print_pow(std::ostringstream &o, const RCP<const Basic> &a,$/;"	f	class:SymEngine::LatexPrinter
_print_pow	symengine/printers/strprinter.cpp	/^void JuliaStrPrinter::_print_pow(std::ostringstream &o,$/;"	f	class:SymEngine::JuliaStrPrinter
_print_pow	symengine/printers/strprinter.cpp	/^void StrPrinter::_print_pow(std::ostringstream &o, const RCP<const Basic> &a,$/;"	f	class:SymEngine::StrPrinter
_print_sign	symengine/printers/strprinter.cpp	/^char _print_sign(const T &i)$/;"	f	namespace:SymEngine
_q	symengine/mp_class.h	/^inline rational_class operator"" _q(const char *str)$/;"	f	namespace:SymEngine::literals
_series_cos	symengine/series.h	/^    static inline Poly _series_cos(const Poly &s, unsigned int prec)$/;"	f	class:SymEngine::SeriesBase
_series_sin	symengine/series.h	/^    static inline Poly _series_sin(const Poly &s, unsigned int prec)$/;"	f	class:SymEngine::SeriesBase
_set_null	build/cmake/checkcxx11.cpp	/^    void _set_null() { ptr_ = NULL; }$/;"	f	class:RCP
_set_null	cmake/checkcxx11.cpp	/^    void _set_null() { ptr_ = NULL; }$/;"	f	class:RCP
_set_null	symengine/symengine_rcp.h	/^    void _set_null()$/;"	f	class:SymEngine::RCP
_sieve_size	symengine/ntheory.cpp	/^unsigned Sieve::_sieve_size = 32 * 1024 * 8; \/\/ 32K in bits$/;"	m	class:SymEngine::Sieve	file:
_sieve_size	symengine/ntheory.h	/^    static unsigned _sieve_size;$/;"	m	class:SymEngine::Sieve
_sqrt_mod_prime	symengine/ntheory.cpp	/^bool _sqrt_mod_prime(integer_class &rop, const integer_class &a,$/;"	f	namespace:SymEngine::__anon17
_sqrt_mod_prime	symengine/ntheory.cpp	/^bool _sqrt_mod_prime(integer_class &rop, const integer_class &a,$/;"	f	namespace:SymEngine::__anon38
_sqrt_mod_tonelli_shanks	symengine/ntheory.cpp	/^bool _sqrt_mod_tonelli_shanks(integer_class &rop, const integer_class &a,$/;"	f	namespace:SymEngine::__anon17
_sqrt_mod_tonelli_shanks	symengine/ntheory.cpp	/^bool _sqrt_mod_tonelli_shanks(integer_class &rop, const integer_class &a,$/;"	f	namespace:SymEngine::__anon38
_state	symengine/mp_class.h	/^    gmp_randstate_t _state;$/;"	m	class:SymEngine::mp_randstate
_test_prime_factor_multiplicities	symengine/tests/ntheory/test_ntheory.cpp	/^void _test_prime_factor_multiplicities(const RCP<const Integer> &a)$/;"	f
_test_primefactors	symengine/tests/ntheory/test_ntheory.cpp	/^void _test_primefactors(const RCP<const Integer> &a, unsigned size)$/;"	f
_z	symengine/mp_class.h	/^inline integer_class operator"" _z(const char *str)$/;"	f	namespace:SymEngine::literals
a_	symengine/functions.h	/^    RCP<const Basic> a_; \/\/! `a` in `TwoArgBasic(a, b)`$/;"	m	class:SymEngine::TwoArgBasic
abs	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> abs(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
abs	symengine/functions.cpp	/^RCP<const Basic> abs(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
accept	symengine/parser/scanner.cpp	/^void ScannerBase::accept(size_t nChars) \/\/ old name: less$/;"	f	class:SymEngine::ScannerBase
access_content	symengine/utilities/teuchos/Teuchos_any.hpp	/^  const placeholder* access_content() const$/;"	f	class:Teuchos::any
access_content	symengine/utilities/teuchos/Teuchos_any.hpp	/^  placeholder* access_content()$/;"	f	class:Teuchos::any
access_private_node	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const RCPNodeHandle& RCP<T>::access_private_node() const$/;"	f	class:Teuchos::RCP
access_private_ptr	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^  T* access_private_ptr() const$/;"	f	class:Teuchos::Ptr
access_private_ptr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T* RCP<T>::access_private_ptr() const$/;"	f	class:Teuchos::RCP
access_rcp	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^  const RCP<T> access_rcp() const$/;"	f	class:Teuchos::Ptr
acos	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acos(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acos	symengine/functions.cpp	/^RCP<const Basic> acos(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
acos	symengine/series.h	/^    static inline Coeff acos(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
acos	symengine/series_generic.cpp	/^Expression UnivariateSeries::acos(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
acos	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::acos(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
acosh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acosh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acosh	symengine/functions.cpp	/^RCP<const Basic> acosh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
acot	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acot(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acot	symengine/functions.cpp	/^RCP<const Basic> acot(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
acoth	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acoth(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acoth	symengine/functions.cpp	/^RCP<const Basic> acoth(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
acsc	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acsc(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acsc	symengine/functions.cpp	/^RCP<const Basic> acsc(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
acsch	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> acsch(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
acsch	symengine/functions.cpp	/^RCP<const Basic> acsch(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
actionType__	symengine/parser/scanner.cpp	/^ScannerBase::ActionType__ ScannerBase::actionType__(size_t range)$/;"	f	class:SymEngine::ScannerBase
add	symengine/add.cpp	/^RCP<const Basic> add(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	namespace:SymEngine
add	symengine/add.cpp	/^RCP<const Basic> add(const vec_basic &a)$/;"	f	namespace:SymEngine
add	symengine/complex.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::Complex
add	symengine/complex_double.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const ComplexMPC &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::add(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/complex_mpc.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
add	symengine/infinity.cpp	/^RCP<const Number> Infty::add(const Number &other) const$/;"	f	class:SymEngine::Infty
add	symengine/integer.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::Integer
add	symengine/nan.cpp	/^RCP<const Number> NaN::add(const Number &other) const$/;"	f	class:SymEngine::NaN
add	symengine/rational.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::Rational
add	symengine/real_double.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::RealDouble
add	symengine/real_mpfr.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
add	symengine/series.h	/^    virtual RCP<const Number> add(const Number &other) const$/;"	f	class:SymEngine::SeriesBase
addNewRCPNode	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::addNewRCPNode( RCPNode* rcp_node, const std::string &info )$/;"	f	class:Teuchos::RCPNodeTracer
addRef	symengine/utilities/catch/catch.hpp	/^        virtual void addRef() const {$/;"	f	struct:Catch::SharedImpl
add_dense_dense	symengine/dense_matrix.cpp	/^void add_dense_dense(const DenseMatrix &A, const DenseMatrix &B, DenseMatrix &C)$/;"	f	namespace:SymEngine
add_dense_scalar	symengine/dense_matrix.cpp	/^void add_dense_scalar(const DenseMatrix &A, const RCP<const Basic> &k,$/;"	f	namespace:SymEngine
add_matrix	symengine/dense_matrix.cpp	/^void DenseMatrix::add_matrix(const MatrixBase &other, MatrixBase &result) const$/;"	f	class:SymEngine::DenseMatrix
add_matrix	symengine/sparse_matrix.cpp	/^void CSRMatrix::add_matrix(const MatrixBase &other, MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
add_mpoly	symengine/polys/msymenginepoly.h	/^RCP<const Poly> add_mpoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
add_scalar	symengine/dense_matrix.cpp	/^void DenseMatrix::add_scalar(const RCP<const Basic> &k,$/;"	f	class:SymEngine::DenseMatrix
add_scalar	symengine/sparse_matrix.cpp	/^void CSRMatrix::add_scalar(const RCP<const Basic> &k, MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
add_to_gen_set	symengine/polys/basic_conversions.cpp	/^    void add_to_gen_set(const RCP<const Basic> &base,$/;"	f	class:SymEngine::PolyGeneratorVisitor
add_to_sorted_vec	symengine/cse.cpp	/^void add_to_sorted_vec(std::vector<unsigned> &vec, unsigned number)$/;"	f	namespace:SymEngine
add_upoly	symengine/polys/upolybase.h	/^RCP<const Poly> add_upoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
addcomp	symengine/complex.h	/^    inline RCP<const Number> addcomp(const Complex &other) const$/;"	f	class:SymEngine::Complex
addcomp	symengine/complex.h	/^    inline RCP<const Number> addcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
addcomp	symengine/complex.h	/^    inline RCP<const Number> addcomp(const Rational &other) const$/;"	f	class:SymEngine::Complex
addcomp	symengine/complex_double.h	/^    RCP<const Number> addcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
addcomp	symengine/complex_double.h	/^    RCP<const Number> addcomp(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
addcomp	symengine/complex_double.h	/^    RCP<const Number> addcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
addcomp	symengine/complex_double.h	/^    RCP<const Number> addcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
addcomp	symengine/complex_double.h	/^    RCP<const Number> addcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
addint	symengine/integer.h	/^    inline RCP<const Integer> addint(const Integer &other) const$/;"	f	class:SymEngine::Integer
addnum	symengine/number.h	/^inline RCP<const Number> addnum(const RCP<const Number> &self,$/;"	f	namespace:SymEngine
addr	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr;$/;"	m	struct:__anon22::line_data	file:
addr	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr;$/;"	m	struct:__anon22::match_data	file:
addr	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr;$/;"	m	struct:__anon43::line_data	file:
addr	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr;$/;"	m	struct:__anon43::match_data	file:
addr2str	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string addr2str(std::string file_name, bfd_vma addr)$/;"	f	namespace:__anon22
addr2str	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string addr2str(std::string file_name, bfd_vma addr)$/;"	f	namespace:__anon43
addr_in_file	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr_in_file;$/;"	m	struct:__anon22::match_data	file:
addr_in_file	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma addr_in_file;$/;"	m	struct:__anon43::match_data	file:
addrat	symengine/rational.h	/^    inline RCP<const Number> addrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
addrat	symengine/rational.h	/^    inline RCP<const Number> addrat(const Rational &other) const$/;"	f	class:SymEngine::Rational
addreal	symengine/real_double.h	/^    RCP<const Number> addreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
addreal	symengine/real_double.h	/^    RCP<const Number> addreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
addreal	symengine/real_double.h	/^    RCP<const Number> addreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
addreal	symengine/real_double.h	/^    RCP<const Number> addreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealDouble
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
addreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::addreal(const RealMPFR &other) const$/;"	f	class:SymEngine::RealMPFR
adds	symengine/cse.cpp	/^    set_basic adds;$/;"	m	class:SymEngine::OptsCSEVisitor	file:
all_files	bin/test_make_install.py	/^all_files = set([relpath(x, symengine_dir) for x in glob(join(symengine_dir, '*.h'))])$/;"	v
alwaysFalse	symengine/utilities/catch/catch.hpp	/^    inline bool alwaysFalse() { return false; }$/;"	f	namespace:Catch
alwaysTrue	symengine/utilities/catch/catch.hpp	/^    inline bool alwaysTrue() { return true; }$/;"	f	namespace:Catch
always_true	benchmarks/nonius.h++	/^        template <typename> struct always_true : std::true_type {};$/;"	s	namespace:nonius::detail
analyse	benchmarks/nonius.h++	/^        sample_analysis<Duration> analyse(configuration cfg, environment<Duration>, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
analyse_samples	benchmarks/nonius.h++	/^        bootstrap_analysis analyse_samples(double confidence_level, int n_resamples, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
analysis	benchmarks/nonius.h++	/^            sample_analysis<fp_seconds> analysis;$/;"	m	struct:nonius::junit_reporter::result
analysis_complete	benchmarks/nonius.h++	/^        void analysis_complete(sample_analysis<fp_seconds> const& analysis) {$/;"	f	struct:nonius::reporter
analysis_start	benchmarks/nonius.h++	/^        void analysis_start() {$/;"	f	struct:nonius::reporter
and_or	symengine/logic.cpp	/^RCP<const Boolean> and_or(const set_boolean &s, const bool &op_x_notx)$/;"	f	namespace:SymEngine
any	symengine/utilities/teuchos/Teuchos_any.hpp	/^  any()$/;"	f	class:Teuchos::any
any	symengine/utilities/teuchos/Teuchos_any.hpp	/^  any(const any & other)$/;"	f	class:Teuchos::any
any	symengine/utilities/teuchos/Teuchos_any.hpp	/^  explicit any(const ValueType & value)$/;"	f	class:Teuchos::any
any	symengine/utilities/teuchos/Teuchos_any.hpp	/^class TEUCHOS_LIB_DLL_EXPORT any$/;"	c	namespace:Teuchos
any_cast	symengine/utilities/teuchos/Teuchos_any.hpp	/^ValueType& any_cast(any &operand)$/;"	f	namespace:Teuchos
any_cast	symengine/utilities/teuchos/Teuchos_any.hpp	/^const ValueType& any_cast(const any &operand)$/;"	f	namespace:Teuchos
apply	symengine/as_real_imag.cpp	/^    void apply(const Basic &b)$/;"	f	class:SymEngine::RealImagVisitor
apply	symengine/cse.cpp	/^    virtual RCP<const Basic> apply(const RCP<const Basic> &orig_expr)$/;"	f	class:SymEngine::RebuildVisitor
apply	symengine/eval_arb.cpp	/^    void apply(arb_ptr result, const Basic &b)$/;"	f	class:SymEngine::EvalArbVisitor
apply	symengine/eval_double.cpp	/^    T apply(const Basic &b)$/;"	f	class:SymEngine::EvalDoubleVisitor
apply	symengine/eval_mpc.cpp	/^    void apply(mpc_ptr result, const Basic &b)$/;"	f	class:SymEngine::EvalMPCVisitor
apply	symengine/eval_mpfr.cpp	/^    void apply(mpfr_ptr result, const Basic &b)$/;"	f	class:SymEngine::EvalMPFRVisitor
apply	symengine/expand.cpp	/^    RCP<const Basic> apply(const Basic &b)$/;"	f	class:SymEngine::ExpandVisitor
apply	symengine/lambda_double.h	/^    fn apply(const Basic &b)$/;"	f	class:SymEngine::LambdaDoubleVisitor
apply	symengine/llvm_double.cpp	/^llvm::Value *LLVMDoubleVisitor::apply(const Basic &b)$/;"	f	class:SymEngine::LLVMDoubleVisitor
apply	symengine/numer_denom.cpp	/^    void apply(const Basic &b)$/;"	f	class:SymEngine::NumerDenomVisitor
apply	symengine/polys/basic_conversions.cpp	/^    umap_basic_num apply(const Basic &b)$/;"	f	class:SymEngine::PolyGeneratorVisitor
apply	symengine/polys/basic_conversions.cpp	/^    umap_basic_num apply(const Basic &b, const RCP<const Basic> &base)$/;"	f	class:SymEngine::PolyGeneratorVisitorPow
apply	symengine/polys/basic_conversions.h	/^    D apply(const Basic &b)$/;"	f	class:SymEngine::BasicToUPolyBase
apply	symengine/polys/basic_conversions.h	/^    Dict apply(const Basic &b)$/;"	f	class:SymEngine::BasicToMPolyBase
apply	symengine/printers/mathml.cpp	/^std::string MathMLPrinter::apply(const Basic &b)$/;"	f	class:SymEngine::MathMLPrinter
apply	symengine/printers/strprinter.cpp	/^std::string StrPrinter::apply(const Basic &b)$/;"	f	class:SymEngine::StrPrinter
apply	symengine/printers/strprinter.cpp	/^std::string StrPrinter::apply(const RCP<const Basic> &b)$/;"	f	class:SymEngine::StrPrinter
apply	symengine/printers/strprinter.cpp	/^std::string StrPrinter::apply(const vec_basic &d)$/;"	f	class:SymEngine::StrPrinter
apply	symengine/series_visitor.h	/^    Poly apply(const RCP<const Basic> &x)$/;"	f	class:SymEngine::SeriesVisitor
apply	symengine/series_visitor.h	/^    bool apply(const Basic &b, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
apply	symengine/solve.cpp	/^    RCP<const Set> apply(const Basic &b)$/;"	f	class:SymEngine::InvertComplexVisitor
apply	symengine/solve.cpp	/^    bool apply(const Basic &b)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
apply	symengine/solve.cpp	/^    bool apply(const RCP<const Basic> &b)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
apply	symengine/subs.h	/^    RCP<const Basic> apply(const Basic &x)$/;"	f	class:SymEngine::XReplaceVisitor
apply	symengine/subs.h	/^    RCP<const Basic> apply(const RCP<const Basic> &x)$/;"	f	class:SymEngine::XReplaceVisitor
apply	symengine/visitor.cpp	/^    set_basic apply(const Basic &b)$/;"	f	class:SymEngine::FreeSymbolsVisitor
apply	symengine/visitor.cpp	/^    set_basic apply(const MatrixBase &m)$/;"	f	class:SymEngine::FreeSymbolsVisitor
apply	symengine/visitor.cpp	/^RCP<const Basic> TransformVisitor::apply(const RCP<const Basic> &x)$/;"	f	class:SymEngine::TransformVisitor
apply	symengine/visitor.cpp	/^void CountOpsVisitor::apply(const Basic &b)$/;"	f	class:SymEngine::CountOpsVisitor
apply	symengine/visitor.h	/^    RCP<const Basic> apply(const Basic &b)$/;"	f	class:SymEngine::CoeffVisitor
apply	symengine/visitor.h	/^    bool apply(const Basic &b)$/;"	f	class:SymEngine::HasSymbolVisitor
apply	symengine/visitor.h	/^    set_basic apply(const Basic &b)$/;"	f	class:SymEngine::AtomsVisitor
applyEvaluator	symengine/utilities/catch/catch.hpp	/^    bool applyEvaluator( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal
arcSafeRelease	symengine/utilities/catch/catch.hpp	/^inline void arcSafeRelease( NSObject* ){}$/;"	f
arcSafeRelease	symengine/utilities/catch/catch.hpp	/^inline void arcSafeRelease( NSObject* obj ) {$/;"	f
arg_	symengine/functions.h	/^    RCP<const Basic> arg_; \/\/! The `arg` in `OneArgFunction(arg)`$/;"	m	class:SymEngine::OneArgFunction
arg_	symengine/functions.h	/^    RCP<const Basic> arg_; \/\/! The expression to be differentiated$/;"	m	class:SymEngine::Derivative
arg_	symengine/functions.h	/^    RCP<const Basic> arg_;$/;"	m	class:SymEngine::Subs
arg_	symengine/functions.h	/^    vec_basic arg_;$/;"	m	class:SymEngine::MultiArgFunction
arg_	symengine/logic.h	/^    RCP<const Boolean> arg_;$/;"	m	class:SymEngine::Not
arg_to_funcset	symengine/cse.cpp	/^    std::vector<std::set<unsigned>> arg_to_funcset;$/;"	m	class:SymEngine::FuncArgTracker	file:
argument	benchmarks/nonius.h++	/^            std::string argument;$/;"	m	struct:nonius::detail::option
argument_error	benchmarks/nonius.h++	/^        struct argument_error {$/;"	s	namespace:nonius::detail
as	symengine/parser/scannerbase.h	/^inline ReturnType constexpr ScannerBase::as(ArgType value)$/;"	f	class:SymEngine::ScannerBase
as_base_exp	symengine/mul.cpp	/^void Mul::as_base_exp(const RCP<const Basic> &self,$/;"	f	class:SymEngine::Mul
as_basic	symengine/series_flint.cpp	/^RCP<const Basic> URatPSeriesFlint::as_basic() const$/;"	f	class:SymEngine::URatPSeriesFlint
as_basic	symengine/series_generic.cpp	/^RCP<const Basic> UnivariateSeries::as_basic() const$/;"	f	class:SymEngine::UnivariateSeries
as_basic	symengine/series_piranha.cpp	/^RCP<const Basic> UPSeriesPiranha::as_basic() const$/;"	f	class:SymEngine::UPSeriesPiranha
as_basic	symengine/series_piranha.cpp	/^RCP<const Basic> URatPSeriesPiranha::as_basic() const$/;"	f	class:SymEngine::URatPSeriesPiranha
as_coef_term	symengine/add.cpp	/^void Add::as_coef_term(const RCP<const Basic> &self,$/;"	f	class:SymEngine::Add
as_complex_double	symengine/complex_double.h	/^    inline std::complex<double> as_complex_double() const$/;"	f	class:SymEngine::ComplexDouble
as_dict	symengine/series_flint.cpp	/^umap_int_basic URatPSeriesFlint::as_dict() const$/;"	f	class:SymEngine::URatPSeriesFlint
as_dict	symengine/series_generic.cpp	/^umap_int_basic UnivariateSeries::as_dict() const$/;"	f	class:SymEngine::UnivariateSeries
as_dict	symengine/series_piranha.cpp	/^umap_int_basic UPSeriesPiranha::as_dict() const$/;"	f	class:SymEngine::UPSeriesPiranha
as_dict	symengine/series_piranha.cpp	/^umap_int_basic URatPSeriesPiranha::as_dict() const$/;"	f	class:SymEngine::URatPSeriesPiranha
as_double	symengine/real_double.h	/^    inline double as_double() const$/;"	f	class:SymEngine::RealDouble
as_dummy	symengine/symbol.cpp	/^RCP<const Symbol> Symbol::as_dummy() const$/;"	f	class:SymEngine::Symbol
as_int	symengine/integer.cpp	/^signed long int Integer::as_int() const$/;"	f	class:SymEngine::Integer
as_integer_class	symengine/integer.h	/^    inline const integer_class &as_integer_class() const$/;"	f	class:SymEngine::Integer
as_mpc	symengine/complex_mpc.h	/^    inline const mpc_class &as_mpc() const$/;"	f	class:SymEngine::ComplexMPC
as_mpfr	symengine/real_mpfr.h	/^    inline const mpfr_class &as_mpfr() const$/;"	f	class:SymEngine::RealMPFR
as_numer_denom	symengine/numer_denom.cpp	/^void as_numer_denom(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
as_rational_class	symengine/rational.h	/^    inline const rational_class &as_rational_class() const$/;"	f	class:SymEngine::Rational
as_real_imag	symengine/as_real_imag.cpp	/^void as_real_imag(const RCP<const Basic> &x, const Ptr<RCP<const Basic>> &real,$/;"	f	namespace:SymEngine
as_symbolic	symengine/polys/msymenginepoly.cpp	/^RCP<const Basic> MExprPoly::as_symbolic() const$/;"	f	class:SymEngine::MExprPoly
as_symbolic	symengine/polys/msymenginepoly.cpp	/^RCP<const Basic> MIntPoly::as_symbolic() const$/;"	f	class:SymEngine::MIntPoly
as_symbolic	symengine/polys/upolybase.h	/^    RCP<const Basic> as_symbolic() const$/;"	f	class:SymEngine::UExprPolyBase
as_symbolic	symengine/polys/upolybase.h	/^    RCP<const Basic> as_symbolic() const$/;"	f	class:SymEngine::UIntPolyBase
as_symbolic	symengine/polys/upolybase.h	/^    RCP<const Basic> as_symbolic() const$/;"	f	class:SymEngine::URatPolyBase
as_two_terms	symengine/add.cpp	/^void Add::as_two_terms(const Ptr<RCP<const Basic>> &a,$/;"	f	class:SymEngine::Add
as_two_terms	symengine/mul.cpp	/^void Mul::as_two_terms(const Ptr<RCP<const Basic>> &a,$/;"	f	class:SymEngine::Mul
as_uint	symengine/integer.cpp	/^unsigned long int Integer::as_uint() const$/;"	f	class:SymEngine::Integer
as_vec_basic	symengine/dense_matrix.cpp	/^vec_basic DenseMatrix::as_vec_basic() const$/;"	f	class:SymEngine::DenseMatrix
as_vectors	symengine/sparse_matrix.cpp	/^CSRMatrix::as_vectors() const$/;"	f	class:SymEngine::CSRMatrix
ascii_art	symengine/printers/strprinter.cpp	/^std::string ascii_art()$/;"	f	namespace:SymEngine
ascii_art_str	symengine/cwrapper.cpp	/^char *ascii_art_str()$/;"	f
asec	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> asec(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
asec	symengine/functions.cpp	/^RCP<const Basic> asec(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
asech	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> asech(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
asech	symengine/functions.cpp	/^RCP<const Basic> asech(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
asin	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> asin(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
asin	symengine/functions.cpp	/^RCP<const Basic> asin(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
asin	symengine/series.h	/^    static inline Coeff asin(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
asin	symengine/series_generic.cpp	/^Expression UnivariateSeries::asin(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
asin	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::asin(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
asin_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper asin_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
asinh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> asinh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
asinh	symengine/functions.cpp	/^RCP<const Basic> asinh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
asinh	symengine/series.h	/^    static inline Coeff asinh(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
asinh	symengine/series_generic.cpp	/^Expression UnivariateSeries::asinh(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
asinh	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::asinh(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
asinh_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper asinh_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
assert_not_null	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^const Ptr<T>& Ptr<T>::assert_not_null() const$/;"	f	class:Teuchos::Ptr
assert_not_null	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const RCP<T>& RCP<T>::assert_not_null() const$/;"	f	class:Teuchos::RCP
assert_valid_ptr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const RCP<T>& RCP<T>::assert_valid_ptr() const$/;"	f	class:Teuchos::RCP
assert_valid_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void assert_valid_ptr(const RCPType& rcp_obj) const$/;"	f	class:Teuchos::RCPNodeHandle
assign	symengine/parser/parserbase.h	/^inline SType &Assign<false, SType>::assign(SType *lhs, SType const &tp)$/;"	f	class:SymEngine::Meta__::Assign
assign	symengine/parser/parserbase.h	/^inline SType &Assign<false, Tp_>::assign(SType *lhs, Tp_ const &tp)$/;"	f	class:SymEngine::Meta__::Assign
assign	symengine/parser/parserbase.h	/^inline SType &Assign<true, Tp_>::assign(SType *lhs, Tp_ &&tp)$/;"	f	class:SymEngine::Meta__::Assign
atan	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> atan(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
atan	symengine/functions.cpp	/^RCP<const Basic> atan(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
atan	symengine/series.h	/^    static inline Coeff atan(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
atan	symengine/series_generic.cpp	/^Expression UnivariateSeries::atan(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
atan	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::atan(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
atan2	symengine/functions.cpp	/^RCP<const Basic> atan2(const RCP<const Basic> &num, const RCP<const Basic> &den)$/;"	f	namespace:SymEngine
atan_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper atan_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
atanh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> atanh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
atanh	symengine/functions.cpp	/^RCP<const Basic> atanh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
atanh	symengine/series.h	/^    static inline Coeff atanh(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
atanh	symengine/series_generic.cpp	/^Expression UnivariateSeries::atanh(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
atanh	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::atanh(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
atanh_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper atanh_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
atoms	symengine/visitor.h	/^inline set_basic atoms(const Basic &b)$/;"	f	namespace:SymEngine
available	symengine/parser/scannerbase.h	/^inline bool constexpr ScannerBase::available(size_t value)$/;"	f	class:SymEngine::ScannerBase
b_	symengine/functions.h	/^    RCP<const Basic> b_; \/\/! `b` in `TwoArgBasic(a, b)`$/;"	m	class:SymEngine::TwoArgBasic
b_	symengine/logic.h	/^    bool b_;$/;"	m	class:SymEngine::BooleanAtom
back_substitution	symengine/dense_matrix.cpp	/^void back_substitution(const DenseMatrix &U, const DenseMatrix &b,$/;"	f	namespace:SymEngine
bad_any_cast	symengine/utilities/teuchos/Teuchos_any.hpp	/^  bad_any_cast( const std::string msg ) : std::runtime_error(msg) {}$/;"	f	class:Teuchos::bad_any_cast
bad_any_cast	symengine/utilities/teuchos/Teuchos_any.hpp	/^class bad_any_cast : public std::runtime_error$/;"	c	namespace:Teuchos
bad_stream	benchmarks/nonius.h++	/^    struct bad_stream : virtual std::exception {$/;"	s	namespace:nonius
base_	symengine/pow.h	/^    RCP<const Basic> base_, exp_; \/\/! base**exp$/;"	m	class:SymEngine::Pow
base_	symengine/sets.h	/^    RCP<const Set> base_; \/\/ base set for all symbols$/;"	m	class:SymEngine::ImageSet
base_obj_map_key_void_ptr_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const void *base_obj_map_key_void_ptr_;$/;"	m	class:Teuchos::RCPNodeTmpl
basic	symengine/cwrapper.h	/^typedef basic_struct basic[1];$/;"	t
basic	symengine/parser/parserbase.h	/^    basic,$/;"	m	class:SymEngine::Tag__
basic_add	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_add(basic s, const basic a, const basic b)$/;"	f
basic_as_numer_denom	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_as_numer_denom(basic numer, basic denom,$/;"	f
basic_assign	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_assign(basic a, const basic b)$/;"	f
basic_atan2	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_atan2(basic s, const basic a, const basic b)$/;"	f
basic_coeff	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_coeff(basic c, const basic b, const basic x,$/;"	f
basic_const_Catalan	symengine/cwrapper.cpp	/^void basic_const_Catalan(basic s)$/;"	f
basic_const_E	symengine/cwrapper.cpp	/^void basic_const_E(basic s)$/;"	f
basic_const_EulerGamma	symengine/cwrapper.cpp	/^void basic_const_EulerGamma(basic s)$/;"	f
basic_const_GoldenRatio	symengine/cwrapper.cpp	/^void basic_const_GoldenRatio(basic s)$/;"	f
basic_const_I	symengine/cwrapper.cpp	/^void basic_const_I(basic s)$/;"	f
basic_const_complex_infinity	symengine/cwrapper.cpp	/^void basic_const_complex_infinity(basic s)$/;"	f
basic_const_infinity	symengine/cwrapper.cpp	/^void basic_const_infinity(basic s)$/;"	f
basic_const_minus_one	symengine/cwrapper.cpp	/^void basic_const_minus_one(basic s)$/;"	f
basic_const_nan	symengine/cwrapper.cpp	/^void basic_const_nan(basic s)$/;"	f
basic_const_neginfinity	symengine/cwrapper.cpp	/^void basic_const_neginfinity(basic s)$/;"	f
basic_const_one	symengine/cwrapper.cpp	/^void basic_const_one(basic s)$/;"	f
basic_const_pi	symengine/cwrapper.cpp	/^void basic_const_pi(basic s)$/;"	f
basic_const_set	symengine/cwrapper.cpp	/^void basic_const_set(basic s, const char *c)$/;"	f
basic_const_zero	symengine/cwrapper.cpp	/^void basic_const_zero(basic s)$/;"	f
basic_cse	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_cse(CVecBasic *replacement_syms,$/;"	f
basic_diff	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_diff(basic s, const basic expr, basic const symbol)$/;"	f
basic_div	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_div(basic s, const basic a, const basic b)$/;"	f
basic_eq	symengine/cwrapper.cpp	/^int basic_eq(const basic a, const basic b)$/;"	f
basic_evalf	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_evalf(basic s, const basic b, unsigned long bits,$/;"	f
basic_free_heap	symengine/cwrapper.cpp	/^void basic_free_heap(basic_struct *s)$/;"	f
basic_free_stack	symengine/cwrapper.cpp	/^void basic_free_stack(basic s)$/;"	f
basic_free_symbols	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_free_symbols(const basic self, CSetBasic *symbols)$/;"	f
basic_function_symbols	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_function_symbols(CSetBasic *symbols,$/;"	f
basic_get_args	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_get_args(const basic self, CVecBasic *args)$/;"	f
basic_get_class_from_id	symengine/cwrapper.cpp	/^char *basic_get_class_from_id(TypeID id)$/;"	f
basic_get_class_id	symengine/cwrapper.cpp	/^TypeID basic_get_class_id(const char *c)$/;"	f
basic_get_type	symengine/cwrapper.cpp	/^TypeID basic_get_type(const basic s)$/;"	f
basic_hash	symengine/cwrapper.cpp	/^size_t basic_hash(const basic self)$/;"	f
basic_max	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_max(basic s, CVecBasic *d)$/;"	f
basic_min	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_min(basic s, CVecBasic *d)$/;"	f
basic_mul	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_mul(basic s, const basic a, const basic b)$/;"	f
basic_neq	symengine/cwrapper.cpp	/^int basic_neq(const basic a, const basic b)$/;"	f
basic_new_heap	symengine/cwrapper.cpp	/^basic_struct *basic_new_heap()$/;"	f
basic_new_stack	symengine/cwrapper.cpp	/^void basic_new_stack(basic s)$/;"	f
basic_parse	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_parse(basic b, const char *str)$/;"	f
basic_parse2	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_parse2(basic b, const char *str, int convert_xor)$/;"	f
basic_pow	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_pow(basic s, const basic a, const basic b)$/;"	f
basic_solve_poly	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_solve_poly(CSetBasic *r, const basic f,$/;"	f
basic_str	symengine/cwrapper.cpp	/^char *basic_str(const basic s)$/;"	f
basic_str_free	symengine/cwrapper.cpp	/^void basic_str_free(char *s)$/;"	f
basic_str_julia	symengine/cwrapper.cpp	/^char *basic_str_julia(const basic s)$/;"	f
basic_struct	symengine/cwrapper.h	/^typedef struct CRCPBasic basic_struct;$/;"	t	typeref:struct:CRCPBasic
basic_struct	symengine/cwrapper.h	/^typedef struct CRCPBasic_C basic_struct;$/;"	t	typeref:struct:CRCPBasic_C
basic_sub	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_sub(basic s, const basic a, const basic b)$/;"	f
basic_subs	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_subs(basic s, const basic e,$/;"	f
basic_subs2	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE basic_subs2(basic s, const basic e, const basic a,$/;"	f
basic_vec	symengine/parser/parserbase.h	/^    basic_vec,$/;"	m	class:SymEngine::Tag__
begin	symengine/fields.h	/^    iterator begin() const$/;"	f	class:SymEngine::GaloisField
begin	symengine/parser/scannerbase.h	/^inline void ScannerBase::begin(StartCondition__ startCondition)$/;"	f	class:SymEngine::ScannerBase
begin	symengine/polys/uintpoly_flint.h	/^    iterator begin() const$/;"	f	class:SymEngine::UFlintPoly
begin	symengine/polys/uintpoly_piranha.h	/^    iterator begin() const$/;"	f	class:SymEngine::UPiranhaPoly
begin	symengine/polys/usymenginepoly.h	/^    iterator begin() const$/;"	f	class:SymEngine::USymEnginePoly
begin	symengine/utilities/teuchos/Teuchos_map.hpp	/^    const_iterator begin() const { return list_.begin(); }$/;"	f	class:Teuchos::std::map
begin	symengine/utilities/teuchos/Teuchos_map.hpp	/^    iterator begin() { return list_.begin(); }$/;"	f	class:Teuchos::std::map
bench_mertens	benchmarks/ntheorybench.cpp	/^void bench_mertens()$/;"	f
bench_mobius	benchmarks/ntheorybench.cpp	/^void bench_mobius()$/;"	f
bench_mp_sqrt	benchmarks/ntheorybench.cpp	/^void bench_mp_sqrt()$/;"	f
bench_prime_factor_multiplicities	benchmarks/ntheorybench.cpp	/^void bench_prime_factor_multiplicities()$/;"	f
benchmark	benchmarks/nonius.h++	/^        benchmark(std::string name, detail::benchmark_function fun)$/;"	f	struct:nonius::benchmark
benchmark	benchmarks/nonius.h++	/^    struct benchmark {$/;"	s	namespace:nonius
benchmark_complete	benchmarks/nonius.h++	/^        void benchmark_complete() {$/;"	f	struct:nonius::reporter
benchmark_failure	benchmarks/nonius.h++	/^        void benchmark_failure(std::exception_ptr error) {$/;"	f	struct:nonius::reporter
benchmark_function	benchmarks/nonius.h++	/^            benchmark_function(Fun&& fun)$/;"	f	struct:nonius::detail::benchmark_function
benchmark_function	benchmarks/nonius.h++	/^            benchmark_function(benchmark_function const& that)$/;"	f	struct:nonius::detail::benchmark_function
benchmark_function	benchmarks/nonius.h++	/^            benchmark_function(benchmark_function&& that)$/;"	f	struct:nonius::detail::benchmark_function
benchmark_function	benchmarks/nonius.h++	/^        struct benchmark_function {$/;"	s	namespace:nonius::detail
benchmark_registrar	benchmarks/nonius.h++	/^        benchmark_registrar(benchmark_registry& registry, std::string name, Fun&& registrant) {$/;"	f	struct:nonius::benchmark_registrar
benchmark_registrar	benchmarks/nonius.h++	/^    struct benchmark_registrar {$/;"	s	namespace:nonius
benchmark_start	benchmarks/nonius.h++	/^        void benchmark_start(std::string const& name) {$/;"	f	struct:nonius::reporter
benchmark_user_error	benchmarks/nonius.h++	/^    struct benchmark_user_error : virtual std::exception {$/;"	s	namespace:nonius
berkowitz	symengine/dense_matrix.cpp	/^void berkowitz(const DenseMatrix &A, std::vector<DenseMatrix> &polys)$/;"	f	namespace:SymEngine
bernoulli	symengine/ntheory.cpp	/^RCP<const Number> bernoulli(unsigned long n)$/;"	f	namespace:SymEngine
beta	symengine/functions.cpp	/^RCP<const Basic> beta(const RCP<const Basic> &x, const RCP<const Basic> &y)$/;"	f	namespace:SymEngine
bfd_vma	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^typedef long long unsigned bfd_vma;$/;"	t	file:
bind	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  inline void bind()$/;"	f	class:Teuchos::RCPNodeHandle
binomial	symengine/ntheory.cpp	/^RCP<const Integer> binomial(const Integer &n, unsigned long k)$/;"	f	namespace:SymEngine
bit_length	symengine/polys/uintpoly.h	/^unsigned int bit_length(T t)$/;"	f	namespace:SymEngine
bits	symengine/eval.cpp	/^    unsigned long bits;$/;"	m	class:SymEngine::EvalVisitor	file:
bol	symengine/parser/scannerbase.h	/^        FinalData bol;$/;"	m	struct:SymEngine::ScannerBase::Final
boolFalse	symengine/logic.cpp	/^RCP<const BooleanAtom> boolFalse = make_rcp<BooleanAtom>(false);$/;"	m	namespace:SymEngine	file:
boolTrue	symengine/logic.cpp	/^RCP<const BooleanAtom> boolTrue = make_rcp<BooleanAtom>(true);$/;"	m	namespace:SymEngine	file:
boolean	symengine/logic.h	/^inline RCP<const BooleanAtom> boolean(bool b)$/;"	f	namespace:SymEngine
boost	symengine/mp_class.h	/^namespace boost$/;"	n
bootstrap	benchmarks/nonius.h++	/^        estimate<double> bootstrap(double confidence_level, Iterator first, Iterator last, sample const& resample, Estimator&& estimator) {$/;"	f	namespace:nonius::detail
bootstrap_analysis	benchmarks/nonius.h++	/^        struct bootstrap_analysis {$/;"	s	namespace:nonius::detail
breathe_default_project	doc/conf.py	/^breathe_default_project = "symengine"$/;"	v
breathe_projects	doc/conf.py	/^breathe_projects = {$/;"	v
breathe_projects_source	doc/conf.py	/^breathe_projects_source = {$/;"	v
builder	symengine/llvm_double.h	/^    IRBuilder *builder;$/;"	m	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const ComplexBase &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Function &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Infty &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/as_real_imag.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::RealImagVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Derivative &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const FunctionSymbol &x)$/;"	f	class:SymEngine::RebuildVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/cse.cpp	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::OptsCSEVisitor
bvisit	symengine/eval.cpp	/^    void bvisit(const ComplexBase &x)$/;"	f	class:SymEngine::EvalVisitor
bvisit	symengine/eval.cpp	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::EvalVisitor
bvisit	symengine/eval.cpp	/^    void bvisit(const FunctionWrapper &x)$/;"	f	class:SymEngine::EvalVisitor
bvisit	symengine/eval.cpp	/^    void bvisit(const Number &x)$/;"	f	class:SymEngine::EvalVisitor
bvisit	symengine/eval.cpp	/^    void bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::EvalVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACosh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACot &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACoth &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACsc &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ACsch &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ASec &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ASech &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ATan2 &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Basic &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Complex &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ComplexDouble &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const ComplexMPC &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Csch &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Derivative &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Dirichlet_eta &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const FunctionWrapper &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const KroneckerDelta &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const LambertW &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const LeviCivita &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const LogGamma &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const LowerGamma &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Max &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Min &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const RealMPFR &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Sech &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Symbol &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const UIntPoly &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const UpperGamma &)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_arb.cpp	/^    void bvisit(const Zeta &x)$/;"	f	class:SymEngine::EvalArbVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACosh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACot &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACoth &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACsc &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ACsch &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ASec &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ASech &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ATan2 &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Basic &)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Complex &x)$/;"	f	class:SymEngine::EvalComplexDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::EvalComplexDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::EvalComplexDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Equality &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Erf &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Erfc &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const FunctionWrapper &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const LessThan &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const LogGamma &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Max &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Min &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Symbol &)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::EvalDoubleVisitor
bvisit	symengine/eval_double.cpp	/^    void bvisit(const Unequality &x)$/;"	f	class:SymEngine::EvalRealDoubleVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACosh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACot &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACoth &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACsc &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ACsch &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ASec &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ASech &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Basic &)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Complex &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const FunctionWrapper &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpc.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::EvalMPCVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACosh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACot &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACoth &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACsc &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ACsch &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ASec &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ASech &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ATan2 &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Basic &)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Beta &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Equality &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Erf &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Erfc &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const FunctionWrapper &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const LessThan &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const LogGamma &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Max &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Min &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/eval_mpfr.cpp	/^    void bvisit(const Unequality &x)$/;"	f	class:SymEngine::EvalMPFRVisitor
bvisit	symengine/expand.cpp	/^    void bvisit(const Add &self)$/;"	f	class:SymEngine::ExpandVisitor
bvisit	symengine/expand.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::ExpandVisitor
bvisit	symengine/expand.cpp	/^    void bvisit(const Mul &self)$/;"	f	class:SymEngine::ExpandVisitor
bvisit	symengine/expand.cpp	/^    void bvisit(const Number &x)$/;"	f	class:SymEngine::ExpandVisitor
bvisit	symengine/expand.cpp	/^    void bvisit(const Pow &self)$/;"	f	class:SymEngine::ExpandVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACosh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACot &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACoth &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACsc &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ACsch &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ASec &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ASech &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ATan2 &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Abs &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const And &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Basic &)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const BooleanAtom &ba)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Complex &x)$/;"	f	class:SymEngine::LambdaComplexDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::LambdaComplexDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::LambdaComplexDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Contains &cts)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Equality &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Erf &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Erfc &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Infty &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const LessThan &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const LogGamma &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Max &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Min &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Not &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Or &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Piecewise &pw)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::LambdaDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Unequality &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/lambda_double.h	/^    void bvisit(const Xor &x)$/;"	f	class:SymEngine::LambdaRealDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Add &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Basic &)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const BooleanAtom &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Constant &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Contains &cts)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Cos &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Infty &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Integer &x, bool as_int32)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Log &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Max &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Min &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Mul &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Not &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Piecewise &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Pow &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Rational &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const RealDouble &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Sin &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::bvisit(const Symbol &x)$/;"	f	class:SymEngine::LLVMDoubleVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Complex &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/numer_denom.cpp	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::NumerDenomVisitor
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::PolyGeneratorVisitor
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::PolyGeneratorVisitorPow
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::PolyGeneratorVisitor
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::PolyGeneratorVisitorPow
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::PolyGeneratorVisitor
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::PolyGeneratorVisitorPow
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Number &x)$/;"	f	class:SymEngine::PolyGeneratorVisitor
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Number &x)$/;"	f	class:SymEngine::PolyGeneratorVisitorPow
bvisit	symengine/polys/basic_conversions.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::PolyGeneratorVisitor
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::BasicToMPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::BasicToMPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::BasicToMPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::BasicToMPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Poly &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::BasicToMPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::BasicToUPolyBase
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::BasicToMExprPoly
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::BasicToMIntPoly
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::BasicToUExprPoly
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::BasicToUIntPoly
bvisit	symengine/polys/basic_conversions.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::BasicToURatPoly
bvisit	symengine/printers/codegen.cpp	/^void C89CodePrinter::bvisit(const Infty &x)$/;"	f	class:SymEngine::C89CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void C99CodePrinter::bvisit(const Gamma &x)$/;"	f	class:SymEngine::C99CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void C99CodePrinter::bvisit(const Infty &x)$/;"	f	class:SymEngine::C99CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void C99CodePrinter::bvisit(const LogGamma &x)$/;"	f	class:SymEngine::C99CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Abs &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Basic &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Ceiling &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Complex &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Contains &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Derivative &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const EmptySet &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Equality &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const FiniteSet &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const GaloisField &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Interval &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const LessThan &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Max &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Min &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const NaN &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Piecewise &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Rational &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Subs &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const Unequality &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const UnivariateSeries &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void CodePrinter::bvisit(const UniversalSet &x)$/;"	f	class:SymEngine::CodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Abs &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Cos &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Max &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Min &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/codegen.cpp	/^void JSCodePrinter::bvisit(const Sin &x)$/;"	f	class:SymEngine::JSCodePrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Abs &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const And &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const BooleanAtom &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Ceiling &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Complement &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Complex &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const ComplexBase &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const ConditionSet &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Contains &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Derivative &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const EmptySet &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Equality &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const FiniteSet &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Floor &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Function &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const ImageSet &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Infty &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Interval &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const LessThan &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const NaN &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Not &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Or &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Piecewise &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Rational &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Subs &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Symbol &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Unequality &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Union &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/latex.cpp	/^void LatexPrinter::bvisit(const Xor &x)$/;"	f	class:SymEngine::LatexPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Add &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const And &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Basic &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const BooleanAtom &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Complement &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const ComplexBase &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const ConditionSet &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Contains &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Derivative &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const EmptySet &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Equality &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const FiniteSet &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Function &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const FunctionSymbol &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const ImageSet &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Integer &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Interval &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const LessThan &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Mul &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Not &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Or &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Piecewise &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Pow &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Rational &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const RealDouble &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Symbol &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Unequality &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Union &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/mathml.cpp	/^void MathMLPrinter::bvisit(const Xor &x)$/;"	f	class:SymEngine::MathMLPrinter
bvisit	symengine/printers/strprinter.cpp	/^void JuliaStrPrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::JuliaStrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void JuliaStrPrinter::bvisit(const Infty &x)$/;"	f	class:SymEngine::JuliaStrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void JuliaStrPrinter::bvisit(const NaN &x)$/;"	f	class:SymEngine::JuliaStrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Add &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Basic &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Complex &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const GaloisField &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Integer &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Mul &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Pow &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Rational &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const RealDouble &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const Relational &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const UPSeriesPiranha &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void Precedence::bvisit(const URatPSeriesPiranha &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Add &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const And &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Basic &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const BooleanAtom &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Complement &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Complex &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const ConditionSet &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Constant &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Contains &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Derivative &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const EmptySet &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Equality &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const FiniteSet &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Function &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const FunctionSymbol &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const GaloisField &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const ImageSet &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Infty &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Integer &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Interval &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const LessThan &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const MExprPoly &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const MIntPoly &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Mul &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const NaN &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Not &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const NumberWrapper &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Or &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Piecewise &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Pow &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Rational &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const RealDouble &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const StrictLessThan &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Subs &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Symbol &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UExprPoly &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UIntPoly &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UIntPolyFlint &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UIntPolyPiranha &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UPSeriesPiranha &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const URatPSeriesPiranha &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const URatPoly &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const URatPolyFlint &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const URatPolyPiranha &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Unequality &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Union &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UnivariateSeries &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const UniversalSet &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.cpp	/^void StrPrinter::bvisit(const Xor &x)$/;"	f	class:SymEngine::StrPrinter
bvisit	symengine/printers/strprinter.h	/^    void bvisit(const MSymEnginePoly<Container, Poly> &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/printers/strprinter.h	/^    void bvisit(const UPolyBase<Container, Poly> &x)$/;"	f	class:SymEngine::Precedence
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Coth &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Csch &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Sech &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/rewrite.cpp	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::RewriteAsExp
bvisit	symengine/series_visitor.h	/^    void bvisit(const ACos &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ASin &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ASinh &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ATan &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ATanh &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Complex &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ComplexDouble &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const ComplexMPC &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Constant &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Cos &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Cosh &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Cot &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Csc &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Function &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Gamma &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Integer &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const LambertW &x)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const LambertW &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Log &f)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Log &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Pow &pow)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Rational &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const RealDouble &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const RealMPFR &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Sec &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Series &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Sinh &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const T &f)$/;"	f	class:SymEngine::NeedsSymbolicExpansionVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Tan &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/series_visitor.h	/^    void bvisit(const Tanh &x)$/;"	f	class:SymEngine::SeriesVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::InvertComplexVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::InvertComplexVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::InvertComplexVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::InvertComplexVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
bvisit	symengine/solve.cpp	/^    void bvisit(const T &x)$/;"	f	class:SymEngine::IsALinearArgTrigVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const And &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Contains &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Derivative &x)$/;"	f	class:SymEngine::MSubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Derivative &x)$/;"	f	class:SymEngine::SSubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Derivative &x)$/;"	f	class:SymEngine::SubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Derivative &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const FiniteSet &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const FunctionSymbol &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const ImageSet &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const MultiArgFunction &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const OneArgFunction &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::SubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::MSubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::SSubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::SubsVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const TwoArgBasic<T> &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/subs.h	/^    void bvisit(const Union &x)$/;"	f	class:SymEngine::XReplaceVisitor
bvisit	symengine/tests/printing/test_printing.cpp	/^    void bvisit(const Sin &x)$/;"	f	class:SymEngine::MyStrPrinter
bvisit	symengine/visitor.cpp	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::FreeSymbolsVisitor
bvisit	symengine/visitor.cpp	/^    void bvisit(const Subs &x)$/;"	f	class:SymEngine::FreeSymbolsVisitor
bvisit	symengine/visitor.cpp	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::FreeSymbolsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Add &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Basic &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const ComplexBase &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Constant &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Mul &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Number &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Pow &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void CountOpsVisitor::bvisit(const Symbol &x)$/;"	f	class:SymEngine::CountOpsVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const Add &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const Basic &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const Mul &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const MultiArgFunction &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const OneArgFunction &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.cpp	/^void TransformVisitor::bvisit(const Pow &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Add &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::AtomsVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Basic &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Basic &x){};$/;"	f	class:SymEngine::HasSymbolVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const FunctionSymbol &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Mul &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Pow &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::CoeffVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const Symbol &x)$/;"	f	class:SymEngine::HasSymbolVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const T &x)$/;"	f	class:SymEngine::AtomsVisitor
bvisit	symengine/visitor.h	/^    void bvisit(const TwoArgBasic<T> &x)$/;"	f	class:SymEngine::TransformVisitor
bvisit_upoly	symengine/printers/strprinter.h	/^    void bvisit_upoly(const Poly &x)$/;"	f	class:SymEngine::Precedence
c89code	symengine/printers/codegen.cpp	/^std::string inline c89code(const Basic &x)$/;"	f	class:SymEngine::std
c99code	symengine/printers/codegen.cpp	/^std::string inline c99code(const Basic &x)$/;"	f	class:SymEngine::std
call	benchmarks/nonius.h++	/^                void call(chronometer meter, std::false_type) const {$/;"	f	struct:nonius::detail::benchmark_function::model
call	benchmarks/nonius.h++	/^                void call(chronometer meter, std::true_type) const {$/;"	f	struct:nonius::detail::benchmark_function::model
call	symengine/lambda_double.h	/^    T call(const std::vector<T> &vec)$/;"	f	class:SymEngine::LambdaDoubleVisitor
call	symengine/lambda_double.h	/^    void call(T *outs, const T *inps)$/;"	f	class:SymEngine::LambdaDoubleVisitor
call	symengine/llvm_double.cpp	/^double LLVMDoubleVisitor::call(const std::vector<double> &vec)$/;"	f	class:SymEngine::LLVMDoubleVisitor
call	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::call(double *outs, const double *inps)$/;"	f	class:SymEngine::LLVMDoubleVisitor
canonicalise	symengine/flint_wrapper.h	/^    void canonicalise()$/;"	f	class:SymEngine::fmpq_wrapper
canonicalize	symengine/mp_class.h	/^inline void canonicalize(rational_class &i)$/;"	f	namespace:SymEngine
canonicalize	symengine/mp_wrapper.h	/^    void canonicalize()$/;"	f	class:SymEngine::mpq_wrapper
capturedExpression	symengine/utilities/catch/catch.hpp	/^        char const * capturedExpression;$/;"	m	struct:Catch::AssertionInfo
carmichael	symengine/ntheory.cpp	/^RCP<const Integer> carmichael(const RCP<const Integer> &n)$/;"	f	namespace:SymEngine
cbrt	symengine/functions.cpp	/^RCP<const Basic> cbrt(RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
cbrt	symengine/pow.h	/^inline RCP<const Basic> cbrt(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
ccode	symengine/printers/codegen.cpp	/^std::string ccode(const Basic &x)$/;"	f	namespace:SymEngine
ceiling	symengine/functions.cpp	/^RCP<const Basic> ceiling(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
char_poly	symengine/dense_matrix.cpp	/^void char_poly(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
cholesky	symengine/dense_matrix.cpp	/^void cholesky(const DenseMatrix &A, DenseMatrix &L)$/;"	f	namespace:SymEngine
chronometer	benchmarks/nonius.h++	/^        chronometer(detail::chronometer_concept& meter, int k)$/;"	f	struct:nonius::chronometer
chronometer	benchmarks/nonius.h++	/^    struct chronometer {$/;"	s	namespace:nonius
chronometer_concept	benchmarks/nonius.h++	/^        struct chronometer_concept {$/;"	s	namespace:nonius::detail
classify_outliers	benchmarks/nonius.h++	/^        outlier_classification classify_outliers(Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
clear	symengine/ntheory.cpp	/^void Sieve::clear()$/;"	f	class:SymEngine::Sieve
clearin	symengine/parser/parser.cpp	/^void ParserBase::clearin()$/;"	f	class:SymEngine::ParserBase
clock_cost	benchmarks/nonius.h++	/^        environment_estimate<FloatDuration<Clock>> clock_cost;$/;"	m	struct:nonius::environment
clock_cost_estimation_iterations	benchmarks/nonius.h++	/^        const auto clock_cost_estimation_iterations = 10000;$/;"	m	namespace:nonius::detail
clock_cost_estimation_tick_limit	benchmarks/nonius.h++	/^        const auto clock_cost_estimation_tick_limit = 100000;$/;"	m	namespace:nonius::detail
clock_cost_estimation_time	benchmarks/nonius.h++	/^        const auto clock_cost_estimation_time = chrono::milliseconds(10);$/;"	m	namespace:nonius::detail
clock_cost_estimation_time_limit	benchmarks/nonius.h++	/^        const auto clock_cost_estimation_time_limit = chrono::seconds(1);$/;"	m	namespace:nonius::detail
clock_resolution	benchmarks/nonius.h++	/^        environment_estimate<FloatDuration<Clock>> clock_resolution;$/;"	m	struct:nonius::environment
clock_resolution_estimation_time	benchmarks/nonius.h++	/^        const auto clock_resolution_estimation_time = chrono::milliseconds(500);$/;"	m	namespace:nonius::detail
clone	symengine/utilities/teuchos/Teuchos_any.hpp	/^    placeholder * clone() const$/;"	f	class:Teuchos::any::holder
close	symengine/parser/scannerbase.h	/^        void close() \/\/ force closing the stream$/;"	f	class:SymEngine::ScannerBase::Input
close	symengine/sets.cpp	/^RCP<const Set> Interval::close() const$/;"	f	class:SymEngine::Interval
coef_	symengine/add.h	/^    RCP<const Number> coef_; \/\/! The coefficient (e.g. `2` in `2+x+y`)$/;"	m	class:SymEngine::Add
coef_	symengine/mul.h	/^    RCP<const Number> coef_; \/\/! The coefficient (e.g. `2` in `2*x*y`)$/;"	m	class:SymEngine::Mul
coef_dict_add_term	symengine/add.cpp	/^void Add::coef_dict_add_term(const Ptr<RCP<const Number>> &coef,$/;"	f	class:SymEngine::Add
coef_type	symengine/polys/msymenginepoly.h	/^    typedef Value coef_type;$/;"	t	class:SymEngine::UDictWrapper
coef_type	symengine/polys/msymenginepoly.h	/^    typedef typename Container::coef_type coef_type;$/;"	t	class:SymEngine::MSymEnginePoly
coef_type	symengine/polys/uexprpoly.h	/^    typedef Expression coef_type;$/;"	t	class:SymEngine::UExprPoly
coef_type	symengine/polys/upolybase.h	/^    typedef Cf coef_type;$/;"	t	class:SymEngine::UNonExprPoly
coef_type	symengine/polys/upolybase.h	/^    typedef Expression coef_type;$/;"	t	class:SymEngine::UExprPolyBase
coeff	symengine/expand.cpp	/^    RCP<const Number> coeff = zero;$/;"	m	class:SymEngine::ExpandVisitor	file:
coeff	symengine/visitor.cpp	/^RCP<const Basic> coeff(const Basic &b, const Basic &x, const Basic &n)$/;"	f	namespace:SymEngine
coeff_	symengine/visitor.h	/^    RCP<const Basic> coeff_;$/;"	m	class:SymEngine::CoeffVisitor
col_	symengine/dense_matrix.cpp	/^    : m_{l}, row_(row), col_(col)$/;"	f	namespace:SymEngine
col_	symengine/matrix.h	/^    unsigned col_;$/;"	m	class:SymEngine::CSRMatrix
col_	symengine/matrix.h	/^    unsigned col_;$/;"	m	class:SymEngine::DenseMatrix
col_	symengine/sparse_matrix.cpp	/^    : p_{p}, j_{j}, x_{x}, row_(row), col_(col)$/;"	f	namespace:SymEngine
col_	symengine/sparse_matrix.cpp	/^    : p_{std::move(p)}, j_{std::move(j)}, x_{std::move(x)}, row_(row), col_(col)$/;"	f	namespace:SymEngine
col_del	symengine/dense_matrix.cpp	/^void DenseMatrix::col_del(unsigned k)$/;"	f	class:SymEngine::DenseMatrix
col_insert	symengine/dense_matrix.cpp	/^void DenseMatrix::col_insert(const DenseMatrix &B, unsigned pos)$/;"	f	class:SymEngine::DenseMatrix
col_join	symengine/dense_matrix.cpp	/^void DenseMatrix::col_join(const DenseMatrix &B)$/;"	f	class:SymEngine::DenseMatrix
column_exchange_dense	symengine/dense_matrix.cpp	/^void column_exchange_dense(DenseMatrix &A, unsigned i, unsigned j)$/;"	f	namespace:SymEngine
command_line_options	benchmarks/nonius.h++	/^        inline detail::option_set const& command_line_options() {$/;"	f	class:nonius::detail::detail
compare	symengine/add.cpp	/^int Add::compare(const Basic &o) const$/;"	f	class:SymEngine::Add
compare	symengine/complex.cpp	/^int Complex::compare(const Basic &o) const$/;"	f	class:SymEngine::Complex
compare	symengine/complex_double.cpp	/^int ComplexDouble::compare(const Basic &o) const$/;"	f	class:SymEngine::ComplexDouble
compare	symengine/complex_mpc.cpp	/^int ComplexMPC::compare(const Basic &o) const$/;"	f	class:SymEngine::ComplexMPC
compare	symengine/constants.cpp	/^int Constant::compare(const Basic &o) const$/;"	f	class:SymEngine::Constant
compare	symengine/fields.cpp	/^int GaloisField::compare(const Basic &o) const$/;"	f	class:SymEngine::GaloisField
compare	symengine/functions.cpp	/^int Derivative::compare(const Basic &o) const$/;"	f	class:SymEngine::Derivative
compare	symengine/functions.cpp	/^int FunctionSymbol::compare(const Basic &o) const$/;"	f	class:SymEngine::FunctionSymbol
compare	symengine/functions.cpp	/^int Subs::compare(const Basic &o) const$/;"	f	class:SymEngine::Subs
compare	symengine/functions.h	/^    virtual inline int compare(const Basic &o) const$/;"	f	class:SymEngine::MultiArgFunction
compare	symengine/functions.h	/^    virtual inline int compare(const Basic &o) const$/;"	f	class:SymEngine::OneArgFunction
compare	symengine/functions.h	/^    virtual inline int compare(const Basic &o) const$/;"	f	class:SymEngine::TwoArgBasic
compare	symengine/infinity.cpp	/^int Infty::compare(const Basic &o) const$/;"	f	class:SymEngine::Infty
compare	symengine/integer.cpp	/^int Integer::compare(const Basic &o) const$/;"	f	class:SymEngine::Integer
compare	symengine/logic.cpp	/^int And::compare(const Basic &o) const$/;"	f	class:SymEngine::And
compare	symengine/logic.cpp	/^int BooleanAtom::compare(const Basic &o) const$/;"	f	class:SymEngine::BooleanAtom
compare	symengine/logic.cpp	/^int Contains::compare(const Basic &o) const$/;"	f	class:SymEngine::Contains
compare	symengine/logic.cpp	/^int Not::compare(const Basic &o) const$/;"	f	class:SymEngine::Not
compare	symengine/logic.cpp	/^int Or::compare(const Basic &o) const$/;"	f	class:SymEngine::Or
compare	symengine/logic.cpp	/^int Piecewise::compare(const Basic &o) const$/;"	f	class:SymEngine::Piecewise
compare	symengine/logic.cpp	/^int Xor::compare(const Basic &o) const$/;"	f	class:SymEngine::Xor
compare	symengine/mul.cpp	/^int Mul::compare(const Basic &o) const$/;"	f	class:SymEngine::Mul
compare	symengine/nan.cpp	/^int NaN::compare(const Basic &o) const$/;"	f	class:SymEngine::NaN
compare	symengine/polys/msymenginepoly.h	/^    int compare(const Basic &o) const$/;"	f	class:SymEngine::MSymEnginePoly
compare	symengine/polys/uexprpoly.h	/^    int compare(const UExprDict &other) const$/;"	f	class:SymEngine::UExprDict
compare	symengine/polys/uintpoly.h	/^    int compare(const UIntDict &other) const$/;"	f	class:SymEngine::UIntDict
compare	symengine/polys/uintpoly_flint.h	/^    int compare(const Basic &o) const$/;"	f	class:SymEngine::UFlintPoly
compare	symengine/polys/uintpoly_piranha.h	/^    int compare(const Basic &o) const$/;"	f	class:SymEngine::UPiranhaPoly
compare	symengine/polys/uratpoly.h	/^    int compare(const URatDict &other) const$/;"	f	class:SymEngine::URatDict
compare	symengine/polys/usymenginepoly.h	/^    int compare(const Basic &o) const$/;"	f	class:SymEngine::USymEnginePoly
compare	symengine/pow.cpp	/^int Pow::compare(const Basic &o) const$/;"	f	class:SymEngine::Pow
compare	symengine/rational.cpp	/^int Rational::compare(const Basic &o) const$/;"	f	class:SymEngine::Rational
compare	symengine/real_double.cpp	/^int RealDouble::compare(const Basic &o) const$/;"	f	class:SymEngine::RealDouble
compare	symengine/real_mpfr.cpp	/^int RealMPFR::compare(const Basic &o) const$/;"	f	class:SymEngine::RealMPFR
compare	symengine/series_flint.cpp	/^int URatPSeriesFlint::compare(const Basic &o) const$/;"	f	class:SymEngine::URatPSeriesFlint
compare	symengine/series_generic.cpp	/^int UnivariateSeries::compare(const Basic &other) const$/;"	f	class:SymEngine::UnivariateSeries
compare	symengine/series_piranha.cpp	/^int UPSeriesPiranha::compare(const Basic &o) const$/;"	f	class:SymEngine::UPSeriesPiranha
compare	symengine/series_piranha.cpp	/^int URatPSeriesPiranha::compare(const Basic &o) const$/;"	f	class:SymEngine::URatPSeriesPiranha
compare	symengine/sets.cpp	/^int Complement::compare(const Basic &o) const$/;"	f	class:SymEngine::Complement
compare	symengine/sets.cpp	/^int ConditionSet::compare(const Basic &o) const$/;"	f	class:SymEngine::ConditionSet
compare	symengine/sets.cpp	/^int EmptySet::compare(const Basic &o) const$/;"	f	class:SymEngine::EmptySet
compare	symengine/sets.cpp	/^int FiniteSet::compare(const Basic &o) const$/;"	f	class:SymEngine::FiniteSet
compare	symengine/sets.cpp	/^int ImageSet::compare(const Basic &o) const$/;"	f	class:SymEngine::ImageSet
compare	symengine/sets.cpp	/^int Interval::compare(const Basic &s) const$/;"	f	class:SymEngine::Interval
compare	symengine/sets.cpp	/^int Union::compare(const Basic &o) const$/;"	f	class:SymEngine::Union
compare	symengine/sets.cpp	/^int UniversalSet::compare(const Basic &o) const$/;"	f	class:SymEngine::UniversalSet
compare	symengine/symbol.cpp	/^int Dummy::compare(const Basic &o) const$/;"	f	class:SymEngine::Dummy
compare	symengine/symbol.cpp	/^int Symbol::compare(const Basic &o) const$/;"	f	class:SymEngine::Symbol
compare	symengine/utilities/catch/catch.hpp	/^    bool compare( T1 const& lhs, T2 const& rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( T* lhs, std::nullptr_t ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( int lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( long long lhs, T* rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op, typename T> bool compare( std::nullptr_t, T* rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( int lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned char rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( long long lhs, unsigned long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned char lhs, long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned int lhs, long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, char rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, int rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long long rhs ) {$/;"	f	namespace:Catch::Internal
compare	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> bool compare( unsigned long long lhs, long rhs ) {$/;"	f	namespace:Catch::Internal
complete_invoke	benchmarks/nonius.h++	/^        CompleteType<ResultOf<Fun(Args...)>> complete_invoke(Fun&& fun, Args&&... args) {$/;"	f	namespace:nonius::detail
complete_invoker	benchmarks/nonius.h++	/^        struct complete_invoker {$/;"	s	namespace:nonius::detail
complete_invoker	benchmarks/nonius.h++	/^        struct complete_invoker<void> {$/;"	s	namespace:nonius::detail
complete_type	benchmarks/nonius.h++	/^        struct complete_type { using type = T; };$/;"	s	namespace:nonius::detail
complete_type	benchmarks/nonius.h++	/^        struct complete_type<void> { struct type {}; };$/;"	s	namespace:nonius::detail
complex_base_imaginary_part	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE complex_base_imaginary_part(basic s, const basic com)$/;"	f
complex_base_real_part	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE complex_base_real_part(basic s, const basic com)$/;"	f
complex_double	symengine/complex_double.cpp	/^RCP<const ComplexDouble> complex_double(std::complex<double> x)$/;"	f	namespace:SymEngine
complex_double_get	symengine/cwrapper.cpp	/^dcomplex complex_double_get(const basic s)$/;"	f
complex_mpc	symengine/complex_mpc.h	/^inline RCP<const ComplexMPC> complex_mpc(mpc_class x)$/;"	f	namespace:SymEngine
complex_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE complex_set(basic s, const basic re, const basic im)$/;"	f
complex_set_mpq	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE complex_set_mpq(basic s, const mpq_t re, const mpq_t im)$/;"	f
complex_set_rat	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE complex_set_rat(basic s, const basic re, const basic im)$/;"	f
concept	benchmarks/nonius.h++	/^            struct concept {$/;"	s	struct:nonius::detail::benchmark_function
concreteName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string concreteName( const T& t )$/;"	f	class:Teuchos::TypeNameTraits
concreteName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string concreteName(T_ptr) { return name(); }$/;"	f	class:Teuchos::TypeNameTraits
concreteName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string concreteName(const std::complex<T>&)$/;"	f	class:Teuchos::TypeNameTraits
concreteName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string concreteName(const std::string&) { return name(); }$/;"	f	class:Teuchos::TypeNameTraits
concreteName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string concreteName(const std::string&)$/;"	f	class:Teuchos::TypeNameTraits
concreteTypeName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^std::string concreteTypeName( const T &t )$/;"	f	namespace:Teuchos
condition_	symengine/sets.h	/^    RCP<const Boolean> condition_;$/;"	m	class:SymEngine::ConditionSet
conditionset	symengine/sets.cpp	/^RCP<const Set> conditionset(const RCP<const Basic> &sym,$/;"	f	namespace:SymEngine
confidence_interval	benchmarks/nonius.h++	/^        double confidence_interval = 0.95;$/;"	m	struct:nonius::configuration
confidence_interval	benchmarks/nonius.h++	/^        double confidence_interval;$/;"	m	struct:nonius::estimate
confidence_interval	benchmarks/nonius.h++	/^        double confidence_interval;$/;"	m	struct:nonius::junit_reporter
configuration	benchmarks/nonius.h++	/^    struct configuration {$/;"	s	namespace:nonius
configure	benchmarks/nonius.h++	/^        void configure(configuration& cfg) {$/;"	f	struct:nonius::reporter
conjugate	symengine/complex.cpp	/^RCP<const Basic> Complex::conjugate() const$/;"	f	class:SymEngine::Complex
conjugate	symengine/complex_double.cpp	/^RCP<const Basic> ComplexDouble::conjugate() const$/;"	f	class:SymEngine::ComplexDouble
conjugate	symengine/complex_mpc.cpp	/^RCP<const Basic> ComplexMPC::conjugate() const$/;"	f	class:SymEngine::ComplexMPC
conjugate	symengine/functions.cpp	/^RCP<const Basic> conjugate(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
conjugate	symengine/infinity.cpp	/^RCP<const Basic> Infty::conjugate() const$/;"	f	class:SymEngine::Infty
conjugate	symengine/nan.cpp	/^RCP<const Basic> NaN::conjugate() const$/;"	f	class:SymEngine::NaN
conjugate	symengine/number.cpp	/^RCP<const Basic> Number::conjugate() const$/;"	f	class:SymEngine::Number
const	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define const$/;"	d	file:
constOptInArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<const T> constOptInArg( T& arg )$/;"	f	namespace:Teuchos
constPtr	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<const T> constPtr( T& arg )$/;"	f	namespace:Teuchos
const_iterator	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef typename list_t::const_iterator  const_iterator;$/;"	t	class:Teuchos::std::map
constant	symengine/constants.h	/^inline RCP<const Constant> constant(const std::string &name)$/;"	f	namespace:SymEngine
constants	symengine/parser/parser.h	/^    std::map<const std::string, const RCP<const Basic>> constants = {$/;"	m	class:SymEngine::Parser
constants	symengine/parser/parser_old.cpp	/^    std::map<const std::string, const RCP<const Basic>> constants = {$/;"	m	class:SymEngine::ExpressionParser	file:
construct	benchmarks/nonius.h++	/^            void construct(Args&&... args)$/;"	f	struct:nonius::detail::object_storage
container_	symengine/logic.h	/^    set_boolean container_;$/;"	m	class:SymEngine::And
container_	symengine/logic.h	/^    set_boolean container_;$/;"	m	class:SymEngine::Or
container_	symengine/logic.h	/^    vec_boolean container_;$/;"	m	class:SymEngine::Xor
container_	symengine/sets.h	/^    RCP<const Set> container_;$/;"	m	class:SymEngine::Complement
container_	symengine/sets.h	/^    set_basic container_;$/;"	m	class:SymEngine::FiniteSet
container_	symengine/sets.h	/^    set_set container_;$/;"	m	class:SymEngine::Union
container_from_dict	symengine/polys/msymenginepoly.h	/^    static Container container_from_dict(const set_basic &s,$/;"	f	class:SymEngine::MSymEnginePoly
container_from_dict	symengine/polys/uintpoly_flint.h	/^    static Container container_from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UFlintPoly
container_from_dict	symengine/polys/uintpoly_piranha.h	/^    static Container container_from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UPiranhaPoly
container_from_dict	symengine/polys/usymenginepoly.h	/^    static Container container_from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::USymEnginePoly
container_type	symengine/polys/msymenginepoly.h	/^    typedef Container container_type;$/;"	t	class:SymEngine::MSymEnginePoly
container_type	symengine/polys/upolybase.h	/^    typedef Container container_type;$/;"	t	class:SymEngine::UPolyBase
contains	symengine/logic.cpp	/^RCP<const Boolean> contains(const RCP<const Basic> &expr,$/;"	f	namespace:SymEngine
contains	symengine/sets.cpp	/^RCP<const Boolean> Complement::contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::Complement
contains	symengine/sets.cpp	/^RCP<const Boolean> ConditionSet::contains(const RCP<const Basic> &o) const$/;"	f	class:SymEngine::ConditionSet
contains	symengine/sets.cpp	/^RCP<const Boolean> FiniteSet::contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::FiniteSet
contains	symengine/sets.cpp	/^RCP<const Boolean> ImageSet::contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::ImageSet
contains	symengine/sets.cpp	/^RCP<const Boolean> Interval::contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::Interval
contains	symengine/sets.cpp	/^RCP<const Boolean> Union::contains(const RCP<const Basic> &o) const$/;"	f	class:SymEngine::Union
contains	symengine/sets.h	/^    virtual RCP<const Boolean> contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::EmptySet
contains	symengine/sets.h	/^    virtual RCP<const Boolean> contains(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::UniversalSet
content	symengine/utilities/teuchos/Teuchos_any.hpp	/^  placeholder * content;$/;"	m	class:Teuchos::any
continue__	symengine/parser/scanner.cpp	/^void ScannerBase::continue__(int ch)$/;"	f	class:SymEngine::ScannerBase
convert	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::convert(const Basic &x)$/;"	f	class:SymEngine::URatPSeriesFlint
convert	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::convert(const Integer &x)$/;"	f	class:SymEngine::URatPSeriesFlint
convert	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::convert(const Rational &x)$/;"	f	class:SymEngine::URatPSeriesFlint
convert	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::convert(const integer_class &x)$/;"	f	class:SymEngine::URatPSeriesFlint
convert	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::convert(const rational_class &x)$/;"	f	class:SymEngine::URatPSeriesFlint
convert	symengine/series_generic.cpp	/^Expression UnivariateSeries::convert(const Basic &x)$/;"	f	class:SymEngine::UnivariateSeries
convert	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::convert(const Basic &x)$/;"	f	class:SymEngine::UPSeriesPiranha
convert	symengine/series_piranha.cpp	/^piranha::integer URatPSeriesPiranha::convert(const Integer &x)$/;"	f	class:SymEngine::URatPSeriesPiranha
convert	symengine/series_piranha.cpp	/^piranha::rational URatPSeriesPiranha::convert(const Basic &x)$/;"	f	class:SymEngine::URatPSeriesPiranha
convert	symengine/series_piranha.cpp	/^piranha::rational URatPSeriesPiranha::convert(const Rational &x)$/;"	f	class:SymEngine::URatPSeriesPiranha
convert	symengine/series_piranha.cpp	/^piranha::rational URatPSeriesPiranha::convert(const rational_class &x)$/;"	f	class:SymEngine::URatPSeriesPiranha
convert	symengine/utilities/catch/catch.hpp	/^        static std::string convert( T const& ) { return unprintableString; }$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	symengine/utilities/catch/catch.hpp	/^        static std::string convert( T const& _value ) {$/;"	f	struct:Catch::Detail::StringMakerBase
convert	symengine/utilities/catch/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::EnumStringMaker
convert	symengine/utilities/catch/catch.hpp	/^        static std::string convert( T const& v )$/;"	f	struct:Catch::Detail::StringMakerBase
convert	symengine/utilities/catch/catch.hpp	/^    static std::string convert( R C::* p ) {$/;"	f	struct:Catch::StringMaker
convert	symengine/utilities/catch/catch.hpp	/^    static std::string convert( U* p ) {$/;"	f	struct:Catch::StringMaker
convertRCPNodeToString	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^std::string convertRCPNodeToString(const Teuchos::RCPNode* rcp_node)$/;"	f	namespace:__anon20
convertRCPNodeToString	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^std::string convertRCPNodeToString(const Teuchos::RCPNode* rcp_node)$/;"	f	namespace:__anon41
convert_xor_	symengine/parser/parser_old.cpp	/^    bool convert_xor_;$/;"	m	class:SymEngine::ExpressionParser	file:
copyright	doc/conf.py	/^copyright = u'2014, 2014 SymEngine Development Team'$/;"	v
cos	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> cos(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
cos	symengine/functions.cpp	/^RCP<const Basic> cos(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
cos	symengine/series.h	/^    static inline Coeff cos(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
cos	symengine/series_generic.cpp	/^Expression UnivariateSeries::cos(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
cos	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::cos(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
cos_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper cos_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
cosh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> cosh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
cosh	symengine/functions.cpp	/^RCP<const Basic> cosh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
cosh	symengine/series.h	/^    static inline Coeff cosh(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
cosh	symengine/series_generic.cpp	/^Expression UnivariateSeries::cosh(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
cosh	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::cosh(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
cosh_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper cosh_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
cot	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> cot(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
cot	symengine/functions.cpp	/^RCP<const Basic> cot(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
coth	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> coth(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
coth	symengine/functions.cpp	/^RCP<const Basic> coth(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
could_extract_minus	symengine/functions.cpp	/^bool could_extract_minus(const Basic &arg)$/;"	f	namespace:SymEngine
count	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^int RCP<T>::count() const$/;"	f	class:Teuchos::RCP
count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int count( const ERCPStrength strength )$/;"	f	class:Teuchos::RCPNode
count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int count() const$/;"	f	class:Teuchos::RCPNodeHandle
count	symengine/visitor.h	/^    unsigned count = 0;$/;"	m	class:SymEngine::CountOpsVisitor
count_	symengine/symbol.cpp	/^size_t Dummy::count_ = 0;$/;"	m	class:SymEngine::Dummy	file:
count_	symengine/symbol.h	/^    static size_t count_;$/;"	m	class:SymEngine::Dummy
count_	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^int Teuchos::ActiveRCPNodesSetup::count_ = 0;$/;"	m	class:Teuchos::Teuchos::ActiveRCPNodesSetup	file:
count_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int count_[2];$/;"	m	class:Teuchos::RCPNode
count_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  static int count_;$/;"	m	class:Teuchos::ActiveRCPNodesSetup
count_ops	symengine/visitor.cpp	/^unsigned count_ops(const vec_basic &a)$/;"	f	namespace:SymEngine
cpptempl	benchmarks/nonius.h++	/^namespace cpptempl$/;"	n
create	symengine/functions.cpp	/^RCP<const Basic> ACos::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACos
create	symengine/functions.cpp	/^RCP<const Basic> ACosh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACosh
create	symengine/functions.cpp	/^RCP<const Basic> ACot::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACot
create	symengine/functions.cpp	/^RCP<const Basic> ACoth::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACoth
create	symengine/functions.cpp	/^RCP<const Basic> ACsc::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACsc
create	symengine/functions.cpp	/^RCP<const Basic> ACsch::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACsch
create	symengine/functions.cpp	/^RCP<const Basic> ASec::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASec
create	symengine/functions.cpp	/^RCP<const Basic> ASech::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASech
create	symengine/functions.cpp	/^RCP<const Basic> ASin::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASin
create	symengine/functions.cpp	/^RCP<const Basic> ASinh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASinh
create	symengine/functions.cpp	/^RCP<const Basic> ATan2::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::ATan2
create	symengine/functions.cpp	/^RCP<const Basic> ATan::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ATan
create	symengine/functions.cpp	/^RCP<const Basic> ATanh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ATanh
create	symengine/functions.cpp	/^RCP<const Basic> Abs::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Abs
create	symengine/functions.cpp	/^RCP<const Basic> Beta::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::Beta
create	symengine/functions.cpp	/^RCP<const Basic> Ceiling::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Ceiling
create	symengine/functions.cpp	/^RCP<const Basic> Conjugate::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Conjugate
create	symengine/functions.cpp	/^RCP<const Basic> Cos::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cos
create	symengine/functions.cpp	/^RCP<const Basic> Cosh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cosh
create	symengine/functions.cpp	/^RCP<const Basic> Cot::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cot
create	symengine/functions.cpp	/^RCP<const Basic> Coth::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Coth
create	symengine/functions.cpp	/^RCP<const Basic> Csc::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Csc
create	symengine/functions.cpp	/^RCP<const Basic> Csch::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Csch
create	symengine/functions.cpp	/^RCP<const Basic> Dirichlet_eta::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Dirichlet_eta
create	symengine/functions.cpp	/^RCP<const Basic> Erf::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Erf
create	symengine/functions.cpp	/^RCP<const Basic> Erfc::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Erfc
create	symengine/functions.cpp	/^RCP<const Basic> Floor::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Floor
create	symengine/functions.cpp	/^RCP<const Basic> FunctionSymbol::create(const vec_basic &x) const$/;"	f	class:SymEngine::FunctionSymbol
create	symengine/functions.cpp	/^RCP<const Basic> Gamma::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Gamma
create	symengine/functions.cpp	/^RCP<const Basic> KroneckerDelta::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::KroneckerDelta
create	symengine/functions.cpp	/^RCP<const Basic> LambertW::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::LambertW
create	symengine/functions.cpp	/^RCP<const Basic> LeviCivita::create(const vec_basic &a) const$/;"	f	class:SymEngine::LeviCivita
create	symengine/functions.cpp	/^RCP<const Basic> Log::create(const RCP<const Basic> &a) const$/;"	f	class:SymEngine::Log
create	symengine/functions.cpp	/^RCP<const Basic> LogGamma::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::LogGamma
create	symengine/functions.cpp	/^RCP<const Basic> LowerGamma::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::LowerGamma
create	symengine/functions.cpp	/^RCP<const Basic> Max::create(const vec_basic &a) const$/;"	f	class:SymEngine::Max
create	symengine/functions.cpp	/^RCP<const Basic> Min::create(const vec_basic &a) const$/;"	f	class:SymEngine::Min
create	symengine/functions.cpp	/^RCP<const Basic> PolyGamma::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::PolyGamma
create	symengine/functions.cpp	/^RCP<const Basic> Sec::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sec
create	symengine/functions.cpp	/^RCP<const Basic> Sech::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sech
create	symengine/functions.cpp	/^RCP<const Basic> Sign::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sign
create	symengine/functions.cpp	/^RCP<const Basic> Sin::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sin
create	symengine/functions.cpp	/^RCP<const Basic> Sinh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sinh
create	symengine/functions.cpp	/^RCP<const Basic> Tan::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Tan
create	symengine/functions.cpp	/^RCP<const Basic> Tanh::create(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Tanh
create	symengine/functions.cpp	/^RCP<const Basic> UpperGamma::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::UpperGamma
create	symengine/functions.cpp	/^RCP<const Basic> Zeta::create(const RCP<const Basic> &a,$/;"	f	class:SymEngine::Zeta
create	symengine/functions.h	/^    inline RCP<const Basic> create(const vec_basic &b) const$/;"	f	class:SymEngine::OneArgFunction
create	symengine/functions.h	/^    inline RCP<const Basic> create(const vec_basic &b) const$/;"	f	class:SymEngine::TwoArgBasic
create	symengine/functions.h	/^    static RCP<const Derivative> create(const RCP<const Basic> &arg,$/;"	f	class:SymEngine::Derivative
create	symengine/functions.h	/^    static RCP<const Subs> create(const RCP<const Basic> &arg,$/;"	f	class:SymEngine::Subs
create	symengine/logic.cpp	/^RCP<const Basic> And::create(const set_boolean &a) const$/;"	f	class:SymEngine::And
create	symengine/logic.cpp	/^RCP<const Basic> Contains::create(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::Contains
create	symengine/logic.cpp	/^RCP<const Basic> Equality::create(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::Equality
create	symengine/logic.cpp	/^RCP<const Basic> LessThan::create(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::LessThan
create	symengine/logic.cpp	/^RCP<const Basic> StrictLessThan::create(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::StrictLessThan
create	symengine/logic.cpp	/^RCP<const Basic> Unequality::create(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::Unequality
create	symengine/series_generic.h	/^    static RCP<const UnivariateSeries> create(const RCP<const Symbol> &var,$/;"	f	class:SymEngine::UnivariateSeries
create	symengine/sets.cpp	/^RCP<const Set> FiniteSet::create(const set_basic &container) const$/;"	f	class:SymEngine::FiniteSet
create	symengine/sets.cpp	/^RCP<const Set> ImageSet::create(const RCP<const Basic> &sym,$/;"	f	class:SymEngine::ImageSet
create	symengine/sets.cpp	/^RCP<const Set> Union::create(const set_set &in) const$/;"	f	class:SymEngine::Union
create	symengine/tests/basic/test_functions.cpp	/^    RCP<const Basic> create(const vec_basic &v) const$/;"	f	class:MySin
create_default_passes	symengine/llvm_double.cpp	/^std::vector<llvm::Pass *> LLVMDoubleVisitor::create_default_passes(int optlevel)$/;"	f	class:SymEngine::LLVMDoubleVisitor
create_strong	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T> RCP<T>::create_strong() const$/;"	f	class:Teuchos::RCP
create_strong	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle create_strong() const$/;"	f	class:Teuchos::RCPNodeHandle
create_weak	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T> RCP<T>::create_weak() const$/;"	f	class:Teuchos::RCP
create_weak	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle create_weak() const$/;"	f	class:Teuchos::RCPNodeHandle
cross	symengine/dense_matrix.cpp	/^void cross(const DenseMatrix &A, const DenseMatrix &B, DenseMatrix &C)$/;"	f	namespace:SymEngine
crt	symengine/ntheory.cpp	/^bool crt(const Ptr<RCP<const Integer>> &R,$/;"	f	namespace:SymEngine
csc	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> csc(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
csc	symengine/functions.cpp	/^RCP<const Basic> csc(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
csch	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> csch(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
csch	symengine/functions.cpp	/^RCP<const Basic> csch(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
cse	symengine/cse.cpp	/^void cse(vec_pair &replacements, vec_basic &reduced_exprs,$/;"	f	namespace:SymEngine
cse_intermediate_fns	symengine/lambda_double.h	/^    std::vector<fn> cse_intermediate_fns;$/;"	m	class:SymEngine::LambdaDoubleVisitor
cse_intermediate_fns_map	symengine/lambda_double.h	/^        cse_intermediate_fns_map;$/;"	m	class:SymEngine::LambdaDoubleVisitor
cse_intermediate_results	symengine/lambda_double.h	/^    std::vector<T> cse_intermediate_results;$/;"	m	class:SymEngine::LambdaDoubleVisitor
csr_binop_csr_canonical	symengine/sparse_matrix.cpp	/^void csr_binop_csr_canonical($/;"	f	namespace:SymEngine
csr_diagonal	symengine/sparse_matrix.cpp	/^void csr_diagonal(const CSRMatrix &A, DenseMatrix &D)$/;"	f	namespace:SymEngine
csr_has_canonical_format	symengine/sparse_matrix.cpp	/^bool CSRMatrix::csr_has_canonical_format(const std::vector<unsigned> &p_,$/;"	f	class:SymEngine::CSRMatrix
csr_has_duplicates	symengine/sparse_matrix.cpp	/^bool CSRMatrix::csr_has_duplicates(const std::vector<unsigned> &p_,$/;"	f	class:SymEngine::CSRMatrix
csr_has_sorted_indices	symengine/sparse_matrix.cpp	/^bool CSRMatrix::csr_has_sorted_indices(const std::vector<unsigned> &p_,$/;"	f	class:SymEngine::CSRMatrix
csr_matmat_pass1	symengine/sparse_matrix.cpp	/^void csr_matmat_pass1(const CSRMatrix &A, const CSRMatrix &B, CSRMatrix &C)$/;"	f	namespace:SymEngine
csr_matmat_pass2	symengine/sparse_matrix.cpp	/^void csr_matmat_pass2(const CSRMatrix &A, const CSRMatrix &B, CSRMatrix &C)$/;"	f	namespace:SymEngine
csr_scale_columns	symengine/sparse_matrix.cpp	/^void csr_scale_columns(CSRMatrix &A, const DenseMatrix &X)$/;"	f	namespace:SymEngine
csr_scale_rows	symengine/sparse_matrix.cpp	/^void csr_scale_rows(CSRMatrix &A, const DenseMatrix &X)$/;"	f	namespace:SymEngine
csr_sort_indices	symengine/sparse_matrix.cpp	/^void CSRMatrix::csr_sort_indices(std::vector<unsigned> &p_,$/;"	f	class:SymEngine::CSRMatrix
csr_sum_duplicates	symengine/sparse_matrix.cpp	/^void CSRMatrix::csr_sum_duplicates(std::vector<unsigned> &p_,$/;"	f	class:SymEngine::CSRMatrix
csv_reporter	benchmarks/nonius.h++	/^    struct csv_reporter : reporter {$/;"	s	namespace:nonius
current	benchmarks/nonius.h++	/^        std::string current;$/;"	m	struct:nonius::csv_reporter
current	benchmarks/nonius.h++	/^        std::string current;$/;"	m	struct:nonius::html_reporter
current	benchmarks/nonius.h++	/^        std::string current;$/;"	m	struct:nonius::junit_reporter
current	benchmarks/nonius.h++	/^        std::string current;$/;"	m	struct:nonius::standard_reporter
d_	symengine/expand.cpp	/^    umap_basic_num d_;$/;"	m	class:SymEngine::ExpandVisitor	file:
d_acceptedTokens__	symengine/parser/parserbase.h	/^    size_t d_acceptedTokens__;$/;"	m	class:SymEngine::ParserBase
d_action	symengine/parser/parser.cpp	/^        int d_action;        \/\/ may be negative (reduce),$/;"	m	union:__anon29::SR__::__anon32	file:
d_action	symengine/parser/parser.cpp	/^        int d_action;        \/\/ may be negative (reduce),$/;"	m	union:__anon8::SR__::__anon11	file:
d_atBOL	symengine/parser/scannerbase.h	/^    bool d_atBOL = true; \/\/ the matched text starts at BOL$/;"	m	class:SymEngine::ScannerBase
d_data	symengine/parser/parserbase.h	/^    DataType d_data;$/;"	m	class:SymEngine::Meta__::Semantic
d_debug__	symengine/parser/parserbase.h	/^    bool d_debug__;$/;"	m	class:SymEngine::ParserBase
d_deque	symengine/parser/scannerbase.h	/^        std::deque<unsigned char> d_deque; \/\/ pending input chars$/;"	m	class:SymEngine::ScannerBase::Input
d_dfaBase__	symengine/parser/scannerbase.h	/^    int const (*d_dfaBase__)[42];$/;"	m	class:SymEngine::ScannerBase
d_errorState	symengine/parser/parser.cpp	/^        size_t d_errorState; \/\/ used with Error states$/;"	m	union:__anon29::SR__::__anon32	file:
d_errorState	symengine/parser/parser.cpp	/^        size_t d_errorState; \/\/ used with Error states$/;"	m	union:__anon8::SR__::__anon11	file:
d_filename	symengine/parser/scannerbase.h	/^    std::string d_filename;    \/\/ name of the currently processed$/;"	m	class:SymEngine::ScannerBase
d_final	symengine/parser/scannerbase.h	/^    Final d_final;$/;"	m	class:SymEngine::ScannerBase
d_get	symengine/parser/scannerbase.h	/^    size_t (ScannerBase::*d_get)() = &ScannerBase::getInput;$/;"	m	class:SymEngine::ScannerBase
d_in	symengine/parser/scannerbase.h	/^        std::istream *d_in;                \/\/ ptr for easy streamswitching$/;"	m	class:SymEngine::ScannerBase::Input
d_in	symengine/parser/scannerbase.h	/^    std::istream *d_in;                         \/\/ points to the input stream$/;"	m	class:SymEngine::ScannerBase
d_in__	symengine/parser/scannerbase.h	/^    std::istream *d_in__;$/;"	m	class:SymEngine::ScannerBase
d_input	symengine/parser/scannerbase.h	/^    Input d_input;$/;"	m	class:SymEngine::ScannerBase
d_lastIdx	symengine/parser/parser.cpp	/^        int d_lastIdx;       \/\/ if negative, the state uses SHIFT$/;"	m	union:__anon29::SR__::__anon32	file:
d_lastIdx	symengine/parser/parser.cpp	/^        int d_lastIdx;       \/\/ if negative, the state uses SHIFT$/;"	m	union:__anon8::SR__::__anon11	file:
d_line	symengine/parser/scannerbase.h	/^    std::shared_ptr<std::istringstream> d_line; \/\/ holds line fm d_in$/;"	m	class:SymEngine::ScannerBase
d_lineNr	symengine/parser/scannerbase.h	/^        size_t d_lineNr;                   \/\/ line count$/;"	m	class:SymEngine::ScannerBase::Input
d_lopEnd	symengine/parser/scannerbase.h	/^    std::string::iterator d_lopEnd;$/;"	m	class:SymEngine::ScannerBase
d_lopIter	symengine/parser/scannerbase.h	/^    std::string::iterator d_lopIter;$/;"	m	class:SymEngine::ScannerBase
d_lopMatched	symengine/parser/scannerbase.h	/^    std::string d_lopMatched; \/\/ matched lop-rule characters$/;"	m	class:SymEngine::ScannerBase
d_lopPending	symengine/parser/scannerbase.h	/^    size_t d_lopPending; \/\/ # pending input chars at lop1__$/;"	m	class:SymEngine::ScannerBase
d_lopSC	symengine/parser/scannerbase.h	/^    int d_lopSC = 0;$/;"	m	class:SymEngine::ScannerBase
d_lopTail	symengine/parser/scannerbase.h	/^    std::string::iterator d_lopTail;$/;"	m	class:SymEngine::ScannerBase
d_matched	symengine/parser/scannerbase.h	/^    std::string d_matched;    \/\/ matched characters$/;"	m	class:SymEngine::ScannerBase
d_more	symengine/parser/scannerbase.h	/^    bool d_more = false; \/\/ set to true by more()$/;"	m	class:SymEngine::ScannerBase
d_nErrors__	symengine/parser/parserbase.h	/^    size_t d_nErrors__;$/;"	m	class:SymEngine::ParserBase
d_nextState	symengine/parser/scannerbase.h	/^    int d_nextState;$/;"	m	class:SymEngine::ScannerBase
d_nextToken__	symengine/parser/parserbase.h	/^    int d_nextToken__;$/;"	m	class:SymEngine::ParserBase
d_nextVal__	symengine/parser/parserbase.h	/^    STYPE__ d_nextVal__;$/;"	m	class:SymEngine::ParserBase
d_nonTerm	symengine/parser/parser.cpp	/^    size_t d_nonTerm; \/\/ identification number of this production's$/;"	m	struct:__anon29::PI__	file:
d_nonTerm	symengine/parser/parser.cpp	/^    size_t d_nonTerm; \/\/ identification number of this production's$/;"	m	struct:__anon8::PI__	file:
d_out	symengine/parser/scannerbase.h	/^    std::shared_ptr<std::ostream> d_out;$/;"	m	class:SymEngine::ScannerBase
d_requiredTokens__	symengine/parser/parserbase.h	/^    size_t d_requiredTokens__;$/;"	m	class:SymEngine::ParserBase
d_return	symengine/parser/scannerbase.h	/^    bool d_return;       \/\/ return after a rule's action$/;"	m	class:SymEngine::ScannerBase
d_scanner	symengine/parser/parser.h	/^    Scanner d_scanner;$/;"	m	class:SymEngine::Parser
d_size	symengine/parser/parser.cpp	/^    size_t d_size;    \/\/ number of elements in this production$/;"	m	struct:__anon29::PI__	file:
d_size	symengine/parser/parser.cpp	/^    size_t d_size;    \/\/ number of elements in this production$/;"	m	struct:__anon8::PI__	file:
d_stackIdx__	symengine/parser/parserbase.h	/^    int d_stackIdx__;$/;"	m	class:SymEngine::ParserBase
d_startCondition	symengine/parser/scannerbase.h	/^    int d_startCondition = 0;$/;"	m	class:SymEngine::ScannerBase
d_state	symengine/parser/scannerbase.h	/^    size_t d_state = 0;$/;"	m	class:SymEngine::ScannerBase
d_stateStack__	symengine/parser/parserbase.h	/^    std::vector<size_t> d_stateStack__;$/;"	m	class:SymEngine::ParserBase
d_state__	symengine/parser/parserbase.h	/^    size_t d_state__;$/;"	m	class:SymEngine::ParserBase
d_streamStack	symengine/parser/scannerbase.h	/^    std::vector<StreamStruct> d_streamStack;$/;"	m	class:SymEngine::ScannerBase
d_tag	symengine/parser/parserbase.h	/^    Tag__ d_tag;$/;"	m	class:SymEngine::Meta__::Base
d_token	symengine/parser/parser.cpp	/^        int d_token;$/;"	m	union:__anon29::SR__::__anon31	file:
d_token	symengine/parser/parser.cpp	/^        int d_token;$/;"	m	union:__anon8::SR__::__anon10	file:
d_token__	symengine/parser/parserbase.h	/^    int d_token__;$/;"	m	class:SymEngine::ParserBase
d_token__	symengine/parser/scannerbase.h	/^    int d_token__; \/\/ returned by lex__$/;"	m	class:SymEngine::ScannerBase
d_type	symengine/parser/parser.cpp	/^        int d_type;$/;"	m	union:__anon29::SR__::__anon31	file:
d_type	symengine/parser/parser.cpp	/^        int d_type;$/;"	m	union:__anon8::SR__::__anon10	file:
d_val__	symengine/parser/parserbase.h	/^    STYPE__ d_val__;$/;"	m	class:SymEngine::ParserBase
d_valueStack__	symengine/parser/parserbase.h	/^    std::vector<STYPE__> d_valueStack__;$/;"	m	class:SymEngine::ParserBase
d_vsp__	symengine/parser/parserbase.h	/^    STYPE__ *d_vsp__;$/;"	m	class:SymEngine::ParserBase
data	benchmarks/nonius.h++	/^            TStorage data;$/;"	m	struct:nonius::detail::object_storage
data	benchmarks/nonius.h++	/^        std::unordered_map<std::string, data_ptr> data;$/;"	m	class:cpptempl::data_map
data	benchmarks/nonius.h++	/^        std::unordered_map<std::string, result> data;$/;"	m	struct:nonius::junit_reporter
data	benchmarks/nonius.h++	/^        std::unordered_map<std::string, std::vector<fp_seconds>> data;$/;"	m	struct:nonius::csv_reporter
data	benchmarks/nonius.h++	/^        std::unordered_map<std::string, std::vector<fp_seconds>> data;$/;"	m	struct:nonius::html_reporter
data	symengine/cwrapper.h	/^    void *data;$/;"	m	struct:CRCPBasic_C
data	symengine/mp_boost.cpp	/^    integer_class data[2][2]; \/\/ data[1][0] is row 1, column 0 entry of matrix$/;"	m	struct:SymEngine::two_by_two_matrix	file:
data	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type &SType::data()$/;"	f	class:SymEngine::Meta__::SType
data	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type &Semantic<tg_>::data()$/;"	f	class:SymEngine::Meta__::Semantic
data	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type const &SType::data() const$/;"	f	class:SymEngine::Meta__::TypeOf::SType
data	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type const &Semantic<tg_>::data() const$/;"	f	class:SymEngine::Meta__::TypeOf::Semantic
data_list	benchmarks/nonius.h++	/^    typedef std::vector<data_ptr> data_list ;$/;"	t	namespace:cpptempl
data_map	benchmarks/nonius.h++	/^    class data_map {$/;"	c	namespace:cpptempl
data_ptr	benchmarks/nonius.h++	/^        data_ptr() {}$/;"	f	class:cpptempl::data_ptr
data_ptr	benchmarks/nonius.h++	/^        data_ptr(const data_ptr& data) {$/;"	f	class:cpptempl::data_ptr
data_ptr	benchmarks/nonius.h++	/^        template<typename T> data_ptr(const T& data) {$/;"	f	class:cpptempl::data_ptr
data_ptr	benchmarks/nonius.h++	/^    class data_ptr {$/;"	c	namespace:cpptempl
data_ptr	benchmarks/nonius.h++	/^    inline data_ptr::data_ptr(DataList* data) : ptr(data) {}$/;"	f	class:cpptempl::data_ptr
data_ptr	benchmarks/nonius.h++	/^    inline data_ptr::data_ptr(DataMap* data) : ptr(data) {}$/;"	f	class:cpptempl::data_ptr
data_ptr	benchmarks/nonius.h++	/^    inline data_ptr::data_ptr(DataValue* data) : ptr(data) {}$/;"	f	class:cpptempl::data_ptr
dcomplex	symengine/cwrapper.h	/^typedef struct dcomplex {$/;"	s
dcomplex	symengine/cwrapper.h	/^} dcomplex;$/;"	t	typeref:struct:dcomplex
deallocFunctorDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^deallocFunctorDelete( DeleteFunctor deleteFunctor )$/;"	f	namespace:Teuchos
deallocFunctorHandleDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^deallocFunctorHandleDelete( DeleteHandleFunctor deleteHandleFunctor )$/;"	f	namespace:Teuchos
dealloc_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  Dealloc dealloc_;$/;"	m	class:Teuchos::EmbeddedObjDealloc
dealloc_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  Dealloc_T dealloc_;$/;"	m	class:Teuchos::RCPNodeTmpl
debug	symengine/parser/parserbase.h	/^inline bool ParserBase::debug() const$/;"	f	class:SymEngine::ParserBase
debug	symengine/parser/scanner.cpp	/^bool ScannerBase::debug() const$/;"	f	class:SymEngine::ScannerBase
debugAssertStrength	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^inline void debugAssertStrength(ERCPStrength strength)$/;"	f	namespace:Teuchos
debug_assert_not_null	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^  void debug_assert_not_null() const$/;"	f	class:Teuchos::Ptr
debug_assert_not_null	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  inline const RCP<T>& debug_assert_not_null() const$/;"	f	class:Teuchos::RCP
debug_assert_not_null	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void debug_assert_not_null() const$/;"	f	class:Teuchos::RCPNodeHandle
debug_assert_valid_ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^void Ptr<T>::debug_assert_valid_ptr() const$/;"	f	class:Teuchos::Ptr
debug_assert_valid_ptr	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  inline const RCP<T>& debug_assert_valid_ptr() const$/;"	f	class:Teuchos::RCP
debug_assert_valid_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void debug_assert_valid_ptr(const RCPType& rcp_obj) const$/;"	f	class:Teuchos::RCPNodeHandle
debug_methods	symengine/derivative.cpp	/^#define debug_methods$/;"	d	file:
decltype	symengine/expression.h	/^    auto operator()(std::ostream &os, const U &cf) const -> decltype(os << cf)$/;"	f	struct:piranha::print_coefficient_impl
decomposedExpression	symengine/utilities/catch/catch.hpp	/^        mutable DecomposedExpression const* decomposedExpression;$/;"	m	struct:Catch::AssertionResultData
deep	symengine/expand.cpp	/^    bool deep;$/;"	m	class:SymEngine::ExpandVisitor	file:
degree	symengine/fields.h	/^    unsigned degree() const$/;"	f	class:SymEngine::GaloisFieldDict
degree	symengine/flint_wrapper.h	/^    long degree() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
degree	symengine/flint_wrapper.h	/^    long degree() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
degree	symengine/polys/upolybase.h	/^    Key degree() const$/;"	f	class:SymEngine::ODictWrapper
degree_	symengine/series.h	/^    const unsigned degree_;$/;"	m	class:SymEngine::SeriesBase
deincr_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int deincr_count( const ERCPStrength strength )$/;"	f	class:Teuchos::RCPNode
deleteAll	symengine/utilities/catch/catch.hpp	/^    void deleteAll( ContainerT& container ) {$/;"	f	namespace:Catch
deleteAllValues	symengine/utilities/catch/catch.hpp	/^    void deleteAllValues( AssociativeContainerT& container ) {$/;"	f	namespace:Catch
deleteFunctor_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  DeleteFunctor deleteFunctor_;$/;"	m	class:Teuchos::DeallocFunctorDelete
deleteHandleFunctor_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  DeleteHandleFunctor deleteHandleFunctor_;$/;"	m	class:Teuchos::DeallocFunctorHandleDelete
delete_obj	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  virtual void delete_obj()$/;"	f	class:Teuchos::RCPNodeTmpl
deleted_ptr_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  T *deleted_ptr_;$/;"	m	class:Teuchos::RCPNodeTmpl
demangleName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.cpp	/^std::string Teuchos::demangleName( const std::string &mangledName )$/;"	f	class:Teuchos
demangle_function_name	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string demangle_function_name(std::string name)$/;"	f	namespace:__anon22
demangle_function_name	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string demangle_function_name(std::string name)$/;"	f	namespace:__anon43
denom_	symengine/numer_denom.cpp	/^    Ptr<RCP<const Basic>> numer_, denom_;$/;"	m	class:SymEngine::NumerDenomVisitor	file:
dense_matrix_FFLDU	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_FFLDU(CDenseMatrix *l, CDenseMatrix *d,$/;"	f
dense_matrix_FFLU	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_FFLU(CDenseMatrix *lu,$/;"	f
dense_matrix_LDL	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_LDL(CDenseMatrix *l, CDenseMatrix *d,$/;"	f
dense_matrix_LU	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_LU(CDenseMatrix *l, CDenseMatrix *u,$/;"	f
dense_matrix_LU_solve	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_LU_solve(CDenseMatrix *x,$/;"	f
dense_matrix_add_matrix	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_add_matrix(CDenseMatrix *s,$/;"	f
dense_matrix_add_scalar	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_add_scalar(CDenseMatrix *s,$/;"	f
dense_matrix_col_del	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_col_del(CDenseMatrix *A, unsigned k)$/;"	f
dense_matrix_col_join	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_col_join(CDenseMatrix *A,$/;"	f
dense_matrix_cols	symengine/cwrapper.cpp	/^unsigned long int dense_matrix_cols(const CDenseMatrix *s)$/;"	f
dense_matrix_det	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_det(basic s, const CDenseMatrix *mat)$/;"	f
dense_matrix_diag	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_diag(CDenseMatrix *s, CVecBasic *d,$/;"	f
dense_matrix_diff	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_diff(CDenseMatrix *result,$/;"	f
dense_matrix_eq	symengine/cwrapper.cpp	/^int dense_matrix_eq(CDenseMatrix *lhs, CDenseMatrix *rhs)$/;"	f
dense_matrix_eye	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_eye(CDenseMatrix *s, unsigned long int N,$/;"	f
dense_matrix_free	symengine/cwrapper.cpp	/^void dense_matrix_free(CDenseMatrix *self)$/;"	f
dense_matrix_get_basic	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_get_basic(basic s, const CDenseMatrix *mat,$/;"	f
dense_matrix_inv	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_inv(CDenseMatrix *s, const CDenseMatrix *mat)$/;"	f
dense_matrix_jacobian	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_jacobian(CDenseMatrix *result,$/;"	f
dense_matrix_mul_matrix	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_mul_matrix(CDenseMatrix *s,$/;"	f
dense_matrix_mul_scalar	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_mul_scalar(CDenseMatrix *s,$/;"	f
dense_matrix_new	symengine/cwrapper.cpp	/^CDenseMatrix *dense_matrix_new()$/;"	f
dense_matrix_new_rows_cols	symengine/cwrapper.cpp	/^CDenseMatrix *dense_matrix_new_rows_cols(unsigned rows, unsigned cols)$/;"	f
dense_matrix_new_vec	symengine/cwrapper.cpp	/^CDenseMatrix *dense_matrix_new_vec(unsigned rows, unsigned cols, CVecBasic *l)$/;"	f
dense_matrix_ones	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_ones(CDenseMatrix *s, unsigned long int r,$/;"	f
dense_matrix_row_del	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_row_del(CDenseMatrix *A, unsigned k)$/;"	f
dense_matrix_row_join	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_row_join(CDenseMatrix *A,$/;"	f
dense_matrix_rows	symengine/cwrapper.cpp	/^unsigned long int dense_matrix_rows(const CDenseMatrix *s)$/;"	f
dense_matrix_rows_cols	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_rows_cols(CDenseMatrix *mat, unsigned r,$/;"	f
dense_matrix_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_set(CDenseMatrix *s, const CDenseMatrix *d)$/;"	f
dense_matrix_set_basic	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_set_basic(CDenseMatrix *mat,$/;"	f
dense_matrix_str	symengine/cwrapper.cpp	/^char *dense_matrix_str(const CDenseMatrix *s)$/;"	f
dense_matrix_submatrix	symengine/cwrapper.cpp	/^dense_matrix_submatrix(CDenseMatrix *s, const CDenseMatrix *mat,$/;"	f
dense_matrix_transpose	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_transpose(CDenseMatrix *s,$/;"	f
dense_matrix_zeros	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE dense_matrix_zeros(CDenseMatrix *s, unsigned long int r,$/;"	f
derivative	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper derivative() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
derivative	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper derivative() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
description	benchmarks/nonius.h++	/^            std::string description;$/;"	m	struct:nonius::detail::option
description	symengine/utilities/catch/catch.hpp	/^    const char* description;$/;"	m	struct:Catch::NameAndDesc
destroy_when	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    EPrePostDestruction destroy_when;$/;"	m	struct:Teuchos::RCPNode::extra_data_entry_t
destruct	benchmarks/nonius.h++	/^            typename std::enable_if<AllowManualDestruction>::type destruct()$/;"	f	struct:nonius::detail::object_storage
destruct_on_exit	benchmarks/nonius.h++	/^            void destruct_on_exit(typename std::enable_if<!Destruct, U>::type* = 0) { }$/;"	f	struct:nonius::detail::object_storage
destruct_on_exit	benchmarks/nonius.h++	/^            void destruct_on_exit(typename std::enable_if<Destruct, U>::type* = 0) { destruct<true>(); }$/;"	f	struct:nonius::detail::object_storage
det	symengine/dense_matrix.cpp	/^RCP<const Basic> DenseMatrix::det() const$/;"	f	class:SymEngine::DenseMatrix
det	symengine/sparse_matrix.cpp	/^RCP<const Basic> CSRMatrix::det() const$/;"	f	class:SymEngine::CSRMatrix
det_bareis	symengine/dense_matrix.cpp	/^RCP<const Basic> det_bareis(const DenseMatrix &A)$/;"	f	namespace:SymEngine
det_berkowitz	symengine/dense_matrix.cpp	/^RCP<const Basic> det_berkowitz(const DenseMatrix &A)$/;"	f	namespace:SymEngine
detail	benchmarks/nonius.h++	/^    namespace detail {$/;"	n	namespace:nonius
detail	symengine/expression.cpp	/^namespace detail$/;"	n	namespace:SymEngine	file:
detail	symengine/expression.h	/^namespace detail$/;"	n	namespace:SymEngine
detail	symengine/mp_class.h	/^namespace detail$/;"	n	namespace:boost
diag	symengine/dense_matrix.cpp	/^void diag(DenseMatrix &A, vec_basic &v, int k)$/;"	f	namespace:SymEngine
diagonal_solve	symengine/dense_matrix.cpp	/^void diagonal_solve(const DenseMatrix &A, const DenseMatrix &b, DenseMatrix &x)$/;"	f	namespace:SymEngine
dict_	symengine/add.h	/^    umap_basic_num dict_; \/\/! The dictionary of the rest (e.g. `x+y` in `2+x+y`)$/;"	m	class:SymEngine::Add
dict_	symengine/fields.h	/^    std::vector<integer_class> dict_;$/;"	m	class:SymEngine::GaloisFieldDict
dict_	symengine/functions.h	/^    map_basic_basic dict_;$/;"	m	class:SymEngine::Subs
dict_	symengine/mul.h	/^        dict_; \/\/! the dictionary of the rest (e.g. `x*y` in `2*x*y`)$/;"	m	class:SymEngine::Mul
dict_	symengine/polys/upolybase.h	/^    std::map<Key, Value> dict_;$/;"	m	class:SymEngine::ODictWrapper
dict_add_term	symengine/add.cpp	/^void Add::dict_add_term(umap_basic_num &d, const RCP<const Number> &coef,$/;"	f	class:SymEngine::Add
dict_add_term	symengine/mul.cpp	/^void Mul::dict_add_term(map_basic_basic &d, const RCP<const Basic> &exp,$/;"	f	class:SymEngine::Mul
dict_add_term_new	symengine/mul.cpp	/^void Mul::dict_add_term_new(const Ptr<RCP<const Number>> &coef,$/;"	f	class:SymEngine::Mul
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(Vec pow, const Basic &x)$/;"	f	class:SymEngine::BasicToMPolyBase
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(unsigned int pow, const Basic &x)$/;"	f	class:SymEngine::BasicToUExprPoly
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(unsigned int pow, const Basic &x)$/;"	f	class:SymEngine::BasicToUIntPoly
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(unsigned int pow, const Basic &x)$/;"	f	class:SymEngine::BasicToUPolyBase
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(unsigned int pow, const Basic &x)$/;"	f	class:SymEngine::BasicToURatPoly
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(vec_int pow, const Basic &x)$/;"	f	class:SymEngine::BasicToMExprPoly
dict_set	symengine/polys/basic_conversions.h	/^    void dict_set(vec_uint pow, const Basic &x)$/;"	f	class:SymEngine::BasicToMIntPoly
dict_type	symengine/polys/msymenginepoly.h	/^    typedef Dict dict_type;$/;"	t	class:SymEngine::UDictWrapper
diff	symengine/basic.cpp	/^RCP<const Basic> Basic::diff(const RCP<const Symbol> &x) const$/;"	f	class:SymEngine::Basic
diff	symengine/dense_matrix.cpp	/^void diff(const DenseMatrix &A, const RCP<const Symbol> &x, DenseMatrix &result)$/;"	f	namespace:SymEngine
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff($/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACos &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACosh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACot &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACoth &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACsc &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ACsch &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ASec &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ASech &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ASin &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ASinh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ATan &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ATan2 &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const ATanh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Abs &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Add &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Basic &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Beta &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Boolean &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Constant &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Cos &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Cosh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Cot &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Coth &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Csc &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Csch &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Derivative &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Erf &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Erfc &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const FunctionWrapper &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const GaloisField &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Gamma &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const LambertW &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Log &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const LogGamma &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const MSymEnginePoly<Container, Poly> &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Mul &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const MultiArgFunction &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Number &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const OneArgFunction &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Piecewise &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Pow &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Sec &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Sech &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Set &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Sin &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Sinh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Subs &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Symbol &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Tan &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const Tanh &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const UExprPoly &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const UIntPoly &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const UIntPolyFlint &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const UIntPolyPiranha &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const URatPoly &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const URatPolyFlint &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^    static RCP<const Basic> diff(const URatPolyPiranha &self,$/;"	f	class:SymEngine::DiffImplementation
diff	symengine/derivative.cpp	/^RCP<const Basic> diff(const RCP<const Basic> &arg, const RCP<const Symbol> &x)$/;"	f	namespace:SymEngine
diff	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::diff(const fqp_t &s, const fqp_t &var)$/;"	f	class:SymEngine::URatPSeriesFlint
diff	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::diff(const UExprDict &s, const UExprDict &var)$/;"	f	class:SymEngine::UnivariateSeries
diff	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::diff(const p_expr &s, const p_expr &var)$/;"	f	class:SymEngine::UPSeriesPiranha
diff	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::diff(const pp_t &s, const pp_t &var)$/;"	f	class:SymEngine::URatPSeriesPiranha
diff_impl	symengine/tests/basic/test_functions.cpp	/^    RCP<const Basic> diff_impl(const RCP<const Symbol> &x) const$/;"	f	class:MySin
diff_upoly	symengine/derivative.cpp	/^    static RCP<const Basic> diff_upoly(const Poly &self,$/;"	f	class:SymEngine::DiffImplementation
diff_upolyflint	symengine/derivative.cpp	/^    static RCP<const Basic> diff_upolyflint(const P &self,$/;"	f	class:SymEngine::DiffImplementation
difference	bin/test_make_install.py	/^difference = all_files - installed_files$/;"	v
digamma	symengine/functions.cpp	/^RCP<const Basic> digamma(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
dirichlet_eta	symengine/functions.cpp	/^RCP<const Basic> dirichlet_eta(const RCP<const Basic> &s)$/;"	f	namespace:SymEngine
div	symengine/complex.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::Complex
div	symengine/complex_double.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const ComplexMPC &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::div(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/complex_mpc.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
div	symengine/infinity.cpp	/^RCP<const Number> Infty::div(const Number &other) const$/;"	f	class:SymEngine::Infty
div	symengine/integer.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::Integer
div	symengine/mul.cpp	/^RCP<const Basic> div(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	namespace:SymEngine
div	symengine/nan.cpp	/^RCP<const Number> NaN::div(const Number &other) const$/;"	f	class:SymEngine::NaN
div	symengine/number.cpp	/^RCP<const Number> Number::div(const Number &other) const$/;"	f	class:SymEngine::Number
div	symengine/rational.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::Rational
div	symengine/real_double.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::RealDouble
div	symengine/real_mpfr.h	/^    virtual RCP<const Number> div(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
divcomp	symengine/complex.h	/^    inline RCP<const Number> divcomp(const Complex &other) const$/;"	f	class:SymEngine::Complex
divcomp	symengine/complex.h	/^    inline RCP<const Number> divcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
divcomp	symengine/complex.h	/^    inline RCP<const Number> divcomp(const Rational &other) const$/;"	f	class:SymEngine::Complex
divcomp	symengine/complex_double.h	/^    RCP<const Number> divcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
divcomp	symengine/complex_double.h	/^    RCP<const Number> divcomp(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
divcomp	symengine/complex_double.h	/^    RCP<const Number> divcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
divcomp	symengine/complex_double.h	/^    RCP<const Number> divcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
divcomp	symengine/complex_double.h	/^    RCP<const Number> divcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
divexact_impl	symengine/polys/uintpoly_piranha.h	/^struct divexact_impl<SymEngine::integer_class> {$/;"	s	namespace:piranha::math
divexact_impl	symengine/polys/uintpoly_piranha.h	/^struct divexact_impl<SymEngine::rational_class> {$/;"	s	namespace:piranha::math
divides	symengine/ntheory.cpp	/^bool divides(const Integer &a, const Integer &b)$/;"	f	namespace:SymEngine
divides_upoly	symengine/polys/uintpoly.cpp	/^bool divides_upoly(const UIntPoly &a, const UIntPoly &b,$/;"	f	namespace:SymEngine
divides_upoly	symengine/polys/uintpoly_flint.h	/^bool divides_upoly(const UFlintPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
divides_upoly	symengine/polys/uintpoly_piranha.h	/^bool divides_upoly(const UPiranhaPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
divides_upoly	symengine/polys/uratpoly.cpp	/^bool divides_upoly(const URatPoly &a, const URatPoly &b,$/;"	f	namespace:SymEngine
divint	symengine/integer.cpp	/^RCP<const Number> Integer::divint(const Integer &other) const$/;"	f	class:SymEngine::Integer
divnum	symengine/number.h	/^inline RCP<const Number> divnum(const RCP<const Number> &self,$/;"	f	namespace:SymEngine
divrat	symengine/rational.h	/^    inline RCP<const Number> divrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
divrat	symengine/rational.h	/^    inline RCP<const Number> divrat(const Rational &other) const$/;"	f	class:SymEngine::Rational
divreal	symengine/real_double.h	/^    RCP<const Number> divreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
divreal	symengine/real_double.h	/^    RCP<const Number> divreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
divreal	symengine/real_double.h	/^    RCP<const Number> divreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
divreal	symengine/real_double.h	/^    RCP<const Number> divreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealDouble
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
divreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::divreal(const RealMPFR &other) const$/;"	f	class:SymEngine::RealMPFR
divrem	symengine/flint_wrapper.h	/^    void divrem(fmpq_poly_wrapper &q, fmpq_poly_wrapper &r,$/;"	f	class:SymEngine::fmpq_poly_wrapper
divrem	symengine/flint_wrapper.h	/^    void divrem(fmpz_poly_wrapper &q, fmpz_poly_wrapper &r,$/;"	f	class:SymEngine::fmpz_poly_wrapper
do_analysis_complete	benchmarks/nonius.h++	/^        virtual void do_analysis_complete(sample_analysis<fp_seconds> const& \/*analysis*\/) {}$/;"	f	struct:nonius::reporter
do_analysis_start	benchmarks/nonius.h++	/^        virtual void do_analysis_start() {} \/\/ TODO make generic?$/;"	f	struct:nonius::reporter
do_benchmark_complete	benchmarks/nonius.h++	/^        virtual void do_benchmark_complete() {}$/;"	f	struct:nonius::reporter
do_benchmark_failure	benchmarks/nonius.h++	/^        virtual void do_benchmark_failure(std::exception_ptr \/*error*\/) {}$/;"	f	struct:nonius::reporter
do_benchmark_start	benchmarks/nonius.h++	/^        virtual void do_benchmark_start(std::string const& \/*name*\/) {}$/;"	f	struct:nonius::reporter
do_configure	benchmarks/nonius.h++	/^        virtual void do_configure(configuration& \/*cfg*\/) {}$/;"	f	struct:nonius::reporter
do_estimate_clock_cost_complete	benchmarks/nonius.h++	/^        virtual void do_estimate_clock_cost_complete(environment_estimate<fp_seconds> \/*estimate*\/) {}$/;"	f	struct:nonius::reporter
do_estimate_clock_cost_start	benchmarks/nonius.h++	/^        virtual void do_estimate_clock_cost_start() {}$/;"	f	struct:nonius::reporter
do_estimate_clock_resolution_complete	benchmarks/nonius.h++	/^        virtual void do_estimate_clock_resolution_complete(environment_estimate<fp_seconds> \/*estimate*\/) {}$/;"	f	struct:nonius::reporter
do_estimate_clock_resolution_start	benchmarks/nonius.h++	/^        virtual void do_estimate_clock_resolution_start() {}$/;"	f	struct:nonius::reporter
do_measurement_complete	benchmarks/nonius.h++	/^        virtual void do_measurement_complete(std::vector<fp_seconds> const& \/*samples*\/) {}$/;"	f	struct:nonius::reporter
do_measurement_start	benchmarks/nonius.h++	/^        virtual void do_measurement_start(execution_plan<fp_seconds> \/*plan*\/) {}$/;"	f	struct:nonius::reporter
do_suite_complete	benchmarks/nonius.h++	/^        virtual void do_suite_complete() {}$/;"	f	struct:nonius::reporter
do_suite_start	benchmarks/nonius.h++	/^        virtual void do_suite_start() {}$/;"	f	struct:nonius::reporter
do_warmup_end	benchmarks/nonius.h++	/^        virtual void do_warmup_end(int \/*iterations*\/) {}$/;"	f	struct:nonius::reporter
do_warmup_start	benchmarks/nonius.h++	/^        virtual void do_warmup_start() {}$/;"	f	struct:nonius::reporter
domain_	symengine/solve.cpp	/^    RCP<const Set> domain_;$/;"	m	class:SymEngine::InvertComplexVisitor	file:
dot	symengine/dense_matrix.cpp	/^void dot(const DenseMatrix &A, const DenseMatrix &B, DenseMatrix &C)$/;"	f	namespace:SymEngine
double_arg_boolean_func	symengine/parser/parser.h	/^    typedef RCP<const Boolean> (*double_arg_boolean_func)($/;"	t	class:SymEngine::Parser
double_arg_boolean_func	symengine/parser/parser_old.cpp	/^    typedef RCP<const Boolean> (*double_arg_boolean_func)($/;"	t	class:SymEngine::ExpressionParser	file:
double_arg_boolean_functions	symengine/parser/parser.h	/^        double_arg_boolean_functions = {$/;"	m	class:SymEngine::Parser
double_arg_boolean_functions	symengine/parser/parser_old.cpp	/^        double_arg_boolean_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
double_arg_func	symengine/parser/parser.h	/^    typedef RCP<const Basic> (*double_arg_func)(const RCP<const Basic> &,$/;"	t	class:SymEngine::Parser
double_arg_func	symengine/parser/parser_old.cpp	/^    typedef RCP<const Basic> (*double_arg_func)(const RCP<const Basic> &,$/;"	t	class:SymEngine::ExpressionParser	file:
double_arg_functions	symengine/parser/parser.h	/^        double_arg_functions = {$/;"	m	class:SymEngine::Parser
double_arg_functions	symengine/parser/parser_old.cpp	/^        double_arg_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
double_casted_Eq	symengine/parser/parser.h	/^    double_arg_boolean_func double_casted_Eq = Eq;$/;"	m	class:SymEngine::Parser
double_casted_Eq	symengine/parser/parser_old.cpp	/^    double_arg_boolean_func double_casted_Eq = Eq;$/;"	m	class:SymEngine::ExpressionParser	file:
double_casted_log	symengine/parser/parser.h	/^    double_arg_func double_casted_log = log;$/;"	m	class:SymEngine::Parser
double_casted_log	symengine/parser/parser_old.cpp	/^    double_arg_func double_casted_log = log;$/;"	m	class:SymEngine::ExpressionParser	file:
double_casted_zeta	symengine/parser/parser.h	/^    double_arg_func double_casted_zeta = zeta;$/;"	m	class:SymEngine::Parser
double_casted_zeta	symengine/parser/parser_old.cpp	/^    double_arg_func double_casted_zeta = zeta;$/;"	m	class:SymEngine::ExpressionParser	file:
down_cast	symengine/symengine_casts.h	/^inline To down_cast(From &f)$/;"	f	namespace:SymEngine
down_cast	symengine/symengine_casts.h	/^inline To down_cast(From *f)          \/\/ Only accept pointers.$/;"	f	namespace:SymEngine
dummy	symengine/symbol.h	/^inline RCP<const Dummy> dummy()$/;"	f	namespace:SymEngine
dummy	symengine/symbol.h	/^inline RCP<const Dummy> dummy(const std::string &name)$/;"	f	namespace:SymEngine
dummy_index	symengine/symbol.h	/^    size_t dummy_index;$/;"	m	class:SymEngine::Dummy
dumps	symengine/llvm_double.cpp	/^const std::string &LLVMDoubleVisitor::dumps() const$/;"	f	class:SymEngine::LLVMDoubleVisitor
duplicate_benchmarks	benchmarks/nonius.h++	/^    struct duplicate_benchmarks : virtual std::exception {$/;"	s	namespace:nonius
dval	symengine/parser/scanner.h	/^    ParserBase::STYPE__ *dval;$/;"	m	class:SymEngine::Scanner
dyn_cast	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^T_To& dyn_cast(T_From &from)$/;"	f	namespace:Teuchos
dyn_cast_throw_exception	symengine/utilities/teuchos/Teuchos_dyn_cast.cpp	/^void Teuchos::dyn_cast_throw_exception($/;"	f	class:Teuchos
e	benchmarks/bench_eval_double.cpp	/^RCP<const Basic> e = get_eval_double_expression();$/;"	v
ec	symengine/symengine_exception.h	/^    symengine_exceptions_t ec;$/;"	m	class:SymEngine::SymEngineException
echo	symengine/parser/scannerbase.h	/^inline void ScannerBase::echo() const$/;"	f	class:SymEngine::ScannerBase
echoCh__	symengine/parser/scanner.cpp	/^void ScannerBase::echoCh__(size_t ch)$/;"	f	class:SymEngine::ScannerBase
echoFirst__	symengine/parser/scanner.cpp	/^void ScannerBase::echoFirst__(size_t ch)$/;"	f	class:SymEngine::ScannerBase
eigen_values	symengine/dense_matrix.cpp	/^RCP<const Set> eigen_values(const DenseMatrix &A)$/;"	f	namespace:SymEngine
elapsed	benchmarks/nonius.h++	/^        Duration elapsed;$/;"	m	struct:nonius::timing
element_type	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T  element_type;$/;"	t	class:Teuchos::RCP
embeddedObjDeallocArrayDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^embeddedObjDeallocArrayDelete(const Embedded &embedded, EPrePostDestruction prePostDestroy)$/;"	f	namespace:Teuchos
embeddedObjDeallocDelete	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^embeddedObjDeallocDelete(const Embedded &embedded, EPrePostDestruction prePostDestroy)$/;"	f	namespace:Teuchos
embedded_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  Embedded embedded_;$/;"	m	class:Teuchos::EmbeddedObjDealloc
emplace	symengine/parser/parserbase.h	/^inline void SType::emplace(Params &&... params)$/;"	f	class:SymEngine::Meta__::SType
empty	benchmarks/nonius.h++	/^    inline bool DataList::empty()$/;"	f	class:cpptempl::DataList
empty	benchmarks/nonius.h++	/^    inline bool DataMap::empty()$/;"	f	class:cpptempl::DataMap
empty	benchmarks/nonius.h++	/^    inline bool DataValue::empty()$/;"	f	class:cpptempl::DataValue
empty	benchmarks/nonius.h++	/^    inline bool data_map::empty() {$/;"	f	class:cpptempl::data_map
empty	symengine/fields.h	/^    bool empty() const$/;"	f	class:SymEngine::GaloisFieldDict
empty	symengine/polys/msymenginepoly.h	/^    bool empty() const$/;"	f	class:SymEngine::UDictWrapper
empty	symengine/polys/upolybase.h	/^    bool empty() const$/;"	f	class:SymEngine::ODictWrapper
empty	symengine/utilities/teuchos/Teuchos_any.hpp	/^  bool empty() const$/;"	f	class:Teuchos::any
empty	symengine/utilities/teuchos/Teuchos_map.hpp	/^    bool empty() const { return list_.empty(); }$/;"	f	class:Teuchos::std::map
emptyset	symengine/sets.h	/^inline RCP<const EmptySet> emptyset()$/;"	f	namespace:SymEngine
end	symengine/fields.h	/^    iterator end() const$/;"	f	class:SymEngine::GaloisField
end	symengine/polys/uintpoly_flint.h	/^    iterator end() const$/;"	f	class:SymEngine::UFlintPoly
end	symengine/polys/uintpoly_piranha.h	/^    iterator end() const$/;"	f	class:SymEngine::UPiranhaPoly
end	symengine/polys/usymenginepoly.h	/^    iterator end() const$/;"	f	class:SymEngine::USymEnginePoly
end	symengine/utilities/teuchos/Teuchos_map.hpp	/^    const_iterator end() const { return list_.end(); }$/;"	f	class:Teuchos::std::map
end	symengine/utilities/teuchos/Teuchos_map.hpp	/^    iterator end() { return list_.end(); }$/;"	f	class:Teuchos::std::map
end_	symengine/sets.h	/^    RCP<const Number> end_;$/;"	m	class:SymEngine::Interval
environment	benchmarks/nonius.h++	/^    struct environment {$/;"	s	namespace:nonius
environment_estimate	benchmarks/nonius.h++	/^    struct environment_estimate {$/;"	s	namespace:nonius
eq	symengine/basic-inl.h	/^inline bool eq(const Basic &a, const Basic &b)$/;"	f	namespace:SymEngine
eq	symengine/matrix.cpp	/^bool MatrixBase::eq(const MatrixBase &other) const$/;"	f	class:SymEngine::MatrixBase
eq	symengine/sparse_matrix.cpp	/^bool CSRMatrix::eq(const MatrixBase &other) const$/;"	f	class:SymEngine::CSRMatrix
erf	symengine/functions.cpp	/^RCP<const Basic> erf(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
erfc	symengine/functions.cpp	/^RCP<const Basic> erfc(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
error	symengine/parser/parser.h	/^    void error(char const *msg)$/;"	f	class:SymEngine::Parser
errorRecovery	symengine/parser/parser.cpp	/^void Parser::errorRecovery() try {$/;"	f	class:SymEngine::Parser
error_code	symengine/symengine_exception.h	/^    symengine_exceptions_t error_code()$/;"	f	class:SymEngine::SymEngineException
error_stream	benchmarks/nonius.h++	/^        std::ostream& error_stream() {$/;"	f	struct:nonius::reporter
escape	benchmarks/nonius.h++	/^        inline std::string escape(std::string const& source, std::unordered_map<char, std::string> const& escapes) {$/;"	f	namespace:nonius::detail
escape	benchmarks/nonius.h++	/^        static std::string escape(std::string const& source) {$/;"	f	struct:nonius::csv_reporter
escape	benchmarks/nonius.h++	/^        static std::string escape(std::string const& source) {$/;"	f	struct:nonius::html_reporter
escape	benchmarks/nonius.h++	/^        static std::string escape(std::string const& source) {$/;"	f	struct:nonius::junit_reporter
estimate	benchmarks/nonius.h++	/^    struct estimate {$/;"	s	namespace:nonius
estimate_clock_cost	benchmarks/nonius.h++	/^        environment_estimate<FloatDuration<Clock>> estimate_clock_cost(FloatDuration<Clock> resolution) {$/;"	f	namespace:nonius::detail
estimate_clock_cost_complete	benchmarks/nonius.h++	/^        void estimate_clock_cost_complete(environment_estimate<fp_seconds> estimate) {$/;"	f	struct:nonius::reporter
estimate_clock_cost_start	benchmarks/nonius.h++	/^        void estimate_clock_cost_start() {$/;"	f	struct:nonius::reporter
estimate_clock_resolution	benchmarks/nonius.h++	/^        environment_estimate<FloatDuration<Clock>> estimate_clock_resolution(int iterations) {$/;"	f	namespace:nonius::detail
estimate_clock_resolution_complete	benchmarks/nonius.h++	/^        void estimate_clock_resolution_complete(environment_estimate<fp_seconds> estimate) {$/;"	f	struct:nonius::reporter
estimate_clock_resolution_start	benchmarks/nonius.h++	/^        void estimate_clock_resolution_start() {$/;"	f	struct:nonius::reporter
estimated_duration	benchmarks/nonius.h++	/^        Duration estimated_duration;$/;"	m	struct:nonius::execution_plan
eval	symengine/fields.h	/^    integer_class eval(const integer_class &x) const$/;"	f	class:SymEngine::GaloisField
eval	symengine/flint_wrapper.h	/^    fmpq_wrapper eval(const fmpq_wrapper &z) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
eval	symengine/flint_wrapper.h	/^    fmpz_wrapper eval(const fmpz_wrapper &z) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
eval	symengine/number.h	/^    virtual RCP<const Number> eval(long bits) const$/;"	f	class:SymEngine::NumberWrapper
eval	symengine/polys/msymenginepoly.cpp	/^Expression MExprPoly::eval($/;"	f	class:SymEngine::MExprPoly
eval	symengine/polys/msymenginepoly.cpp	/^integer_class MIntPoly::eval($/;"	f	class:SymEngine::MIntPoly
eval	symengine/polys/uexprpoly.cpp	/^Expression UExprPoly::eval(const Expression &x) const$/;"	f	class:SymEngine::UExprPoly
eval	symengine/polys/uintpoly_flint.h	/^    Cf eval(const Cf &x) const$/;"	f	class:SymEngine::UFlintPoly
eval	symengine/polys/uintpoly_piranha.h	/^    Cf eval(const Cf &x) const$/;"	f	class:SymEngine::UPiranhaPoly
eval	symengine/polys/usymenginepoly.h	/^    Cf eval(const Cf &x) const$/;"	f	class:SymEngine::USymEnginePoly
eval	symengine/tests/basic/test_functions.cpp	/^    RCP<const Number> eval(long bits) const$/;"	f	class:MySin
eval_arb	symengine/eval_arb.cpp	/^void eval_arb(arb_t result, const Basic &b, long precision)$/;"	f	namespace:SymEngine
eval_bit	symengine/polys/uintpoly.h	/^    integer_class eval_bit(const unsigned int &x) const$/;"	f	class:SymEngine::UIntDict
eval_complex_double	symengine/eval_double.cpp	/^std::complex<double> eval_complex_double(const Basic &b)$/;"	f	namespace:SymEngine
eval_double	symengine/eval_double.cpp	/^double eval_double(const Basic &b)$/;"	f	namespace:SymEngine
eval_double_single_dispatch	symengine/eval_double.cpp	/^double eval_double_single_dispatch(const Basic &b)$/;"	f	namespace:SymEngine
eval_double_visitor_pattern	symengine/eval_double.cpp	/^double eval_double_visitor_pattern(const Basic &b)$/;"	f	namespace:SymEngine
eval_levicivita	symengine/functions.cpp	/^RCP<const Basic> eval_levicivita(const vec_basic &arg, int len)$/;"	f	namespace:SymEngine
eval_mpc	symengine/eval_mpc.cpp	/^void eval_mpc(mpc_ptr result, const Basic &b, mpfr_rnd_t rnd)$/;"	f	namespace:SymEngine
eval_mpfr	symengine/eval_mpfr.cpp	/^void eval_mpfr(mpfr_ptr result, const Basic &b, mpfr_rnd_t rnd)$/;"	f	namespace:SymEngine
eval_vec	symengine/flint_wrapper.h	/^    void eval_vec(fmpz *ovec, fmpz *ivec, unsigned int n) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
evalf	symengine/eval.cpp	/^RCP<const Basic> evalf(const Basic &b, unsigned long bits, EvalfDomain domain)$/;"	f	namespace:SymEngine
evalf_numeric	symengine/eval.cpp	/^RCP<const Number> evalf_numeric(const Basic &b, unsigned long bits, bool real)$/;"	f	namespace:SymEngine
evaluate	symengine/utilities/catch/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs ) {$/;"	f	struct:Catch::Internal::Evaluator
evaluate	symengine/utilities/catch/catch.hpp	/^        static bool evaluate( T1 const& lhs, T2 const& rhs) {$/;"	f	struct:Catch::Internal::Evaluator
exceptionHandler__	symengine/parser/parser.h	/^    void exceptionHandler__(std::exception const &exc)$/;"	f	class:SymEngine::Parser
exclude_patterns	doc/conf.py	/^exclude_patterns = ['_build']$/;"	v
excluded_symbols	symengine/cse.cpp	/^    set_basic &excluded_symbols;$/;"	m	class:SymEngine::RebuildVisitor	file:
executeAction	symengine/parser/parser.cpp	/^void Parser::executeAction(int production) try {$/;"	f	class:SymEngine::Parser
executeAction__	symengine/parser/scanner.cpp	/^int Scanner::executeAction__(size_t ruleIdx) try {$/;"	f	class:SymEngine::Scanner
execution_plan	benchmarks/nonius.h++	/^    struct execution_plan {$/;"	s	namespace:nonius
executionengine	symengine/llvm_double.h	/^    llvm::ExecutionEngine *executionengine;$/;"	m	class:SymEngine::LLVMDoubleVisitor
exp	symengine/pow.cpp	/^RCP<const Basic> exp(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
exp	symengine/series.h	/^    static inline Coeff exp(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
exp	symengine/series_generic.cpp	/^Expression UnivariateSeries::exp(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
exp	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::exp(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
exp_	symengine/pow.h	/^    RCP<const Basic> base_, exp_; \/\/! base**exp$/;"	m	class:SymEngine::Pow
exp_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper exp_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
expand	symengine/expand.cpp	/^RCP<const Basic> expand(const RCP<const Basic> &self, bool deep)$/;"	f	namespace:SymEngine
expand	symengine/expression.h	/^inline Expression expand(const Expression &arg)$/;"	f	namespace:SymEngine
expand_as_exp	symengine/basic.h	/^    virtual RCP<const Basic> expand_as_exp() const$/;"	f	class:SymEngine::Basic
expand_check_pairs	symengine/tests/basic/test_series_expansion_UP.cpp	/^static bool expand_check_pairs(const RCP<const Basic> &ex,$/;"	f	file:
expand_check_pairs	symengine/tests/basic/test_series_expansion_URatF.cpp	/^static bool expand_check_pairs(const RCP<const Basic> &ex,$/;"	f	file:
expand_check_pairs	symengine/tests/basic/test_series_expansion_URatP.cpp	/^static bool expand_check_pairs(const RCP<const Basic> &ex,$/;"	f	file:
expand_check_pairs	symengine/tests/basic/test_series_generic.cpp	/^static bool expand_check_pairs(const RCP<const Basic> &ex,$/;"	f	file:
expand_if_deep	symengine/expand.cpp	/^    RCP<const Basic> expand_if_deep(const RCP<const Basic> &expr)$/;"	f	class:SymEngine::ExpandVisitor	file:
expr2poly	symengine/rings.cpp	/^void expr2poly(const RCP<const Basic> &p, umap_basic_num &syms, umap_vec_mpz &P)$/;"	f	namespace:SymEngine
expr_	symengine/logic.h	/^    RCP<const Basic> expr_;$/;"	m	class:SymEngine::Contains
expr_	symengine/sets.h	/^    RCP<const Basic> expr_;$/;"	m	class:SymEngine::ImageSet
extensions	doc/conf.py	/^extensions = [$/;"	v
extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    any extra_data;$/;"	m	struct:Teuchos::RCPNode::extra_data_entry_t
extra_data_entry_t	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    extra_data_entry_t( const any &_extra_data, EPrePostDestruction _destroy_when )$/;"	f	struct:Teuchos::RCPNode::extra_data_entry_t
extra_data_entry_t	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    extra_data_entry_t() : destroy_when(POST_DESTROY) {}$/;"	f	struct:Teuchos::RCPNode::extra_data_entry_t
extra_data_entry_t	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  struct extra_data_entry_t {$/;"	s	class:Teuchos::RCPNode
extra_data_map_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  extra_data_map_t *extra_data_map_;$/;"	m	class:Teuchos::RCPNode
extra_data_map_t	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  typedef Teuchos::map<std::string,extra_data_entry_t> extra_data_map_t;$/;"	t	class:Teuchos::RCPNode
extract_coeffs	symengine/solve.cpp	/^inline vec_basic extract_coeffs(const RCP<const Poly> &f)$/;"	f	namespace:SymEngine
eye	symengine/dense_matrix.cpp	/^void eye(DenseMatrix &A, int k)$/;"	f	namespace:SymEngine
f	benchmarks/nonius.h++	/^            std::unique_ptr<concept> f;$/;"	m	struct:nonius::detail::benchmark_function
f	benchmarks/symbench.cpp	/^RCP<const Basic> f(RCP<const Basic> z)$/;"	f
f	benchmarks/symbench_ginac.cpp	/^ex f(ex z)$/;"	f
f	symengine/tests/rcp/test_rcp.cpp	/^void f(Mesh &m)$/;"	f
f2_const	symengine/tests/rcp/test_rcp.cpp	/^void f2_const(const Mesh2 &m)$/;"	f
f2_hybrid	symengine/tests/rcp/test_rcp.cpp	/^void f2_hybrid(Mesh2 &m)$/;"	f
f_const	symengine/tests/rcp/test_rcp.cpp	/^void f_const(const Mesh &m)$/;"	f
fac	symengine/flint_wrapper.h	/^    fmpz_poly_factor_t fac;$/;"	m	class:SymEngine::fmpz_poly_factor_wrapper
factor	symengine/ntheory.cpp	/^int factor(const Ptr<RCP<const Integer>> &f, const Integer &n, double B1)$/;"	f	namespace:SymEngine
factor_lehman_method	symengine/ntheory.cpp	/^int factor_lehman_method(const Ptr<RCP<const Integer>> &f, const Integer &n)$/;"	f	namespace:SymEngine
factor_pollard_pm1_method	symengine/ntheory.cpp	/^int factor_pollard_pm1_method(const Ptr<RCP<const Integer>> &f,$/;"	f	namespace:SymEngine
factor_pollard_rho_method	symengine/ntheory.cpp	/^int factor_pollard_rho_method(const Ptr<RCP<const Integer>> &f,$/;"	f	namespace:SymEngine
factor_trial_division	symengine/ntheory.cpp	/^int factor_trial_division(const Ptr<RCP<const Integer>> &f, const Integer &n)$/;"	f	namespace:SymEngine
factorial	symengine/ntheory.cpp	/^RCP<const Integer> factorial(unsigned long n)$/;"	f	namespace:SymEngine
factors	symengine/flint_wrapper.h	/^    fmpz_poly_factor_wrapper factors() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
factors	symengine/polys/uintpoly_flint.h	/^factors(const UFlintPoly<Container, BaseType, Poly> &a)$/;"	f	namespace:SymEngine
failure	benchmarks/nonius.h++	/^            std::exception_ptr failure;$/;"	m	struct:nonius::junit_reporter::result
false_type	symengine/utilities/catch/catch.hpp	/^        static auto test(...) -> std::false_type;$/;"	m	class:Catch::Detail::IsStreamInsertable::std
fdiff	symengine/derivative.cpp	/^    static RCP<const Basic> fdiff(const T &self, const RCP<const Symbol> &x)$/;"	f	class:SymEngine::DiffImplementation
fdiff	symengine/derivative.cpp	/^    static bool fdiff(const Ptr<RCP<const Basic>> &ret, const Function &self,$/;"	f	class:SymEngine::DiffImplementation
fdiff	symengine/derivative.cpp	/^    static bool fdiff(const Ptr<RCP<const Basic>> &ret, const LowerGamma &self,$/;"	f	class:SymEngine::DiffImplementation
fdiff	symengine/derivative.cpp	/^    static bool fdiff(const Ptr<RCP<const Basic>> &ret, const PolyGamma &self,$/;"	f	class:SymEngine::DiffImplementation
fdiff	symengine/derivative.cpp	/^    static bool fdiff(const Ptr<RCP<const Basic>> &ret, const UpperGamma &self,$/;"	f	class:SymEngine::DiffImplementation
fdiff	symengine/derivative.cpp	/^    static bool fdiff(const Ptr<RCP<const Basic>> &ret, const Zeta &self,$/;"	f	class:SymEngine::DiffImplementation
features	build/CMakeFiles/feature_tests.c	/^  const char features[] = {"\\n"$/;"	v
features	build/CMakeFiles/feature_tests.cxx	/^  const char features[] = {"\\n"$/;"	v
fib_matrix	symengine/mp_boost.cpp	/^inline two_by_two_matrix fib_matrix(unsigned long n)$/;"	f	namespace:SymEngine
fibonacci	symengine/ntheory.cpp	/^RCP<const Integer> fibonacci(unsigned long n)$/;"	f	namespace:SymEngine
fibonacci2	symengine/ntheory.cpp	/^void fibonacci2(const Ptr<RCP<const Integer>> &g,$/;"	f	namespace:SymEngine
file	symengine/utilities/catch/catch.hpp	/^        char const* file;$/;"	m	struct:Catch::SourceLineInfo
filename	symengine/parser/scannerbase.h	/^inline std::string const &ScannerBase::filename() const$/;"	f	class:SymEngine::std::ScannerBase
filename	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string filename;$/;"	m	struct:__anon22::line_data	file:
filename	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string filename;$/;"	m	struct:__anon22::match_data	file:
filename	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string filename;$/;"	m	struct:__anon43::line_data	file:
filename	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string filename;$/;"	m	struct:__anon43::match_data	file:
final	benchmarks/nonius.h++	/^        struct chronometer_model final : public chronometer_concept {$/;"	s	namespace:nonius::detail
find	symengine/utilities/teuchos/Teuchos_map.hpp	/^    const_iterator find(const key_type& k) const$/;"	f	class:Teuchos::std::map
find	symengine/utilities/teuchos/Teuchos_map.hpp	/^    iterator find(const key_type& k)$/;"	f	class:Teuchos::std::map
find_cf	symengine/polys/uexprpoly.h	/^    Expression find_cf(int deg) const$/;"	f	class:SymEngine::UExprDict
find_cf	symengine/series_flint.h	/^    static inline fmpq_wrapper find_cf(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
find_cf	symengine/series_generic.cpp	/^Expression UnivariateSeries::find_cf(const UExprDict &s, const UExprDict &var,$/;"	f	class:SymEngine::UnivariateSeries
find_cf	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::find_cf(const p_expr &s, const p_expr &var,$/;"	f	class:SymEngine::UPSeriesPiranha
find_cf	symengine/series_piranha.cpp	/^piranha::rational URatPSeriesPiranha::find_cf(const pp_t &s, const pp_t &var,$/;"	f	class:SymEngine::URatPSeriesPiranha
finished	benchmarks/nonius.h++	/^            TimePoint<Clock> finished;$/;"	m	struct:nonius::detail::final
finiteset	symengine/sets.h	/^inline RCP<const Set> finiteset(const set_basic &container)$/;"	f	namespace:SymEngine
fits_slong_p	symengine/mp_wrapper.h	/^    inline int fits_slong_p() const$/;"	f	class:SymEngine::mpz_wrapper
fits_ulong_p	symengine/mp_wrapper.h	/^    inline int fits_ulong_p() const$/;"	f	class:SymEngine::mpz_wrapper
floor	symengine/functions.cpp	/^RCP<const Basic> floor(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
fmod	symengine/mp_boost.cpp	/^integer_class fmod(const integer_class &a, const integer_class &mod)$/;"	f	namespace:SymEngine
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper()$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(const char *cp)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(const fmpq_poly_wrapper &other)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(const fmpq_wrapper &q)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(const mpq_t q)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(const mpz_t z)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(fmpq_poly_wrapper &&other)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper(int i)$/;"	f	class:SymEngine::fmpq_poly_wrapper
fmpq_poly_wrapper	symengine/flint_wrapper.h	/^class fmpq_poly_wrapper$/;"	c	namespace:SymEngine
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper()$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const T i)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const fmpq_t m)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const fmpq_wrapper &other)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const fmpz_t m)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const fmpz_wrapper &n, const fmpz_wrapper &d = 1)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const mpq_t m)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^    fmpq_wrapper(const mpz_t m)$/;"	f	class:SymEngine::fmpq_wrapper
fmpq_wrapper	symengine/flint_wrapper.h	/^class fmpq_wrapper$/;"	c	namespace:SymEngine
fmpqxx2sym	symengine/tests/basic/test_series_expansion_URatF.cpp	/^static RCP<const Number> fmpqxx2sym(const fmpq_wrapper &fc)$/;"	f	file:
fmpz_poly_factor_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_factor_wrapper()$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
fmpz_poly_factor_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_factor_wrapper(const fmpz_poly_factor_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
fmpz_poly_factor_wrapper	symengine/flint_wrapper.h	/^class fmpz_poly_factor_wrapper$/;"	c	namespace:SymEngine
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper()$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper(const char *cp)$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper(const fmpz_poly_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper(const fmpz_wrapper &z)$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper(fmpz_poly_wrapper &&other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper(int i)$/;"	f	class:SymEngine::fmpz_poly_wrapper
fmpz_poly_wrapper	symengine/flint_wrapper.h	/^class fmpz_poly_wrapper$/;"	c	namespace:SymEngine
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper()$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper(const T i)$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper(const fmpz_t m)$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper(const fmpz_wrapper &other)$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper(const mpz_t m)$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^    inline fmpz_wrapper(const std::string &s, unsigned base = 10)$/;"	f	class:SymEngine::fmpz_wrapper
fmpz_wrapper	symengine/flint_wrapper.h	/^class fmpz_wrapper$/;"	c	namespace:SymEngine
fn	symengine/eval_double.cpp	/^typedef std::function<double(const Basic &)> fn;$/;"	t	namespace:SymEngine	file:
fn	symengine/lambda_double.h	/^    typedef std::function<T(const T *x)> fn;$/;"	t	class:SymEngine::LambdaDoubleVisitor
foo	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void Teuchos::ActiveRCPNodesSetup::foo()$/;"	f	class:Teuchos::Teuchos::ActiveRCPNodesSetup
forward_substitution	symengine/dense_matrix.cpp	/^void forward_substitution(const DenseMatrix &A, const DenseMatrix &b,$/;"	f	namespace:SymEngine
fraction_free_LDU	symengine/dense_matrix.cpp	/^void fraction_free_LDU(const DenseMatrix &A, DenseMatrix &L, DenseMatrix &D,$/;"	f	namespace:SymEngine
fraction_free_LU	symengine/dense_matrix.cpp	/^void fraction_free_LU(const DenseMatrix &A, DenseMatrix &LU)$/;"	f	namespace:SymEngine
fraction_free_LU_solve	symengine/dense_matrix.cpp	/^void fraction_free_LU_solve(const DenseMatrix &A, const DenseMatrix &b,$/;"	f	namespace:SymEngine
fraction_free_gauss_jordan_elimination	symengine/dense_matrix.cpp	/^void fraction_free_gauss_jordan_elimination(const DenseMatrix &A,$/;"	f	namespace:SymEngine
fraction_free_gauss_jordan_solve	symengine/dense_matrix.cpp	/^void fraction_free_gauss_jordan_solve(const DenseMatrix &A,$/;"	f	namespace:SymEngine
fraction_free_gaussian_elimination	symengine/dense_matrix.cpp	/^void fraction_free_gaussian_elimination(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
fraction_free_gaussian_elimination_solve	symengine/dense_matrix.cpp	/^void fraction_free_gaussian_elimination_solve(const DenseMatrix &A,$/;"	f	namespace:SymEngine
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr ) { if(ptr) delete [] ptr; }$/;"	f	class:Teuchos::DeallocArrayDelete
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr ) { if(ptr) delete ptr; }$/;"	f	class:Teuchos::DeallocDelete
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr ) { if(ptr) deleteFunctor_(ptr); }$/;"	f	class:Teuchos::DeallocFunctorDelete
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr ) { if(ptr) { T **hdl = &ptr; deleteHandleFunctor_(hdl); } }$/;"	f	class:Teuchos::DeallocFunctorHandleDelete
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr ) { }$/;"	f	class:Teuchos::DeallocNull
free	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void free( T* ptr )$/;"	f	class:Teuchos::EmbeddedObjDealloc
free_symbols	symengine/visitor.cpp	/^set_basic free_symbols(const Basic &b)$/;"	f	namespace:SymEngine
free_symbols	symengine/visitor.cpp	/^set_basic free_symbols(const MatrixBase &m)$/;"	f	namespace:SymEngine
from_basic	symengine/polys/basic_conversions.h	/^RCP<const P> from_basic(const RCP<const Basic> &basic, set_basic &gens,$/;"	f	namespace:SymEngine
from_basic	symengine/polys/basic_conversions.h	/^RCP<const P> from_basic(const RCP<const Basic> &basic,$/;"	f	namespace:SymEngine
from_basic	symengine/polys/basic_conversions.h	/^from_basic(const RCP<const Basic> &basic, bool ex = false)$/;"	f	namespace:SymEngine
from_basic	symengine/polys/basic_conversions.h	/^from_basic(const RCP<const Basic> &basic, bool ex)$/;"	f	namespace:SymEngine
from_container	symengine/polys/msymenginepoly.h	/^    static RCP<const Poly> from_container(const set_basic &vars, Container &&d)$/;"	f	class:SymEngine::MSymEnginePoly
from_container	symengine/polys/upolybase.h	/^    static RCP<const Poly> from_container(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UPolyBase
from_coo	symengine/sparse_matrix.cpp	/^CSRMatrix CSRMatrix::from_coo(unsigned row, unsigned col,$/;"	f	class:SymEngine::CSRMatrix
from_dict	symengine/add.cpp	/^RCP<const Basic> Add::from_dict(const RCP<const Number> &coef,$/;"	f	class:SymEngine::Add
from_dict	symengine/fields.cpp	/^RCP<const GaloisField> GaloisField::from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::GaloisField
from_dict	symengine/mul.cpp	/^RCP<const SymEngine::Basic> Mul::from_dict(const RCP<const Number> &coef,$/;"	f	class:SymEngine::Mul
from_dict	symengine/polys/msymenginepoly.h	/^    static RCP<const Poly> from_dict(const vec_basic &v,$/;"	f	class:SymEngine::MSymEnginePoly
from_dict	symengine/polys/upolybase.h	/^    static RCP<const Poly> from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UExprPolyBase
from_dict	symengine/polys/upolybase.h	/^    static RCP<const Poly> from_dict(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UNonExprPoly
from_direction	symengine/infinity.cpp	/^RCP<const Infty> Infty::from_direction(const RCP<const Number> &direction)$/;"	f	class:SymEngine::Infty
from_int	symengine/infinity.cpp	/^RCP<const Infty> Infty::from_int(const int val)$/;"	f	class:SymEngine::Infty
from_mpq	symengine/complex.cpp	/^RCP<const Number> Complex::from_mpq(const rational_class re,$/;"	f	class:SymEngine::Complex
from_mpq	symengine/rational.cpp	/^RCP<const Number> Rational::from_mpq(const rational_class &i)$/;"	f	class:SymEngine::Rational
from_mpq	symengine/rational.cpp	/^RCP<const Number> Rational::from_mpq(rational_class &&i)$/;"	f	class:SymEngine::Rational
from_poly	symengine/polys/msymenginepoly.h	/^    from_poly(const FromPoly &p)$/;"	f	class:SymEngine::MSymEnginePoly
from_poly	symengine/polys/uintpoly_flint.h	/^    from_poly(const FromPoly &p)$/;"	f	class:SymEngine::UFlintPoly
from_poly	symengine/polys/uintpoly_piranha.h	/^    from_poly(const FromPoly &f)$/;"	f	class:SymEngine::UPiranhaPoly
from_poly	symengine/polys/upolybase.h	/^    static Wrapper from_poly(const FromPoly &p)$/;"	f	class:SymEngine::ODictWrapper
from_poly	symengine/polys/usymenginepoly.h	/^    from_poly(const FromPoly &p)$/;"	f	class:SymEngine::USymEnginePoly
from_two_basic	symengine/functions.cpp	/^RCP<const Beta> Beta::from_two_basic(const RCP<const Basic> &x,$/;"	f	class:SymEngine::Beta
from_two_ints	symengine/rational.cpp	/^RCP<const Number> Rational::from_two_ints(const Integer &n, const Integer &d)$/;"	f	class:SymEngine::Rational
from_two_ints	symengine/rational.cpp	/^RCP<const Number> Rational::from_two_ints(long n, long d)$/;"	f	class:SymEngine::Rational
from_two_nums	symengine/complex.cpp	/^RCP<const Number> Complex::from_two_nums(const Number &re, const Number &im)$/;"	f	class:SymEngine::Complex
from_two_rats	symengine/complex.cpp	/^RCP<const Number> Complex::from_two_rats(const Rational &re, const Rational &im)$/;"	f	class:SymEngine::Complex
from_uintpoly	symengine/fields.cpp	/^RCP<const GaloisField> GaloisField::from_uintpoly(const UIntPoly &a,$/;"	f	class:SymEngine::GaloisField
from_vec	symengine/fields.cpp	/^GaloisField::from_vec(const RCP<const Basic> &var,$/;"	f	class:SymEngine::GaloisField
from_vec	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::from_vec(const std::vector<integer_class> &v,$/;"	f	class:SymEngine::GaloisFieldDict
from_vec	symengine/polys/uintpoly_flint.h	/^    static RCP<const Poly> from_vec(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UFlintPoly
from_vec	symengine/polys/uintpoly_piranha.h	/^    static RCP<const Poly> from_vec(const RCP<const Basic> &var,$/;"	f	class:SymEngine::UPiranhaPoly
from_vec	symengine/polys/upolybase.h	/^    static Wrapper from_vec(const std::vector<Value> &v)$/;"	f	class:SymEngine::ODictWrapper
from_vec	symengine/polys/usymenginepoly.h	/^    static RCP<const Poly> from_vec(const RCP<const Basic> &var,$/;"	f	class:SymEngine::USymEnginePoly
fun	benchmarks/nonius.h++	/^                Fun fun;$/;"	m	struct:nonius::detail::benchmark_function::model
fun	benchmarks/nonius.h++	/^            Fun fun;$/;"	m	struct:nonius::detail::repeater
fun	benchmarks/nonius.h++	/^        detail::benchmark_function fun;$/;"	m	struct:nonius::benchmark
func	symengine/llvm_double.h	/^    intptr_t func;$/;"	m	class:SymEngine::LLVMDoubleVisitor
func_to_argset	symengine/cse.cpp	/^    std::vector<std::set<unsigned>> func_to_argset;$/;"	m	class:SymEngine::FuncArgTracker	file:
function_name	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string function_name;$/;"	m	struct:__anon22::line_data	file:
function_name	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::string function_name;$/;"	m	struct:__anon43::line_data	file:
function_symbol	symengine/functions.cpp	/^RCP<const Basic> function_symbol(std::string name, const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
function_symbol	symengine/functions.cpp	/^RCP<const Basic> function_symbol(std::string name, const vec_basic &arg)$/;"	f	namespace:SymEngine
function_symbol_get_name	symengine/cwrapper.cpp	/^char *function_symbol_get_name(const basic b)$/;"	f
function_symbol_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE function_symbol_set(basic s, const char *c,$/;"	f
functionify	symengine/parser/parser_old.cpp	/^    RCP<const Basic> functionify(unsigned int &iter, const std::string &expr)$/;"	f	class:SymEngine::ExpressionParser	file:
gY_	symengine/solve.cpp	/^    RCP<const Set> gY_;$/;"	m	class:SymEngine::InvertComplexVisitor	file:
gamma	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> gamma(Basic const &aConst) const$/;"	f	class:SymEngine::EvaluateMPC	file:
gamma	symengine/functions.cpp	/^RCP<const Basic> gamma(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
gamma_multiple_2	symengine/functions.cpp	/^RCP<const Basic> gamma_multiple_2(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
gamma_positive_int	symengine/functions.cpp	/^RCP<const Basic> gamma_positive_int(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
gcd	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper gcd(const fmpq_poly_wrapper &other) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
gcd	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper gcd(const fmpz_poly_wrapper &other) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
gcd	symengine/ntheory.cpp	/^RCP<const Integer> gcd(const Integer &a, const Integer &b)$/;"	f	namespace:SymEngine
gcd_ext	symengine/ntheory.cpp	/^void gcd_ext(const Ptr<RCP<const Integer>> &g, const Ptr<RCP<const Integer>> &s,$/;"	f	namespace:SymEngine
gcd_impl	symengine/polys/uintpoly_piranha.h	/^struct gcd_impl<SymEngine::integer_class, SymEngine::integer_class> {$/;"	s	namespace:piranha::math
gcd_impl	symengine/polys/uintpoly_piranha.h	/^struct gcd_impl<SymEngine::rational_class, SymEngine::rational_class> {$/;"	s	namespace:piranha::math
gcd_upoly	symengine/polys/uintpoly_flint.h	/^RCP<const Poly> gcd_upoly(const UFlintPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
gcd_upoly	symengine/polys/uintpoly_piranha.h	/^inline RCP<const UIntPolyPiranha> gcd_upoly(const UIntPolyPiranha &a,$/;"	f	namespace:SymEngine
gcd_upoly	symengine/polys/uintpoly_piranha.h	/^inline RCP<const URatPolyPiranha> gcd_upoly(const URatPolyPiranha &a,$/;"	f	namespace:SymEngine
gen	symengine/polys/basic_conversions.h	/^    RCP<const Basic> gen;$/;"	m	class:SymEngine::BasicToUPolyBase
gen_set	symengine/polys/basic_conversions.cpp	/^    umap_basic_num gen_set;$/;"	m	class:SymEngine::PolyGeneratorVisitor	file:
gen_set	symengine/polys/basic_conversions.cpp	/^    umap_basic_num gen_set;$/;"	m	class:SymEngine::PolyGeneratorVisitorPow	file:
generate_fdiff_weights_vector	symengine/finitediff.cpp	/^vec_basic generate_fdiff_weights_vector(const vec_basic &grid,$/;"	f	namespace:SymEngine
generate_primes	symengine/ntheory.cpp	/^void Sieve::generate_primes(std::vector<unsigned> &primes, unsigned limit)$/;"	f	class:SymEngine::Sieve
gens	symengine/polys/basic_conversions.h	/^    set_basic gens;$/;"	m	class:SymEngine::BasicToMPolyBase
gens_map	symengine/polys/basic_conversions.h	/^    umap_basic_uint gens_map;$/;"	m	class:SymEngine::BasicToMPolyBase
gens_pow	symengine/polys/basic_conversions.h	/^        gens_pow;$/;"	m	class:SymEngine::BasicToMPolyBase
get	build/cmake/checkcxx11.cpp	/^    T* get() const { return ptr_; }$/;"	f	class:RCP
get	build/cmake/checkcxx11.cpp	/^    inline T* get() const { return ptr_; }$/;"	f	class:Ptr
get	cmake/checkcxx11.cpp	/^    T* get() const { return ptr_; }$/;"	f	class:RCP
get	cmake/checkcxx11.cpp	/^    inline T* get() const { return ptr_; }$/;"	f	class:Ptr
get	symengine/dense_matrix.cpp	/^RCP<const Basic> DenseMatrix::get(unsigned i, unsigned j) const$/;"	f	class:SymEngine::DenseMatrix
get	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type &Base::get()$/;"	f	class:SymEngine::Meta__::Base
get	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type &SType::get()$/;"	f	class:SymEngine::Meta__::SType
get	symengine/parser/parserbase.h	/^inline typename TypeOf<tg_>::type const &Base::get() const$/;"	f	class:SymEngine::Meta__::TypeOf::Base
get	symengine/parser/scanner.cpp	/^size_t ScannerBase::Input::get()$/;"	f	class:SymEngine::ScannerBase::Input
get	symengine/sparse_matrix.cpp	/^RCP<const Basic> CSRMatrix::get(unsigned i, unsigned j) const$/;"	f	class:SymEngine::CSRMatrix
get	symengine/symengine_rcp.h	/^    T *get() const$/;"	f	class:SymEngine::RCP
get	symengine/symengine_rcp.h	/^    inline T *get() const$/;"	f	class:SymEngine::Ptr
get	symengine/utilities/catch/catch.hpp	/^        T* get() const{ return m_p; }$/;"	f	class:Catch::Ptr
get	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^T* Ptr<T>::get() const$/;"	f	class:Teuchos::Ptr
get	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T* RCP<T>::get() const$/;"	f	class:Teuchos::RCP
get	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNode* get() const$/;"	f	class:Teuchos::RCPNodeThrowDeleter
getActiveRCPNodeHeaderString	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^std::string RCPNodeTracer::getActiveRCPNodeHeaderString()$/;"	f	class:Teuchos::RCPNodeTracer
getBaseObjVoidPtr	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^  static const void* getBaseObjVoidPtr(T *p)$/;"	f	class:Teuchos::GetBaseObjVoidPtrImpl
getBaseObjVoidPtr	symengine/utilities/teuchos/Teuchos_getBaseObjVoidPtr.hpp	/^const void* getBaseObjVoidPtr(T *p)$/;"	f	namespace:Teuchos
getCommonDebugNotesString	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^std::string RCPNodeTracer::getCommonDebugNotesString()$/;"	f	class:Teuchos::RCPNodeTracer
getConst	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<const T> Ptr<T>::getConst() const$/;"	f	class:Teuchos::Ptr
getConst	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<const T> RCP<T>::getConst() const$/;"	f	class:Teuchos::RCP
getEmbeddedObj	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const Embedded& Teuchos::getEmbeddedObj( const RCP<T>& p )$/;"	f	class:Teuchos
getExistingRCPNode	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  static RCPNode* getExistingRCPNode(T *p)$/;"	f	class:Teuchos::RCPNodeTracer
getExistingRCPNodeGivenLookupKey	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^RCPNode* RCPNodeTracer::getExistingRCPNodeGivenLookupKey(const void* p)$/;"	f	class:Teuchos::RCPNodeTracer
getInput	symengine/parser/scannerbase.h	/^inline size_t ScannerBase::getInput()$/;"	f	class:SymEngine::ScannerBase
getInstance	symengine/sets.cpp	/^const RCP<const EmptySet> &EmptySet::getInstance()$/;"	f	class:SymEngine::EmptySet
getInstance	symengine/sets.cpp	/^const RCP<const UniversalSet> &UniversalSet::getInstance()$/;"	f	class:SymEngine::UniversalSet
getInvertedObjOwnershipParent	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::getInvertedObjOwnershipParent(const RCP<T> &invertedChild)$/;"	f	class:Teuchos
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsEqualTo>             { static const char* getName(){ return "=="; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThan>         { static const char* getName(){ return ">"; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsGreaterThanOrEqualTo>{ static const char* getName(){ return ">="; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsLessThan>            { static const char* getName(){ return "<"; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsLessThanOrEqualTo>   { static const char* getName(){ return "<="; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<> struct OperatorTraits<IsNotEqualTo>          { static const char* getName(){ return "!="; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getName	symengine/utilities/catch/catch.hpp	/^    template<Operator Op> struct OperatorTraits             { static const char* getName(){ return "*error*"; } };$/;"	f	struct:Catch::Internal::OperatorTraits
getNonconstEmbeddedObj	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Embedded& Teuchos::getNonconstEmbeddedObj( const RCP<T>& p )$/;"	f	class:Teuchos
getNonconstObj	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  Embedded& getNonconstObj() { return embedded_; }$/;"	f	class:Teuchos::EmbeddedObjDealloc
getNull	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^  static Iter getNull()$/;"	f	class:Teuchos::NullIteratorTraits
getNull	symengine/utilities/teuchos/Teuchos_NullIteratorTraits.hpp	/^  static std::reverse_iterator<Iter> getNull()$/;"	f	class:Teuchos::NullIteratorTraits
getNull	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  static RCP<T> getNull() { return null; }$/;"	f	class:Teuchos::NullIteratorTraits
getObj	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  const Embedded& getObj() const { return embedded_; }$/;"	f	class:Teuchos::EmbeddedObjDealloc
getOptionalEmbeddedObj	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::getOptionalEmbeddedObj( const RCP<T>& p )$/;"	f	class:Teuchos
getOptionalNonconstEmbeddedObj	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::getOptionalNonconstEmbeddedObj( const RCP<T>& p )$/;"	f	class:Teuchos
getPrecedence	symengine/printers/strprinter.cpp	/^PrecedenceEnum Precedence::getPrecedence(const RCP<const Basic> &x)$/;"	f	class:SymEngine::Precedence
getPrintRCPNodeStatisticsOnExit	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool RCPNodeTracer::getPrintRCPNodeStatisticsOnExit()$/;"	f	class:Teuchos::RCPNodeTracer
getRCPNodeBaseObjMapKeyVoidPtr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  static const void* getRCPNodeBaseObjMapKeyVoidPtr(T *p)$/;"	f	class:Teuchos::RCPNodeTracer
getRCPNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^RCPNodeTracer::getRCPNodeStatistics()$/;"	f	class:Teuchos::RCPNodeTracer
getRange__	symengine/parser/scanner.cpp	/^size_t ScannerBase::getRange__(int ch) \/\/ using int to prevent casts$/;"	f	class:SymEngine::ScannerBase
getRawPtr	build/cmake/checkcxx11.cpp	/^    inline T* getRawPtr() const { return get(); }$/;"	f	class:Ptr
getRawPtr	cmake/checkcxx11.cpp	/^    inline T* getRawPtr() const { return get(); }$/;"	f	class:Ptr
getRawPtr	symengine/symengine_rcp.h	/^    inline T *getRawPtr() const$/;"	f	class:SymEngine::Ptr
getRawPtr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^T* Ptr<T>::getRawPtr() const$/;"	f	class:Teuchos::Ptr
getRawPtr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T* RCP<T>::getRawPtr() const$/;"	f	class:Teuchos::RCP
get__	symengine/parser/scannerbase.h	/^inline size_t ScannerBase::get__()$/;"	f	class:SymEngine::ScannerBase
get_a	symengine/functions.h	/^    inline RCP<const Basic> get_a() const$/;"	f	class:SymEngine::Zeta
get_address	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma get_address(int i) const {$/;"	f	class:__anon22::StacktraceAddresses
get_address	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  bfd_vma get_address(int i) const {$/;"	f	class:__anon43::StacktraceAddresses
get_arg	symengine/functions.h	/^    inline RCP<const Basic> get_arg() const$/;"	f	class:SymEngine::Derivative
get_arg	symengine/functions.h	/^    inline RCP<const Basic> get_arg() const$/;"	f	class:SymEngine::OneArgFunction
get_arg	symengine/functions.h	/^    inline const RCP<const Basic> &get_arg() const$/;"	f	class:SymEngine::Subs
get_arg	symengine/logic.cpp	/^RCP<const Boolean> Not::get_arg() const$/;"	f	class:SymEngine::Not
get_arg1	symengine/functions.h	/^    inline RCP<const Basic> get_arg1() const$/;"	f	class:SymEngine::TwoArgBasic
get_arg2	symengine/functions.h	/^    inline RCP<const Basic> get_arg2() const$/;"	f	class:SymEngine::TwoArgBasic
get_args	symengine/add.cpp	/^vec_basic Add::get_args() const$/;"	f	class:SymEngine::Add
get_args	symengine/constants.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Constant
get_args	symengine/fields.cpp	/^vec_basic GaloisField::get_args() const$/;"	f	class:SymEngine::GaloisField
get_args	symengine/functions.cpp	/^vec_basic Subs::get_args() const$/;"	f	class:SymEngine::Subs
get_args	symengine/functions.h	/^    virtual inline vec_basic get_args() const$/;"	f	class:SymEngine::MultiArgFunction
get_args	symengine/functions.h	/^    virtual inline vec_basic get_args() const$/;"	f	class:SymEngine::OneArgFunction
get_args	symengine/functions.h	/^    virtual inline vec_basic get_args() const$/;"	f	class:SymEngine::TwoArgBasic
get_args	symengine/functions.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Derivative
get_args	symengine/infinity.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Infty
get_args	symengine/logic.cpp	/^vec_basic And::get_args() const$/;"	f	class:SymEngine::And
get_args	symengine/logic.cpp	/^vec_basic BooleanAtom::get_args() const$/;"	f	class:SymEngine::BooleanAtom
get_args	symengine/logic.cpp	/^vec_basic Contains::get_args() const$/;"	f	class:SymEngine::Contains
get_args	symengine/logic.cpp	/^vec_basic Not::get_args() const$/;"	f	class:SymEngine::Not
get_args	symengine/logic.cpp	/^vec_basic Or::get_args() const$/;"	f	class:SymEngine::Or
get_args	symengine/logic.cpp	/^vec_basic Piecewise::get_args() const$/;"	f	class:SymEngine::Piecewise
get_args	symengine/logic.cpp	/^vec_basic Xor::get_args() const$/;"	f	class:SymEngine::Xor
get_args	symengine/mul.cpp	/^vec_basic Mul::get_args() const$/;"	f	class:SymEngine::Mul
get_args	symengine/number.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Number
get_args	symengine/polys/msymenginepoly.h	/^    inline vec_basic get_args() const$/;"	f	class:SymEngine::MSymEnginePoly
get_args	symengine/polys/upolybase.h	/^    inline vec_basic get_args() const$/;"	f	class:SymEngine::UPolyBase
get_args	symengine/pow.cpp	/^vec_basic Pow::get_args() const$/;"	f	class:SymEngine::Pow
get_args	symengine/sets.cpp	/^vec_basic Interval::get_args() const$/;"	f	class:SymEngine::Interval
get_args	symengine/sets.cpp	/^vec_basic Union::get_args() const$/;"	f	class:SymEngine::Union
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Complement
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::ConditionSet
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::EmptySet
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::FiniteSet
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::ImageSet
get_args	symengine/sets.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::UniversalSet
get_args	symengine/symbol.h	/^    virtual vec_basic get_args() const$/;"	f	class:SymEngine::Symbol
get_args_in_value_order	symengine/cse.cpp	/^    vec_basic get_args_in_value_order(Container &argset)$/;"	f	class:SymEngine::FuncArgTracker
get_base	symengine/pow.h	/^    inline RCP<const Basic> get_base() const$/;"	f	class:SymEngine::Pow
get_base_obj_map_key_void_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const void* get_base_obj_map_key_void_ptr() const$/;"	f	class:Teuchos::RCPNodeHandle
get_base_obj_map_key_void_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const void* get_base_obj_map_key_void_ptr() const$/;"	f	class:Teuchos::RCPNodeTmpl
get_base_obj_type_name	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const std::string get_base_obj_type_name() const$/;"	f	class:Teuchos::RCPNodeTmpl
get_baseset	symengine/sets.h	/^    inline const RCP<const Set> &get_baseset() const$/;"	f	class:SymEngine::ImageSet
get_basic	symengine/expression.h	/^    const RCP<const Basic> &get_basic() const$/;"	f	class:SymEngine::Expression
get_basic	symengine/polys/uexprpoly.h	/^    const RCP<const Basic> get_basic(std::string var) const$/;"	f	class:SymEngine::UExprDict
get_children	benchmarks/nonius.h++	/^    inline token_vector & Token::get_children()$/;"	f	class:cpptempl::Token
get_children	benchmarks/nonius.h++	/^    inline token_vector & TokenFor::get_children()$/;"	f	class:cpptempl::TokenFor
get_children	benchmarks/nonius.h++	/^    inline token_vector & TokenIf::get_children()$/;"	f	class:cpptempl::TokenIf
get_coef	symengine/add.h	/^    inline const RCP<const Number> &get_coef() const$/;"	f	class:SymEngine::Add
get_coef	symengine/mul.h	/^    inline const RCP<const Number> &get_coef() const$/;"	f	class:SymEngine::Mul
get_coeff	symengine/fields.h	/^    inline integer_class get_coeff(unsigned int x) const$/;"	f	class:SymEngine::GaloisField
get_coeff	symengine/fields.h	/^    integer_class get_coeff(unsigned int x) const$/;"	f	class:SymEngine::GaloisFieldDict
get_coeff	symengine/flint_wrapper.h	/^    fmpq_wrapper get_coeff(unsigned int deg) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
get_coeff	symengine/flint_wrapper.h	/^    fmpz_wrapper get_coeff(unsigned int n) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
get_coeff	symengine/polys/msymenginepoly.h	/^    Value get_coeff(Vec &x) const$/;"	f	class:SymEngine::UDictWrapper
get_coeff	symengine/polys/uintpoly_flint.h	/^    Cf get_coeff(unsigned int x) const$/;"	f	class:SymEngine::UFlintPoly
get_coeff	symengine/polys/uintpoly_piranha.h	/^    Cf get_coeff(unsigned int x) const$/;"	f	class:SymEngine::UPiranhaPoly
get_coeff	symengine/polys/upolybase.h	/^    Value get_coeff(Key x) const$/;"	f	class:SymEngine::ODictWrapper
get_coeff	symengine/polys/usymenginepoly.h	/^    inline Cf get_coeff(Key x) const$/;"	f	class:SymEngine::USymEnginePoly
get_coeff	symengine/series_flint.cpp	/^RCP<const Basic> URatPSeriesFlint::get_coeff(int n) const$/;"	f	class:SymEngine::URatPSeriesFlint
get_coeff	symengine/series_generic.cpp	/^RCP<const Basic> UnivariateSeries::get_coeff(int deg) const$/;"	f	class:SymEngine::UnivariateSeries
get_coeff	symengine/series_piranha.cpp	/^RCP<const Basic> UPSeriesPiranha::get_coeff(int i) const$/;"	f	class:SymEngine::UPSeriesPiranha
get_coeff	symengine/series_piranha.cpp	/^RCP<const Basic> URatPSeriesPiranha::get_coeff(int i) const$/;"	f	class:SymEngine::URatPSeriesPiranha
get_coeff_basic	symengine/solve.cpp	/^inline RCP<const Basic> get_coeff_basic(const Expression &i)$/;"	f	namespace:SymEngine
get_coeff_basic	symengine/solve.cpp	/^inline RCP<const Basic> get_coeff_basic(const integer_class &i)$/;"	f	namespace:SymEngine
get_coeff_ref	symengine/polys/uintpoly_flint.h	/^    Cf get_coeff_ref(unsigned int x) const$/;"	f	class:SymEngine::UFlintPoly
get_coeff_ref	symengine/polys/uintpoly_piranha.h	/^    const Cf &get_coeff_ref(unsigned int x) const$/;"	f	class:SymEngine::UPiranhaPoly
get_common_arg_candidates	symengine/cse.cpp	/^    get_common_arg_candidates(std::set<unsigned> &argset, unsigned min_func_i)$/;"	f	class:SymEngine::FuncArgTracker
get_condition	symengine/sets.h	/^    inline const RCP<const Boolean> &get_condition() const$/;"	f	class:SymEngine::ConditionSet
get_container	symengine/logic.cpp	/^const set_boolean &And::get_container() const$/;"	f	class:SymEngine::And
get_container	symengine/logic.cpp	/^const set_boolean &Or::get_container() const$/;"	f	class:SymEngine::Or
get_container	symengine/logic.cpp	/^const vec_boolean &Xor::get_container() const$/;"	f	class:SymEngine::Xor
get_container	symengine/sets.h	/^    inline const RCP<const Set> &get_container() const$/;"	f	class:SymEngine::Complement
get_container	symengine/sets.h	/^    inline const set_basic &get_container() const$/;"	f	class:SymEngine::FiniteSet
get_container	symengine/sets.h	/^    inline const set_set &get_container() const$/;"	f	class:SymEngine::Union
get_d	symengine/mp_wrapper.h	/^    double get_d() const$/;"	f	class:SymEngine::mpq_wrapper
get_d	symengine/mp_wrapper.h	/^    inline double long get_d() const$/;"	f	class:SymEngine::mpz_wrapper
get_dealloc	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const Dealloc_T& Teuchos::get_dealloc( const RCP<T>& p )$/;"	f	class:Teuchos
get_dealloc	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const Dealloc_T& get_dealloc() const$/;"	f	class:Teuchos::RCPNodeTmpl
get_degree	symengine/polys/upolybase.h	/^    inline int get_degree() const$/;"	f	class:SymEngine::UExprPolyBase
get_degree	symengine/polys/upolybase.h	/^    inline int get_degree() const$/;"	f	class:SymEngine::UNonExprPoly
get_degree	symengine/series.h	/^    inline virtual unsigned get_degree() const$/;"	f	class:SymEngine::SeriesBase
get_den	symengine/flint_wrapper.h	/^    const fmpz_wrapper &get_den() const$/;"	f	class:SymEngine::fmpq_wrapper
get_den	symengine/flint_wrapper.h	/^    fmpz_wrapper &get_den()$/;"	f	class:SymEngine::fmpq_wrapper
get_den	symengine/functions.h	/^    inline RCP<const Basic> get_den() const$/;"	f	class:SymEngine::ATan2
get_den	symengine/mp_class.h	/^inline const integer_class &get_den(const rational_class &i)$/;"	f	namespace:SymEngine
get_den	symengine/mp_class.h	/^inline integer_class &get_den(rational_class &i)$/;"	f	namespace:SymEngine
get_den	symengine/mp_wrapper.h	/^    const mpz_wrapper &get_den() const$/;"	f	class:SymEngine::mpq_wrapper
get_den	symengine/mp_wrapper.h	/^    mpz_wrapper &get_den()$/;"	f	class:SymEngine::mpq_wrapper
get_den	symengine/rational.h	/^    RCP<const Integer> get_den() const$/;"	f	class:SymEngine::Rational
get_dict	symengine/add.h	/^    inline const umap_basic_num &get_dict() const$/;"	f	class:SymEngine::Add
get_dict	symengine/fields.h	/^    const std::vector<integer_class> &get_dict() const$/;"	f	class:SymEngine::GaloisFieldDict
get_dict	symengine/fields.h	/^    inline const std::vector<integer_class> &get_dict() const$/;"	f	class:SymEngine::GaloisField
get_dict	symengine/functions.h	/^    inline const map_basic_basic &get_dict() const$/;"	f	class:SymEngine::Subs
get_dict	symengine/mul.h	/^    inline const map_basic_basic &get_dict() const$/;"	f	class:SymEngine::Mul
get_dict	symengine/polys/msymenginepoly.h	/^    const Dict &get_dict() const$/;"	f	class:SymEngine::UDictWrapper
get_dict	symengine/polys/upolybase.h	/^    const std::map<Key, Value> &get_dict() const$/;"	f	class:SymEngine::ODictWrapper
get_dict	symengine/polys/usymenginepoly.h	/^    inline const std::map<Key, Cf> &get_dict() const$/;"	f	class:SymEngine::USymEnginePoly
get_direction	symengine/infinity.h	/^    inline RCP<const Number> get_direction() const$/;"	f	class:SymEngine::Infty
get_double_intrinsic	symengine/llvm_double.cpp	/^llvm::Function *get_double_intrinsic(llvm::Intrinsic::ID id, unsigned n,$/;"	f	namespace:SymEngine
get_dummy	symengine/derivative.cpp	/^    static inline RCP<const Symbol> get_dummy(const Basic &b, std::string name)$/;"	f	class:SymEngine::DiffImplementation
get_end	symengine/sets.h	/^    inline const RCP<const Number> &get_end() const$/;"	f	class:SymEngine::Interval
get_eval	symengine/complex_mpc.cpp	/^Evaluate &ComplexMPC::get_eval() const$/;"	f	class:SymEngine::ComplexMPC
get_eval	symengine/infinity.cpp	/^Evaluate &Infty::get_eval() const$/;"	f	class:SymEngine::Infty
get_eval	symengine/nan.cpp	/^Evaluate &NaN::get_eval() const$/;"	f	class:SymEngine::NaN
get_eval	symengine/number.h	/^    virtual Evaluate &get_eval() const$/;"	f	class:SymEngine::Number
get_eval	symengine/real_double.cpp	/^Evaluate &ComplexDouble::get_eval() const$/;"	f	class:SymEngine::ComplexDouble
get_eval	symengine/real_double.cpp	/^Evaluate &RealDouble::get_eval() const$/;"	f	class:SymEngine::RealDouble
get_eval	symengine/real_mpfr.cpp	/^Evaluate &RealMPFR::get_eval() const$/;"	f	class:SymEngine::RealMPFR
get_eval_double_expression	benchmarks/bench_eval_double.cpp	/^RCP<const Basic> get_eval_double_expression()$/;"	f
get_exp	symengine/pow.h	/^    inline RCP<const Basic> get_exp() const$/;"	f	class:SymEngine::Pow
get_expr	symengine/logic.cpp	/^RCP<const Basic> Contains::get_expr() const$/;"	f	class:SymEngine::Contains
get_expr	symengine/sets.h	/^    inline const RCP<const Basic> &get_expr() const$/;"	f	class:SymEngine::ImageSet
get_external_function	symengine/llvm_double.cpp	/^LLVMDoubleVisitor::get_external_function(const std::string &name)$/;"	f	class:SymEngine::LLVMDoubleVisitor
get_extra_data	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^const T1& Teuchos::get_extra_data( const RCP<T2>& p, const std::string& name )$/;"	f	class:Teuchos
get_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^any& RCPNode::get_extra_data( const std::string& type_name, const std::string& name )$/;"	f	class:Teuchos::RCPNode
get_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  any& get_extra_data( const std::string& type_name,$/;"	f	class:Teuchos::RCPNodeHandle
get_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const any& get_extra_data( const std::string& type_name,$/;"	f	class:Teuchos::RCPNode
get_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const any& get_extra_data( const std::string& type_name,$/;"	f	class:Teuchos::RCPNodeHandle
get_fmpq_poly_t	symengine/flint_wrapper.h	/^    const fmpq_poly_t *get_fmpq_poly_t() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
get_fmpq_poly_t	symengine/flint_wrapper.h	/^    fmpq_poly_t *get_fmpq_poly_t()$/;"	f	class:SymEngine::fmpq_poly_wrapper
get_fmpq_t	symengine/flint_wrapper.h	/^    const fmpq *get_fmpq_t() const$/;"	f	class:SymEngine::fmpq_wrapper
get_fmpq_t	symengine/flint_wrapper.h	/^    fmpq *get_fmpq_t()$/;"	f	class:SymEngine::fmpq_wrapper
get_fmpz_poly_factor_t	symengine/flint_wrapper.h	/^    const fmpz_poly_factor_t &get_fmpz_poly_factor_t() const$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
get_fmpz_poly_factor_t	symengine/flint_wrapper.h	/^    fmpz_poly_factor_t &get_fmpz_poly_factor_t()$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
get_fmpz_poly_t	symengine/flint_wrapper.h	/^    const fmpz_poly_t *get_fmpz_poly_t() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
get_fmpz_poly_t	symengine/flint_wrapper.h	/^    fmpz_poly_t *get_fmpz_poly_t()$/;"	f	class:SymEngine::fmpz_poly_wrapper
get_fmpz_t	symengine/flint_wrapper.h	/^    inline const fmpz *get_fmpz_t() const$/;"	f	class:SymEngine::fmpz_wrapper
get_fmpz_t	symengine/flint_wrapper.h	/^    inline fmpz *get_fmpz_t()$/;"	f	class:SymEngine::fmpz_wrapper
get_function_type	symengine/llvm_double.cpp	/^llvm::Function *LLVMDoubleVisitor::get_function_type(llvm::LLVMContext *context)$/;"	f	class:SymEngine::LLVMDoubleVisitor
get_impl_stacktrace_depth	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int get_impl_stacktrace_depth() const {$/;"	f	class:__anon22::StacktraceAddresses
get_impl_stacktrace_depth	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int get_impl_stacktrace_depth() const {$/;"	f	class:__anon43::StacktraceAddresses
get_index	symengine/symbol.h	/^    size_t get_index() const$/;"	f	class:SymEngine::Dummy
get_lc	symengine/polys/upolybase.h	/^    Cf get_lc() const$/;"	f	class:SymEngine::UNonExprPoly
get_lc	symengine/polys/upolybase.h	/^    Value get_lc() const$/;"	f	class:SymEngine::ODictWrapper
get_left_open	symengine/sets.h	/^    inline const bool &get_left_open() const$/;"	f	class:SymEngine::Interval
get_magnitude	benchmarks/nonius.h++	/^        inline double get_magnitude(fp_seconds secs) {$/;"	f	namespace:nonius::detail
get_map_key_void_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^const void* get_map_key_void_ptr(const Teuchos::RCPNode* rcp_node)$/;"	f	namespace:__anon20
get_map_key_void_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^const void* get_map_key_void_ptr(const Teuchos::RCPNode* rcp_node)$/;"	f	namespace:__anon41
get_max_width	benchmarks/nonius.h++	/^        int get_max_width(Iterator first, Iterator last, Projection proj) {$/;"	f	namespace:nonius::detail
get_mpc_t	symengine/complex_mpc.h	/^    mpc_ptr get_mpc_t()$/;"	f	class:SymEngine::mpc_class
get_mpc_t	symengine/complex_mpc.h	/^    mpc_srcptr get_mpc_t() const$/;"	f	class:SymEngine::mpc_class
get_mpfr_t	symengine/real_mpfr.h	/^    mpfr_ptr get_mpfr_t()$/;"	f	class:SymEngine::mpfr_class
get_mpfr_t	symengine/real_mpfr.h	/^    mpfr_srcptr get_mpfr_t() const$/;"	f	class:SymEngine::mpfr_class
get_mpq_t	symengine/mp_class.h	/^inline auto get_mp_t(const rational_class &x) -> decltype(get_mpq_t(x))$/;"	f	namespace:SymEngine
get_mpq_t	symengine/mp_class.h	/^inline mpq_srcptr get_mpq_t(const rational_class &i)$/;"	f	namespace:SymEngine
get_mpq_t	symengine/mp_wrapper.h	/^    mpq_ptr get_mpq_t()$/;"	f	class:SymEngine::mpq_wrapper
get_mpq_t	symengine/mp_wrapper.h	/^    mpq_srcptr get_mpq_t() const$/;"	f	class:SymEngine::mpq_wrapper
get_mpz_t	symengine/mp_class.h	/^inline auto get_mp_t(const integer_class &x) -> decltype(get_mpz_t(x))$/;"	f	namespace:SymEngine
get_mpz_t	symengine/mp_class.h	/^inline mpz_ptr get_mpz_t(integer_class &i)$/;"	f	namespace:SymEngine
get_mpz_t	symengine/mp_class.h	/^inline mpz_srcptr get_mpz_t(const integer_class &i)$/;"	f	namespace:SymEngine
get_mpz_t	symengine/mp_wrapper.h	/^    inline mpz_ptr get_mpz_t()$/;"	f	class:SymEngine::mpz_wrapper
get_mpz_t	symengine/mp_wrapper.h	/^    inline mpz_srcptr get_mpz_t() const$/;"	f	class:SymEngine::mpz_wrapper
get_name	symengine/constants.h	/^    inline std::string get_name() const$/;"	f	class:SymEngine::Constant
get_name	symengine/functions.h	/^    inline const std::string &get_name() const$/;"	f	class:SymEngine::FunctionSymbol
get_name	symengine/symbol.h	/^    inline const std::string &get_name() const$/;"	f	class:SymEngine::Symbol
get_nonconst_dealloc	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Dealloc_T& Teuchos::get_nonconst_dealloc( const RCP<T>& p )$/;"	f	class:Teuchos
get_nonconst_dealloc	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  Dealloc_T& get_nonconst_dealloc()$/;"	f	class:Teuchos::RCPNodeTmpl
get_nonconst_extra_data	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T1& Teuchos::get_nonconst_extra_data( RCP<T2>& p, const std::string& name )$/;"	f	class:Teuchos
get_num	symengine/flint_wrapper.h	/^    const fmpz_wrapper &get_num() const$/;"	f	class:SymEngine::fmpq_wrapper
get_num	symengine/flint_wrapper.h	/^    fmpz_wrapper &get_num()$/;"	f	class:SymEngine::fmpq_wrapper
get_num	symengine/functions.h	/^    inline RCP<const Basic> get_num() const$/;"	f	class:SymEngine::ATan2
get_num	symengine/mp_class.h	/^inline const integer_class &get_num(const rational_class &i)$/;"	f	namespace:SymEngine
get_num	symengine/mp_class.h	/^inline integer_class &get_num(rational_class &i)$/;"	f	namespace:SymEngine
get_num	symengine/mp_wrapper.h	/^    const mpz_wrapper &get_num() const$/;"	f	class:SymEngine::mpq_wrapper
get_num	symengine/mp_wrapper.h	/^    mpz_wrapper &get_num()$/;"	f	class:SymEngine::mpq_wrapper
get_num	symengine/rational.h	/^    RCP<const Integer> get_num() const$/;"	f	class:SymEngine::Rational
get_num_den	symengine/rational.cpp	/^void get_num_den(const Rational &rat, const Ptr<RCP<const Integer>> &num,$/;"	f	namespace:SymEngine
get_optional_dealloc	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::get_optional_dealloc( const RCP<T>& p )$/;"	f	class:Teuchos
get_optional_extra_data	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::get_optional_extra_data( const RCP<T2>& p, const std::string& name )$/;"	f	class:Teuchos
get_optional_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^any* RCPNode::get_optional_extra_data( const std::string& type_name,$/;"	f	class:Teuchos::RCPNode
get_optional_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  any* get_optional_extra_data($/;"	f	class:Teuchos::RCPNodeHandle
get_optional_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const any* get_optional_extra_data($/;"	f	class:Teuchos::RCPNode
get_optional_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  const any* get_optional_extra_data($/;"	f	class:Teuchos::RCPNodeHandle
get_optional_nonconst_dealloc	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::get_optional_nonconst_dealloc( const RCP<T>& p )$/;"	f	class:Teuchos
get_optional_nonconst_extra_data	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::get_optional_nonconst_extra_data( RCP<T2>& p, const std::string& name )$/;"	f	class:Teuchos
get_or_add_value_number	symengine/cse.cpp	/^    unsigned get_or_add_value_number(RCP<const Basic> value)$/;"	f	class:SymEngine::FuncArgTracker
get_pi_shift	symengine/functions.cpp	/^bool get_pi_shift(const RCP<const Basic> &arg, const Ptr<RCP<const Number>> &n,$/;"	f	namespace:SymEngine
get_point	symengine/functions.cpp	/^vec_basic Subs::get_point() const$/;"	f	class:SymEngine::Subs
get_poly	symengine/polys/msymenginepoly.h	/^    inline const Container &get_poly() const$/;"	f	class:SymEngine::MSymEnginePoly
get_poly	symengine/polys/upolybase.h	/^    inline const Container &get_poly() const$/;"	f	class:SymEngine::UPolyBase
get_poly	symengine/series.h	/^    inline const Poly &get_poly() const$/;"	f	class:SymEngine::SeriesBase
get_powi	symengine/llvm_double.cpp	/^llvm::Function *LLVMDoubleVisitor::get_powi()$/;"	f	class:SymEngine::LLVMDoubleVisitor
get_prec	symengine/complex_mpc.h	/^    inline mpfr_prec_t get_prec() const$/;"	f	class:SymEngine::ComplexMPC
get_prec	symengine/complex_mpc.h	/^    mpfr_prec_t get_prec() const$/;"	f	class:SymEngine::mpc_class
get_prec	symengine/real_mpfr.h	/^    inline mpfr_prec_t get_prec() const$/;"	f	class:SymEngine::RealMPFR
get_prec	symengine/real_mpfr.h	/^    mpfr_prec_t get_prec() const$/;"	f	class:SymEngine::mpfr_class
get_right_open	symengine/sets.h	/^    inline const bool &get_right_open() const$/;"	f	class:SymEngine::Interval
get_s	symengine/functions.h	/^    inline RCP<const Basic> get_s() const$/;"	f	class:SymEngine::Dirichlet_eta
get_s	symengine/functions.h	/^    inline RCP<const Basic> get_s() const$/;"	f	class:SymEngine::Zeta
get_set	symengine/logic.cpp	/^RCP<const Set> Contains::get_set() const$/;"	f	class:SymEngine::Contains
get_set_from_vec	symengine/solve.cpp	/^set_basic get_set_from_vec(const vec_sym &syms)$/;"	f	namespace:SymEngine
get_si	symengine/mp_wrapper.h	/^    inline signed long get_si() const$/;"	f	class:SymEngine::mpz_wrapper
get_size	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int get_size() const {$/;"	f	class:__anon22::StacktraceAddresses
get_size	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int get_size() const {$/;"	f	class:__anon43::StacktraceAddresses
get_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string Teuchos::get_stacktrace(int impl_stacktrace_depth)$/;"	f	class:Teuchos
get_stacktrace_addresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^RCP<StacktraceAddresses> get_stacktrace_addresses(int impl_stacktrace_depth)$/;"	f	namespace:__anon22
get_stacktrace_addresses	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^RCP<StacktraceAddresses> get_stacktrace_addresses(int impl_stacktrace_depth)$/;"	f	namespace:__anon43
get_start	symengine/sets.h	/^    inline const RCP<const Number> &get_start() const$/;"	f	class:SymEngine::Interval
get_stored_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string Teuchos::get_stored_stacktrace()$/;"	f	class:Teuchos
get_string	symengine/parser/parser_old.cpp	/^    std::string get_string(int start, int end)$/;"	f	class:SymEngine::ExpressionParser	file:
get_subset_candidates	symengine/cse.cpp	/^    get_subset_candidates(const Container1 &argset,$/;"	f	class:SymEngine::FuncArgTracker
get_symbol	symengine/sets.h	/^    inline const RCP<const Basic> &get_symbol() const$/;"	f	class:SymEngine::ConditionSet
get_symbol	symengine/sets.h	/^    inline const RCP<const Basic> &get_symbol() const$/;"	f	class:SymEngine::ImageSet
get_symbols	symengine/functions.h	/^    inline const multiset_basic &get_symbols() const$/;"	f	class:SymEngine::Derivative
get_translated_container	symengine/polys/msymenginepoly.h	/^set_basic get_translated_container(Container &x, Container &y, const Poly &a,$/;"	f	namespace:SymEngine
get_type_code	symengine/basic.h	/^    inline TypeID get_type_code() const$/;"	f	class:SymEngine::Basic
get_ui	symengine/mp_wrapper.h	/^    inline unsigned long get_ui() const$/;"	f	class:SymEngine::mpz_wrapper
get_universe	symengine/sets.h	/^    inline const RCP<const Set> &get_universe() const$/;"	f	class:SymEngine::Complement
get_val	symengine/logic.cpp	/^bool BooleanAtom::get_val() const$/;"	f	class:SymEngine::BooleanAtom
get_var	symengine/polys/upolybase.h	/^    inline const RCP<const Basic> &get_var() const$/;"	f	class:SymEngine::UPolyBase
get_var	symengine/series.h	/^    inline virtual const std::string &get_var() const$/;"	f	class:SymEngine::SeriesBase
get_variables	symengine/functions.cpp	/^vec_basic Subs::get_variables() const$/;"	f	class:SymEngine::Subs
get_vars	symengine/polys/msymenginepoly.h	/^    inline const set_basic &get_vars() const$/;"	f	class:SymEngine::MSymEnginePoly
get_vec	symengine/functions.h	/^    inline const vec_basic &get_vec() const$/;"	f	class:SymEngine::MultiArgFunction
get_vec	symengine/logic.cpp	/^const PiecewiseVec &Piecewise::get_vec() const$/;"	f	class:SymEngine::Piecewise
get_vec_from_set	symengine/logic.cpp	/^const vec_boolean get_vec_from_set(const set_boolean &s)$/;"	f	namespace:SymEngine
get_version	symengine/basic.cpp	/^const char *get_version()$/;"	f	namespace:SymEngine
getlist	benchmarks/nonius.h++	/^    inline data_list& Data::getlist()$/;"	f	class:cpptempl::Data
getlist	benchmarks/nonius.h++	/^    inline data_list& DataList::getlist()$/;"	f	class:cpptempl::DataList
getmap	benchmarks/nonius.h++	/^    inline data_map& Data::getmap()$/;"	f	class:cpptempl::Data
getmap	benchmarks/nonius.h++	/^    inline data_map& DataMap:: getmap()$/;"	f	class:cpptempl::DataMap
gettext	benchmarks/nonius.h++	/^    inline std::string gettext(token_ptr token, data_map &data)$/;"	f	namespace:cpptempl
gettext	benchmarks/nonius.h++	/^    inline void TokenEnd::gettext( std::ostream &, data_map &)$/;"	f	class:cpptempl::TokenEnd
gettext	benchmarks/nonius.h++	/^    inline void TokenFor::gettext( std::ostream &stream, data_map &data )$/;"	f	class:cpptempl::TokenFor
gettext	benchmarks/nonius.h++	/^    inline void TokenIf::gettext( std::ostream &stream, data_map &data )$/;"	f	class:cpptempl::TokenIf
gettext	benchmarks/nonius.h++	/^    inline void TokenText::gettext( std::ostream &stream, data_map & )$/;"	f	class:cpptempl::TokenText
gettext	benchmarks/nonius.h++	/^    inline void TokenVar::gettext( std::ostream &stream, data_map &data )$/;"	f	class:cpptempl::TokenVar
gettype	benchmarks/nonius.h++	/^    inline TokenType TokenEnd::gettype()$/;"	f	class:cpptempl::TokenEnd
gettype	benchmarks/nonius.h++	/^    inline TokenType TokenFor::gettype()$/;"	f	class:cpptempl::TokenFor
gettype	benchmarks/nonius.h++	/^    inline TokenType TokenIf::gettype()$/;"	f	class:cpptempl::TokenIf
gettype	benchmarks/nonius.h++	/^    inline TokenType TokenText::gettype()$/;"	f	class:cpptempl::TokenText
gettype	benchmarks/nonius.h++	/^    inline TokenType TokenVar::gettype()$/;"	f	class:cpptempl::TokenVar
getvalue	benchmarks/nonius.h++	/^    inline std::string Data::getvalue()$/;"	f	class:cpptempl::Data
getvalue	benchmarks/nonius.h++	/^    inline std::string DataValue::getvalue()$/;"	f	class:cpptempl::DataValue
gf_compose_mod	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_compose_mod(const GaloisFieldDict &g,$/;"	f	class:SymEngine::GaloisFieldDict
gf_ddf_shoup	symengine/fields.cpp	/^GaloisFieldDict::gf_ddf_shoup() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_ddf_zassenhaus	symengine/fields.cpp	/^GaloisFieldDict::gf_ddf_zassenhaus() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_diff	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_diff() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_div	symengine/fields.cpp	/^void GaloisFieldDict::gf_div(const GaloisFieldDict &o,$/;"	f	class:SymEngine::GaloisFieldDict
gf_edf_shoup	symengine/fields.cpp	/^GaloisFieldDict::gf_edf_shoup(const unsigned &n) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_edf_zassenhaus	symengine/fields.cpp	/^GaloisFieldDict::gf_edf_zassenhaus(const unsigned &n) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_eval	symengine/fields.cpp	/^integer_class GaloisFieldDict::gf_eval(const integer_class &a) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_factor	symengine/fields.cpp	/^GaloisFieldDict::gf_factor() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_frobenius_map	symengine/fields.cpp	/^GaloisFieldDict::gf_frobenius_map(const GaloisFieldDict &g,$/;"	f	class:SymEngine::GaloisFieldDict
gf_frobenius_monomial_base	symengine/fields.cpp	/^std::vector<GaloisFieldDict> GaloisFieldDict::gf_frobenius_monomial_base() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_gcd	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_gcd(const GaloisFieldDict &o) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_is_sqf	symengine/fields.cpp	/^bool GaloisFieldDict::gf_is_sqf() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_istrip	symengine/fields.cpp	/^void GaloisFieldDict::gf_istrip()$/;"	f	class:SymEngine::GaloisFieldDict
gf_lcm	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_lcm(const GaloisFieldDict &o) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_lshift	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_lshift(const integer_class n) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_monic	symengine/fields.cpp	/^void GaloisFieldDict::gf_monic(integer_class &res,$/;"	f	class:SymEngine::GaloisFieldDict
gf_multi_eval	symengine/fields.cpp	/^GaloisFieldDict::gf_multi_eval(const vec_integer_class &v) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_poly	symengine/fields.h	/^inline RCP<const GaloisField> gf_poly(RCP<const Basic> i, map_uint_mpz &&dict,$/;"	f	namespace:SymEngine
gf_poly	symengine/fields.h	/^inline RCP<const GaloisField> gf_poly(RCP<const Basic> i,$/;"	f	namespace:SymEngine
gf_pow	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_pow(const unsigned long n) const$/;"	f	class:SymEngine::GaloisFieldDict
gf_pow_mod	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_pow_mod(const GaloisFieldDict &f,$/;"	f	class:SymEngine::GaloisFieldDict
gf_random	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_random(const unsigned int &n_val,$/;"	f	class:SymEngine::GaloisFieldDict
gf_rshift	symengine/fields.cpp	/^void GaloisFieldDict::gf_rshift(const integer_class n,$/;"	f	class:SymEngine::GaloisFieldDict
gf_shoup	symengine/fields.cpp	/^GaloisFieldDict::gf_shoup() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_sqf_list	symengine/fields.cpp	/^GaloisFieldDict::gf_sqf_list() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_sqf_part	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_sqf_part() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_sqr	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::gf_sqr() const$/;"	f	class:SymEngine::GaloisFieldDict
gf_trace_map	symengine/fields.cpp	/^std::pair<GaloisFieldDict, GaloisFieldDict> GaloisFieldDict::gf_trace_map($/;"	f	class:SymEngine::GaloisFieldDict
gf_zassenhaus	symengine/fields.cpp	/^GaloisFieldDict::gf_zassenhaus() const$/;"	f	class:SymEngine::GaloisFieldDict
global_benchmark_registry	benchmarks/nonius.h++	/^    inline benchmark_registry& global_benchmark_registry() {$/;"	f	namespace:nonius
global_reporter_registry	benchmarks/nonius.h++	/^    inline reporter_registry& global_reporter_registry() {$/;"	f	namespace:nonius
go	benchmarks/nonius.h++	/^    void go(configuration cfg, Iterator first, Iterator last, reporter& rep) {$/;"	f	namespace:nonius
go	benchmarks/nonius.h++	/^    void go(configuration cfg, Iterator first, Iterator last, reporter&& rep) {$/;"	f	namespace:nonius
go	benchmarks/nonius.h++	/^    void go(configuration cfg, benchmark_registry& benchmarks = global_benchmark_registry(), reporter_registry& reporters = global_reporter_registry()) {$/;"	f	namespace:nonius
handle_minus	symengine/functions.cpp	/^bool handle_minus(const RCP<const Basic> &arg,$/;"	f	namespace:SymEngine
harmonic	symengine/ntheory.cpp	/^RCP<const Number> harmonic(unsigned long n, long m)$/;"	f	namespace:SymEngine
has	benchmarks/nonius.h++	/^    inline bool data_map::has(const std::string& key) {$/;"	f	class:cpptempl::data_map
has_	symengine/visitor.h	/^    bool has_;$/;"	m	class:SymEngine::HasSymbolVisitor
has_dup	symengine/functions.cpp	/^bool has_dup(const vec_basic &arg)$/;"	f	namespace:SymEngine
has_exact_ring_operations	symengine/polys/uintpoly_piranha.h	/^struct has_exact_ring_operations<SymEngine::integer_class> {$/;"	s	namespace:piranha
has_exact_ring_operations	symengine/polys/uintpoly_piranha.h	/^struct has_exact_ring_operations<SymEngine::rational_class> {$/;"	s	namespace:piranha
has_ownership	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool RCP<T>::has_ownership() const$/;"	f	class:Teuchos::RCP
has_ownership	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool has_ownership() const$/;"	f	class:Teuchos::RCPNode
has_ownership	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool has_ownership() const$/;"	f	class:Teuchos::RCPNodeHandle
has_ownership	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void has_ownership(bool has_ownership_in)$/;"	f	class:Teuchos::RCPNode
has_ownership	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void has_ownership(bool has_ownership_in)$/;"	f	class:Teuchos::RCPNodeHandle
has_ownership_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool has_ownership_;$/;"	m	class:Teuchos::RCPNode
has_symbol	symengine/visitor.cpp	/^bool has_symbol(const Basic &b, const Symbol &x)$/;"	f	namespace:SymEngine
hash	symengine/basic-inl.h	/^inline hash_t Basic::hash() const$/;"	f	class:SymEngine::Basic
hash	symengine/basic-inl.h	/^struct hash<SymEngine::Basic> {$/;"	s	namespace:std
hash_	symengine/basic.h	/^    mutable std::atomic<hash_t> hash_; \/\/ This holds the hash value$/;"	m	class:SymEngine::Basic
hash_combine	symengine/basic-inl.h	/^inline void hash_combine(hash_t &seed, const T &v)$/;"	f	namespace:SymEngine
hash_combine_impl	symengine/basic-inl.h	/^inline void hash_combine_impl($/;"	f	namespace:SymEngine
hash_combine_impl	symengine/basic-inl.h	/^inline void hash_combine_impl(hash_t &seed, const double &s)$/;"	f	namespace:SymEngine
hash_combine_impl	symengine/basic-inl.h	/^inline void hash_combine_impl(hash_t &seed, const std::string &s)$/;"	f	namespace:SymEngine
hash_combine_impl	symengine/real_mpfr.cpp	/^void hash_combine_impl(hash_t &seed, mpfr_srcptr s)$/;"	f	namespace:SymEngine
hash_t	symengine/dict.h	/^typedef uint64_t hash_t;$/;"	t	namespace:SymEngine
held	symengine/utilities/teuchos/Teuchos_any.hpp	/^    ValueType held;$/;"	m	class:Teuchos::any::holder
help	benchmarks/nonius.h++	/^        bool help = false;$/;"	m	struct:nonius::configuration
help_text	benchmarks/nonius.h++	/^            help_text(std::string name, option_set const& options) : name(std::move(name)), options(options) {}$/;"	f	struct:nonius::detail::help_text
help_text	benchmarks/nonius.h++	/^        struct help_text {$/;"	s	namespace:nonius::detail
hermite	benchmarks/symbench.cpp	/^RCP<const Basic> hermite(RCP<const Integer> n, RCP<const Basic> y)$/;"	f
hermite	benchmarks/symbench_ginac.cpp	/^ex hermite(numeric n, ex y)$/;"	f
high_mild	benchmarks/nonius.h++	/^        int high_mild = 0;      \/\/ 1.5 to 3 times IQR above Q3$/;"	m	struct:nonius::outlier_classification
high_severe	benchmarks/nonius.h++	/^        int high_severe = 0;    \/\/ more than 3 times IQR above Q3$/;"	m	struct:nonius::outlier_classification
holder	symengine/utilities/teuchos/Teuchos_any.hpp	/^    holder(const ValueType & value)$/;"	f	class:Teuchos::any::holder
holder	symengine/utilities/teuchos/Teuchos_any.hpp	/^  class holder : public placeholder$/;"	c	class:Teuchos::any
homogeneous_lde	symengine/diophantine.cpp	/^void homogeneous_lde(std::vector<DenseMatrix> &basis, const DenseMatrix &A)$/;"	f	namespace:SymEngine
html_reporter	benchmarks/nonius.h++	/^    struct html_reporter : reporter {$/;"	s	namespace:nonius
html_static_path	doc/conf.py	/^html_static_path = ['_static']$/;"	v
html_theme	doc/conf.py	/^html_theme = 'default'$/;"	v
htmlhelp_basename	doc/conf.py	/^htmlhelp_basename = 'SymEnginedoc'$/;"	v
i	symengine/complex_double.h	/^    std::complex<double> i;$/;"	m	class:SymEngine::ComplexDouble
i	symengine/complex_mpc.h	/^    mpc_class i;$/;"	m	class:SymEngine::ComplexMPC
i	symengine/integer.h	/^    integer_class i;$/;"	m	class:SymEngine::Integer
i	symengine/rational.h	/^    rational_class i;$/;"	m	class:SymEngine::Rational
i	symengine/real_double.h	/^    double i;$/;"	m	class:SymEngine::RealDouble
i	symengine/real_mpfr.h	/^    mpfr_class i;$/;"	m	class:SymEngine::RealMPFR
i2	symengine/constants.cpp	/^RCP<const Basic> i2 = integer(2);$/;"	m	namespace:SymEngine	file:
i5	symengine/constants.cpp	/^RCP<const Basic> i5 = integer(5);$/;"	m	namespace:SymEngine	file:
i_	symengine/polys/upolybase.h	/^    long i_;$/;"	m	class:SymEngine::ContainerBaseIter
i_nth_root	symengine/integer.cpp	/^int i_nth_root(const Ptr<RCP<const Integer>> &r, const Integer &a,$/;"	f	namespace:SymEngine
iabs	symengine/integer.cpp	/^RCP<const Integer> iabs(const Integer &n)$/;"	f	namespace:SymEngine
iaddnum	symengine/number.h	/^inline void iaddnum(const Ptr<RCP<const Number>> &self,$/;"	f	namespace:SymEngine
ideal_magnitude	benchmarks/nonius.h++	/^        double ideal_magnitude() const {$/;"	f	struct:nonius::html_reporter
identity	symengine/mp_boost.cpp	/^    static two_by_two_matrix identity()$/;"	f	struct:SymEngine::two_by_two_matrix
idivnum	symengine/number.h	/^inline void idivnum(const Ptr<RCP<const Number>> &self,$/;"	f	namespace:SymEngine
im2	symengine/constants.cpp	/^RCP<const Basic> im2 = integer(-2);$/;"	m	namespace:SymEngine	file:
im3	symengine/constants.cpp	/^RCP<const Basic> im3 = integer(-3);$/;"	m	namespace:SymEngine	file:
im5	symengine/constants.cpp	/^RCP<const Basic> im5 = integer(-5);$/;"	m	namespace:SymEngine	file:
imag	symengine/cwrapper.h	/^    double imag;$/;"	m	struct:dcomplex
imag_	symengine/as_real_imag.cpp	/^    Ptr<RCP<const Basic>> real_, imag_;$/;"	m	class:SymEngine::RealImagVisitor	file:
imageset	symengine/sets.h	/^inline RCP<const Set> imageset(const RCP<const Basic> &sym,$/;"	f	namespace:SymEngine
imaginary_	symengine/complex.h	/^    rational_class imaginary_;$/;"	m	class:SymEngine::Complex
imaginary_part	symengine/complex.cpp	/^RCP<const Number> Complex::imaginary_part() const$/;"	f	class:SymEngine::Complex
imaginary_part	symengine/complex_double.cpp	/^RCP<const Number> ComplexDouble::imaginary_part() const$/;"	f	class:SymEngine::ComplexDouble
imaginary_part	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::imaginary_part() const$/;"	f	class:SymEngine::ComplexMPC
impl	benchmarks/nonius.h++	/^        detail::chronometer_concept* impl;$/;"	m	struct:nonius::chronometer
impl_pre_delete_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNode::impl_pre_delete_extra_data()$/;"	f	class:Teuchos::RCPNode
impl_stacktrace_depth	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int impl_stacktrace_depth;$/;"	m	class:__anon22::StacktraceAddresses	file:
impl_stacktrace_depth	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int impl_stacktrace_depth;$/;"	m	class:__anon43::StacktraceAddresses	file:
implicit_cast	symengine/symengine_casts.h	/^inline To implicit_cast(const From &f)$/;"	f	namespace:SymEngine
imulnum	symengine/number.h	/^inline void imulnum(const Ptr<RCP<const Number>> &self,$/;"	f	namespace:SymEngine
inOutArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> inOutArg( T& arg )$/;"	f	namespace:Teuchos
incr_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int incr_count( const ERCPStrength strength )$/;"	f	class:Teuchos::RCPNode
info	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  std::string info;$/;"	m	struct:__anon20::RCPNodeInfo	file:
info	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  std::string info;$/;"	m	struct:__anon41::RCPNodeInfo	file:
info_arch	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_arch	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_arch = "INFO" ":" "arch[" ARCHITECTURE_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_compiler	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_compiler = "INFO" ":" "compiler[" COMPILER_ID "]";$/;"	v
info_cray	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";$/;"	v
info_cray	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const *info_cray = "INFO" ":" "compiler_wrapper[CrayPrgEnv]";$/;"	v
info_language_dialect_default	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^const char* info_language_dialect_default =$/;"	v
info_language_dialect_default	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^const char* info_language_dialect_default = "INFO" ":" "dialect_default["$/;"	v
info_platform	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_platform	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_platform = "INFO" ":" "platform[" PLATFORM_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* info_simulate = "INFO" ":" "simulate[" SIMULATE_ID "]";$/;"	v
info_simulate_version	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const info_simulate_version[] = {$/;"	v
info_simulate_version	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_simulate_version[] = {$/;"	v
info_version	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const info_version[] = {$/;"	v
info_version	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version[] = {$/;"	v
info_version_internal	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const info_version_internal[] = {$/;"	v
info_version_internal	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const info_version_internal[] = {$/;"	v
infty	symengine/infinity.cpp	/^inline RCP<const Infty> infty(const RCP<const Number> &direction)$/;"	f	namespace:SymEngine
infty	symengine/infinity.h	/^inline RCP<const Infty> infty(int n = 1)$/;"	f	namespace:SymEngine
init	symengine/lambda_double.h	/^    void init(const vec_basic &inputs, const vec_basic &outputs,$/;"	f	class:SymEngine::LambdaDoubleVisitor
init	symengine/lambda_double.h	/^    void init(const vec_basic &x, const Basic &b, bool cse = false)$/;"	f	class:SymEngine::LambdaDoubleVisitor
init	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::init(const vec_basic &inputs, const vec_basic &outputs,$/;"	f	class:SymEngine::LLVMDoubleVisitor
init	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::init(const vec_basic &x, const Basic &b,$/;"	f	class:SymEngine::LLVMDoubleVisitor
init_eval_double	symengine/eval_double.cpp	/^std::vector<fn> init_eval_double()$/;"	f	namespace:SymEngine
init_latex_printer_names	symengine/printers/latex.cpp	/^std::vector<std::string> init_latex_printer_names()$/;"	f	namespace:SymEngine
init_mathml_printer_names	symengine/printers/mathml.cpp	/^std::vector<std::string> init_mathml_printer_names()$/;"	f	namespace:SymEngine
init_str_printer_names	symengine/printers/strprinter.cpp	/^std::vector<std::string> init_str_printer_names()$/;"	f	namespace:SymEngine
inoutArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> inoutArg( T& arg )$/;"	f	namespace:Teuchos
inp	symengine/parser/parser.h	/^    std::istringstream inp;$/;"	m	class:SymEngine::Parser
insert	symengine/dict.h	/^inline void insert(T1 &m, const T2 &first, const T3 &second)$/;"	f	namespace:SymEngine
insertion_number	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int insertion_number() const$/;"	f	class:Teuchos::RCPNode
insertion_number_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int insertion_number_;$/;"	m	class:Teuchos::RCPNode
install_dir	bin/test_make_install.py	/^install_dir = sys.argv[1]$/;"	v
installed_files	bin/test_make_install.py	/^installed_files = set([relpath(x, install_dir) for x in glob(join(install_dir, '*.h'))])$/;"	v
integer	symengine/integer.h	/^inline RCP<const Integer> integer(integer_class i)$/;"	f	namespace:SymEngine
integer	symengine/integer.h	/^integer(T i)$/;"	f	namespace:SymEngine
integer_class	symengine/mp_class.h	/^    integer_class;$/;"	t	namespace:SymEngine
integer_get_mpz	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE integer_get_mpz(mpz_t a, const basic s)$/;"	f
integer_get_si	symengine/cwrapper.cpp	/^signed long integer_get_si(const basic s)$/;"	f
integer_get_ui	symengine/cwrapper.cpp	/^unsigned long integer_get_ui(const basic s)$/;"	f
integer_set_mpz	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE integer_set_mpz(basic s, const mpz_t i)$/;"	f
integer_set_si	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE integer_set_si(basic s, long i)$/;"	f
integer_set_str	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE integer_set_str(basic s, const char *c)$/;"	f
integer_set_ui	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE integer_set_ui(basic s, unsigned long i)$/;"	f
integral	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper integral() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
integrate	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::integrate(const fqp_t &s, const fqp_t &var)$/;"	f	class:SymEngine::URatPSeriesFlint
integrate	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::integrate(const UExprDict &s, const UExprDict &var)$/;"	f	class:SymEngine::UnivariateSeries
integrate	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::integrate(const p_expr &s, const p_expr &var)$/;"	f	class:SymEngine::UPSeriesPiranha
integrate	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::integrate(const pp_t &s, const pp_t &var)$/;"	f	class:SymEngine::URatPSeriesPiranha
internal_coef_type	symengine/flint_wrapper.h	/^    typedef fmpq_wrapper internal_coef_type;$/;"	t	class:SymEngine::fmpq_poly_wrapper
internal_coef_type	symengine/flint_wrapper.h	/^    typedef fmpz_wrapper internal_coef_type;$/;"	t	class:SymEngine::fmpz_poly_factor_wrapper
internal_coef_type	symengine/flint_wrapper.h	/^    typedef fmpz_wrapper internal_coef_type;$/;"	t	class:SymEngine::fmpz_poly_wrapper
intersphinx_mapping	doc/conf.py	/^intersphinx_mapping = {'http:\/\/docs.python.org\/': None}$/;"	v
interval	symengine/sets.h	/^inline RCP<const Set> interval(const RCP<const Number> &start,$/;"	f	namespace:SymEngine
inv	symengine/dense_matrix.cpp	/^void DenseMatrix::inv(MatrixBase &result) const$/;"	f	class:SymEngine::DenseMatrix
inv	symengine/sparse_matrix.cpp	/^void CSRMatrix::inv(MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
inv_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper inv_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
inverse_LU	symengine/dense_matrix.cpp	/^void inverse_LU(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
inverse_cst	symengine/constants.cpp	/^umap_basic_basic inverse_cst = {$/;"	m	namespace:SymEngine	file:
inverse_fraction_free_LU	symengine/dense_matrix.cpp	/^void inverse_fraction_free_LU(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
inverse_gauss_jordan	symengine/dense_matrix.cpp	/^void inverse_gauss_jordan(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
inverse_lookup	symengine/functions.cpp	/^bool inverse_lookup(umap_basic_basic &d, const RCP<const Basic> &t,$/;"	f	namespace:SymEngine
inverse_pivoted_LU	symengine/dense_matrix.cpp	/^void inverse_pivoted_LU(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
inverse_tct	symengine/constants.cpp	/^umap_basic_basic inverse_tct = {$/;"	m	namespace:SymEngine	file:
invertComplex	symengine/solve.cpp	/^RCP<const Set> invertComplex(const RCP<const Basic> &fX,$/;"	f	namespace:SymEngine
invoke	benchmarks/nonius.h++	/^            static CompleteType<void> invoke(Fun&& fun, Args&&... args) {$/;"	f	struct:nonius::detail::complete_invoker
invoke	benchmarks/nonius.h++	/^            static Result invoke(Fun&& fun, Args&&... args) {$/;"	f	struct:nonius::detail::complete_invoker
invoke	symengine/utilities/catch/catch.hpp	/^    virtual void invoke() const {$/;"	f	class:Catch::MethodTestCase
invseries_coeff	symengine/tests/basic/test_series_expansion_UP.cpp	/^#define invseries_coeff(/;"	d	file:
invseries_coeff	symengine/tests/basic/test_series_expansion_URatF.cpp	/^static RCP<const Number> invseries_coeff(const RCP<const Basic> &ex,$/;"	f	file:
invseries_coeff	symengine/tests/basic/test_series_expansion_URatP.cpp	/^#define invseries_coeff(/;"	d	file:
invseries_coeff	symengine/tests/basic/test_series_generic.cpp	/^#define invseries_coeff(/;"	d	file:
isBinaryExpression	symengine/utilities/catch/catch.hpp	/^        virtual bool isBinaryExpression() const {$/;"	f	struct:Catch::DecomposedExpression
isFalseTest	symengine/utilities/catch/catch.hpp	/^    inline bool isFalseTest( int flags )                { return ( flags & ResultDisposition::FalseTest ) != 0; }$/;"	f	namespace:Catch
isJustInfo	symengine/utilities/catch/catch.hpp	/^    inline bool isJustInfo( int flags ) {$/;"	f	namespace:Catch
isOk	symengine/utilities/catch/catch.hpp	/^    inline bool isOk( ResultWas::OfType resultType ) {$/;"	f	namespace:Catch
isTracingActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool RCPNodeTracer::isTracingActiveRCPNodes()$/;"	f	class:Teuchos::RCPNodeTracer
isTrue	symengine/utilities/catch/catch.hpp	/^    inline bool isTrue( bool value ){ return value; }$/;"	f	namespace:Catch
is_	symengine/solve.cpp	/^    bool is_;$/;"	m	class:SymEngine::IsALinearArgTrigVisitor	file:
is_a	symengine/basic-inl.h	/^inline bool is_a(const Basic &b)$/;"	f	namespace:SymEngine
is_a	symengine/matrix.h	/^inline bool is_a(const MatrixBase &b)$/;"	f	namespace:SymEngine
is_a_Atom	symengine/basic.cpp	/^bool is_a_Atom(const Basic &b)$/;"	f	namespace:SymEngine
is_a_Boolean	symengine/logic.h	/^inline bool is_a_Boolean(const Basic &b)$/;"	f	namespace:SymEngine
is_a_Complex	symengine/complex.h	/^inline bool is_a_Complex(const Basic &b)$/;"	f	namespace:SymEngine
is_a_Complex	symengine/cwrapper.cpp	/^int is_a_Complex(const basic c)$/;"	f
is_a_ComplexDouble	symengine/cwrapper.cpp	/^int is_a_ComplexDouble(const basic c)$/;"	f
is_a_ComplexMPC	symengine/cwrapper.cpp	/^int is_a_ComplexMPC(const basic c)$/;"	f
is_a_DenseMatrix	symengine/cwrapper.cpp	/^int is_a_DenseMatrix(const CDenseMatrix *c)$/;"	f
is_a_Integer	symengine/cwrapper.cpp	/^int is_a_Integer(const basic c)$/;"	f
is_a_LinearArgTrigEquation	symengine/solve.cpp	/^bool is_a_LinearArgTrigEquation(const Basic &b, const Symbol &x)$/;"	f	namespace:SymEngine
is_a_Number	symengine/cwrapper.cpp	/^int is_a_Number(const basic s)$/;"	f
is_a_Number	symengine/number.h	/^inline bool is_a_Number(const Basic &b)$/;"	f	namespace:SymEngine
is_a_Rational	symengine/cwrapper.cpp	/^int is_a_Rational(const basic c)$/;"	f
is_a_RealDouble	symengine/cwrapper.cpp	/^int is_a_RealDouble(const basic c)$/;"	f
is_a_RealMPFR	symengine/cwrapper.cpp	/^int is_a_RealMPFR(const basic c)$/;"	f
is_a_Relational	symengine/logic.h	/^inline bool is_a_Relational(const Basic &b)$/;"	f	namespace:SymEngine
is_a_Set	symengine/sets.h	/^inline bool is_a_Set(const Basic &b)$/;"	f	namespace:SymEngine
is_a_SparseMatrix	symengine/cwrapper.cpp	/^int is_a_SparseMatrix(const CSparseMatrix *c)$/;"	f
is_a_Symbol	symengine/cwrapper.cpp	/^int is_a_Symbol(const basic c)$/;"	f
is_a_UPoly	symengine/polys/upolybase.h	/^struct is_a_UPoly {$/;"	s	namespace:SymEngine
is_a_sub	symengine/basic-inl.h	/^inline bool is_a_sub(const Basic &b)$/;"	f	namespace:SymEngine
is_aligned	symengine/cwrapper.cpp	/^inline bool is_aligned(T *p, size_t n = alignof(T))$/;"	f	namespace:SymEngine
is_base_of_multiple	symengine/visitor.h	/^struct is_base_of_multiple {$/;"	s	namespace:SymEngine
is_base_of_multiple	symengine/visitor.h	/^struct is_base_of_multiple<Derived, First> {$/;"	s	namespace:SymEngine
is_callable	benchmarks/nonius.h++	/^        struct is_callable<Fun(Args...)> : decltype(is_callable_tester::test<Fun, Args...>(0)) {};$/;"	s	namespace:nonius::detail
is_callable_tester	benchmarks/nonius.h++	/^        struct is_callable_tester {$/;"	s	namespace:nonius::detail
is_canonical	symengine/add.cpp	/^bool Add::is_canonical(const RCP<const Number> &coef,$/;"	f	class:SymEngine::Add
is_canonical	symengine/complex.cpp	/^bool Complex::is_canonical(const rational_class &real,$/;"	f	class:SymEngine::Complex
is_canonical	symengine/fields.cpp	/^bool GaloisField::is_canonical(const GaloisFieldDict &dict) const$/;"	f	class:SymEngine::GaloisField
is_canonical	symengine/functions.cpp	/^bool ACos::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACos
is_canonical	symengine/functions.cpp	/^bool ACosh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACosh
is_canonical	symengine/functions.cpp	/^bool ACot::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACot
is_canonical	symengine/functions.cpp	/^bool ACoth::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACoth
is_canonical	symengine/functions.cpp	/^bool ACsc::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACsc
is_canonical	symengine/functions.cpp	/^bool ACsch::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ACsch
is_canonical	symengine/functions.cpp	/^bool ASec::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASec
is_canonical	symengine/functions.cpp	/^bool ASech::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASech
is_canonical	symengine/functions.cpp	/^bool ASin::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASin
is_canonical	symengine/functions.cpp	/^bool ASinh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ASinh
is_canonical	symengine/functions.cpp	/^bool ATan2::is_canonical(const RCP<const Basic> &num,$/;"	f	class:SymEngine::ATan2
is_canonical	symengine/functions.cpp	/^bool ATan::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ATan
is_canonical	symengine/functions.cpp	/^bool ATanh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::ATanh
is_canonical	symengine/functions.cpp	/^bool Abs::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Abs
is_canonical	symengine/functions.cpp	/^bool Beta::is_canonical(const RCP<const Basic> &x, const RCP<const Basic> &y)$/;"	f	class:SymEngine::Beta
is_canonical	symengine/functions.cpp	/^bool Ceiling::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Ceiling
is_canonical	symengine/functions.cpp	/^bool Conjugate::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Conjugate
is_canonical	symengine/functions.cpp	/^bool Cos::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cos
is_canonical	symengine/functions.cpp	/^bool Cosh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cosh
is_canonical	symengine/functions.cpp	/^bool Cot::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Cot
is_canonical	symengine/functions.cpp	/^bool Coth::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Coth
is_canonical	symengine/functions.cpp	/^bool Csc::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Csc
is_canonical	symengine/functions.cpp	/^bool Csch::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Csch
is_canonical	symengine/functions.cpp	/^bool Derivative::is_canonical(const RCP<const Basic> &arg,$/;"	f	class:SymEngine::Derivative
is_canonical	symengine/functions.cpp	/^bool Dirichlet_eta::is_canonical(const RCP<const Basic> &s) const$/;"	f	class:SymEngine::Dirichlet_eta
is_canonical	symengine/functions.cpp	/^bool Erf::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Erf
is_canonical	symengine/functions.cpp	/^bool Erfc::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Erfc
is_canonical	symengine/functions.cpp	/^bool Floor::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Floor
is_canonical	symengine/functions.cpp	/^bool FunctionSymbol::is_canonical(const vec_basic &arg) const$/;"	f	class:SymEngine::FunctionSymbol
is_canonical	symengine/functions.cpp	/^bool Gamma::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Gamma
is_canonical	symengine/functions.cpp	/^bool KroneckerDelta::is_canonical(const RCP<const Basic> &i,$/;"	f	class:SymEngine::KroneckerDelta
is_canonical	symengine/functions.cpp	/^bool LambertW::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::LambertW
is_canonical	symengine/functions.cpp	/^bool LeviCivita::is_canonical(const vec_basic &arg) const$/;"	f	class:SymEngine::LeviCivita
is_canonical	symengine/functions.cpp	/^bool Log::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Log
is_canonical	symengine/functions.cpp	/^bool LogGamma::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::LogGamma
is_canonical	symengine/functions.cpp	/^bool LowerGamma::is_canonical(const RCP<const Basic> &s,$/;"	f	class:SymEngine::LowerGamma
is_canonical	symengine/functions.cpp	/^bool Max::is_canonical(const vec_basic &arg) const$/;"	f	class:SymEngine::Max
is_canonical	symengine/functions.cpp	/^bool Min::is_canonical(const vec_basic &arg) const$/;"	f	class:SymEngine::Min
is_canonical	symengine/functions.cpp	/^bool PolyGamma::is_canonical(const RCP<const Basic> &n,$/;"	f	class:SymEngine::PolyGamma
is_canonical	symengine/functions.cpp	/^bool Sec::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sec
is_canonical	symengine/functions.cpp	/^bool Sech::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sech
is_canonical	symengine/functions.cpp	/^bool Sign::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sign
is_canonical	symengine/functions.cpp	/^bool Sin::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sin
is_canonical	symengine/functions.cpp	/^bool Sinh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Sinh
is_canonical	symengine/functions.cpp	/^bool Subs::is_canonical(const RCP<const Basic> &arg,$/;"	f	class:SymEngine::Subs
is_canonical	symengine/functions.cpp	/^bool Tan::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Tan
is_canonical	symengine/functions.cpp	/^bool Tanh::is_canonical(const RCP<const Basic> &arg) const$/;"	f	class:SymEngine::Tanh
is_canonical	symengine/functions.cpp	/^bool UpperGamma::is_canonical(const RCP<const Basic> &s,$/;"	f	class:SymEngine::UpperGamma
is_canonical	symengine/functions.cpp	/^bool Zeta::is_canonical(const RCP<const Basic> &s,$/;"	f	class:SymEngine::Zeta
is_canonical	symengine/infinity.cpp	/^bool Infty::is_canonical(const RCP<const Number> &num) const$/;"	f	class:SymEngine::Infty
is_canonical	symengine/logic.cpp	/^bool And::is_canonical(const set_boolean &container_)$/;"	f	class:SymEngine::And
is_canonical	symengine/logic.cpp	/^bool Not::is_canonical(const RCP<const Boolean> &in)$/;"	f	class:SymEngine::Not
is_canonical	symengine/logic.cpp	/^bool Or::is_canonical(const set_boolean &container_)$/;"	f	class:SymEngine::Or
is_canonical	symengine/logic.cpp	/^bool Xor::is_canonical(const vec_boolean &container_)$/;"	f	class:SymEngine::Xor
is_canonical	symengine/logic.cpp	/^inline bool Relational::is_canonical(const RCP<const Basic> &lhs,$/;"	f	class:SymEngine::Relational
is_canonical	symengine/mul.cpp	/^bool Mul::is_canonical(const RCP<const Number> &coef,$/;"	f	class:SymEngine::Mul
is_canonical	symengine/polys/usymenginepoly.h	/^    bool is_canonical(const Container &dict) const$/;"	f	class:SymEngine::USymEnginePoly
is_canonical	symengine/pow.cpp	/^bool Pow::is_canonical(const Basic &base, const Basic &exp) const$/;"	f	class:SymEngine::Pow
is_canonical	symengine/rational.cpp	/^bool Rational::is_canonical(const rational_class &i) const$/;"	f	class:SymEngine::Rational
is_canonical	symengine/sets.cpp	/^bool ConditionSet::is_canonical(const RCP<const Basic> &sym,$/;"	f	class:SymEngine::ConditionSet
is_canonical	symengine/sets.cpp	/^bool FiniteSet::is_canonical(const set_basic &container)$/;"	f	class:SymEngine::FiniteSet
is_canonical	symengine/sets.cpp	/^bool ImageSet::is_canonical(const RCP<const Basic> &sym,$/;"	f	class:SymEngine::ImageSet
is_canonical	symengine/sets.cpp	/^bool Interval::is_canonical(const RCP<const Number> &s,$/;"	f	class:SymEngine::Interval
is_canonical	symengine/sets.cpp	/^bool Union::is_canonical(const set_set &in)$/;"	f	class:SymEngine::Union
is_canonical	symengine/sparse_matrix.cpp	/^bool CSRMatrix::is_canonical() const$/;"	f	class:SymEngine::CSRMatrix
is_complex	symengine/complex.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::Complex
is_complex	symengine/complex_double.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::ComplexDouble
is_complex	symengine/complex_mpc.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::ComplexMPC
is_complex	symengine/infinity.h	/^    inline bool is_complex() const$/;"	f	class:SymEngine::Infty
is_complex	symengine/integer.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::Integer
is_complex	symengine/nan.h	/^    inline bool is_complex() const$/;"	f	class:SymEngine::NaN
is_complex	symengine/rational.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::Rational
is_complex	symengine/real_double.h	/^    virtual bool is_complex() const$/;"	f	class:SymEngine::RealDouble
is_complex	symengine/real_mpfr.h	/^    virtual bool is_complex() const$/;"	f	class:SymEngine::RealMPFR
is_complex	symengine/series.h	/^    inline virtual bool is_complex() const$/;"	f	class:SymEngine::SeriesBase
is_dual_character_operator	symengine/parser/parser_old.cpp	/^    bool is_dual_character_operator(int iter)$/;"	f	class:SymEngine::ExpressionParser	file:
is_exact	symengine/complex_double.h	/^    inline virtual bool is_exact() const$/;"	f	class:SymEngine::ComplexDouble
is_exact	symengine/complex_mpc.h	/^    inline virtual bool is_exact() const$/;"	f	class:SymEngine::ComplexMPC
is_exact	symengine/infinity.h	/^    inline virtual bool is_exact() const$/;"	f	class:SymEngine::Infty
is_exact	symengine/nan.h	/^    inline bool is_exact() const$/;"	f	class:SymEngine::NaN
is_exact	symengine/number.h	/^    virtual bool is_exact() const$/;"	f	class:SymEngine::Number
is_exact	symengine/real_double.h	/^    inline virtual bool is_exact() const$/;"	f	class:SymEngine::RealDouble
is_exact	symengine/real_mpfr.h	/^    inline virtual bool is_exact() const$/;"	f	class:SymEngine::RealMPFR
is_exact_zero	symengine/number.h	/^    inline bool is_exact_zero() const$/;"	f	class:SymEngine::Number
is_int	symengine/rational.h	/^    inline bool is_int() const$/;"	f	class:SymEngine::Rational
is_integer	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_integer() const$/;"	f	class:SymEngine::UExprPoly
is_minimum	symengine/diophantine.cpp	/^bool is_minimum(const DenseMatrix &t, const std::vector<DenseMatrix> &basis,$/;"	f	namespace:SymEngine
is_minus_one	symengine/complex.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::Complex
is_minus_one	symengine/complex_double.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::ComplexDouble
is_minus_one	symengine/complex_mpc.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::ComplexMPC
is_minus_one	symengine/infinity.h	/^    inline bool is_minus_one() const$/;"	f	class:SymEngine::Infty
is_minus_one	symengine/integer.h	/^    inline virtual bool is_minus_one() const$/;"	f	class:SymEngine::Integer
is_minus_one	symengine/nan.h	/^    inline bool is_minus_one() const$/;"	f	class:SymEngine::NaN
is_minus_one	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_minus_one() const$/;"	f	class:SymEngine::UExprPoly
is_minus_one	symengine/rational.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::Rational
is_minus_one	symengine/real_double.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::RealDouble
is_minus_one	symengine/real_mpfr.h	/^    virtual bool is_minus_one() const$/;"	f	class:SymEngine::RealMPFR
is_minus_one	symengine/series.h	/^    inline virtual bool is_minus_one() const$/;"	f	class:SymEngine::SeriesBase
is_mul	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_mul() const$/;"	f	class:SymEngine::UExprPoly
is_negative	symengine/complex.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::Complex
is_negative	symengine/complex_double.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::ComplexDouble
is_negative	symengine/complex_mpc.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::ComplexMPC
is_negative	symengine/infinity.h	/^    inline bool is_negative() const$/;"	f	class:SymEngine::Infty
is_negative	symengine/integer.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::Integer
is_negative	symengine/nan.h	/^    inline bool is_negative() const$/;"	f	class:SymEngine::NaN
is_negative	symengine/rational.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::Rational
is_negative	symengine/real_double.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::RealDouble
is_negative	symengine/real_mpfr.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::RealMPFR
is_negative	symengine/series.h	/^    inline virtual bool is_negative() const$/;"	f	class:SymEngine::SeriesBase
is_negative_infinity	symengine/infinity.cpp	/^bool Infty::is_negative_infinity() const$/;"	f	class:SymEngine::Infty
is_node_null	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool is_node_null() const$/;"	f	class:Teuchos::RCPNodeHandle
is_nth_residue	symengine/ntheory.cpp	/^bool is_nth_residue(const Integer &a, const Integer &n, const Integer &mod)$/;"	f	namespace:SymEngine
is_null	build/cmake/checkcxx11.cpp	/^    bool is_null() const { return ptr_ == NULL; }$/;"	f	class:RCP
is_null	cmake/checkcxx11.cpp	/^    bool is_null() const { return ptr_ == NULL; }$/;"	f	class:RCP
is_null	symengine/symengine_rcp.h	/^    bool is_null() const$/;"	f	class:SymEngine::RCP
is_null	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool is_null( const Ptr<T> &p )$/;"	f	namespace:Teuchos
is_null	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool RCP<T>::is_null() const$/;"	f	class:Teuchos::RCP
is_null	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::is_null( const RCP<T> &p )$/;"	f	class:Teuchos
is_one	symengine/complex.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::Complex
is_one	symengine/complex_double.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::ComplexDouble
is_one	symengine/complex_mpc.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::ComplexMPC
is_one	symengine/fields.h	/^    bool is_one() const$/;"	f	class:SymEngine::GaloisFieldDict
is_one	symengine/flint_wrapper.h	/^    bool is_one() const$/;"	f	class:SymEngine::fmpq_wrapper
is_one	symengine/infinity.h	/^    inline bool is_one() const$/;"	f	class:SymEngine::Infty
is_one	symengine/integer.h	/^    inline virtual bool is_one() const$/;"	f	class:SymEngine::Integer
is_one	symengine/nan.h	/^    inline bool is_one() const$/;"	f	class:SymEngine::NaN
is_one	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_one() const$/;"	f	class:SymEngine::UExprPoly
is_one	symengine/rational.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::Rational
is_one	symengine/real_double.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::RealDouble
is_one	symengine/real_mpfr.h	/^    virtual bool is_one() const$/;"	f	class:SymEngine::RealMPFR
is_one	symengine/series.h	/^    inline virtual bool is_one() const$/;"	f	class:SymEngine::SeriesBase
is_perfect_power	symengine/number.h	/^    virtual bool is_perfect_power(bool is_expected = false) const$/;"	f	class:SymEngine::Number
is_perfect_power	symengine/rational.cpp	/^bool Rational::is_perfect_power(bool is_expected) const$/;"	f	class:SymEngine::Rational
is_positive	symengine/complex.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::Complex
is_positive	symengine/complex_double.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::ComplexDouble
is_positive	symengine/complex_mpc.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::ComplexMPC
is_positive	symengine/infinity.h	/^    inline bool is_positive() const$/;"	f	class:SymEngine::Infty
is_positive	symengine/integer.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::Integer
is_positive	symengine/nan.h	/^    inline bool is_positive() const$/;"	f	class:SymEngine::NaN
is_positive	symengine/rational.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::Rational
is_positive	symengine/real_double.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::RealDouble
is_positive	symengine/real_mpfr.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::RealMPFR
is_positive	symengine/series.h	/^    inline virtual bool is_positive() const$/;"	f	class:SymEngine::SeriesBase
is_positive_infinity	symengine/infinity.cpp	/^bool Infty::is_positive_infinity() const$/;"	f	class:SymEngine::Infty
is_pow	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_pow() const$/;"	f	class:SymEngine::UExprPoly
is_proper_subset	symengine/sets.h	/^    bool is_proper_subset(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Set
is_proper_superset	symengine/sets.h	/^    bool is_proper_superset(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Set
is_quad_residue	symengine/ntheory.cpp	/^bool is_quad_residue(const Integer &a, const Integer &p)$/;"	f	namespace:SymEngine
is_re_zero	symengine/complex.cpp	/^bool ComplexBase::is_re_zero() const$/;"	f	class:SymEngine::ComplexBase
is_related	benchmarks/nonius.h++	/^        struct is_related$/;"	s	namespace:nonius::detail
is_same_type	symengine/basic-inl.h	/^inline bool is_same_type(const Basic &a, const Basic &b)$/;"	f	namespace:SymEngine
is_seen	symengine/cse.cpp	/^    bool is_seen(const Basic &expr)$/;"	f	class:SymEngine::OptsCSEVisitor
is_single_character_operator	symengine/parser/parser_old.cpp	/^    bool is_single_character_operator(int iter)$/;"	f	class:SymEngine::ExpressionParser	file:
is_subset	symengine/sets.h	/^    bool is_subset(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Set
is_superset	symengine/sets.h	/^    bool is_superset(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Set
is_symbol	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_symbol() const$/;"	f	class:SymEngine::UExprPoly
is_symmetric_dense	symengine/dense_matrix.cpp	/^bool is_symmetric_dense(const DenseMatrix &A)$/;"	f	namespace:SymEngine
is_true	benchmarks/nonius.h++	/^    inline bool TokenIf::is_true( std::string expr, data_map &data )$/;"	f	class:cpptempl::TokenIf
is_unary_precedor	symengine/parser/parser_old.cpp	/^    bool is_unary_precedor(int iter)$/;"	f	class:SymEngine::ExpressionParser	file:
is_unsigned_infinity	symengine/infinity.cpp	/^bool Infty::is_unsigned_infinity() const$/;"	f	class:SymEngine::Infty
is_valid_ptr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool RCP<T>::is_valid_ptr() const$/;"	f	class:Teuchos::RCP
is_valid_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool is_valid_ptr() const$/;"	f	class:Teuchos::RCPNodeHandle
is_valid_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  virtual bool is_valid_ptr() const$/;"	f	class:Teuchos::RCPNodeTmpl
is_whitespace_char	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^bool is_whitespace_char(const char c)$/;"	f	namespace:__anon22
is_whitespace_char	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^bool is_whitespace_char(const char c)$/;"	f	namespace:__anon43
is_zero	symengine/complex.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::Complex
is_zero	symengine/complex_double.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::ComplexDouble
is_zero	symengine/complex_mpc.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::ComplexMPC
is_zero	symengine/flint_wrapper.h	/^    bool is_zero() const$/;"	f	class:SymEngine::fmpq_wrapper
is_zero	symengine/infinity.h	/^    inline bool is_zero() const$/;"	f	class:SymEngine::Infty
is_zero	symengine/integer.h	/^    inline virtual bool is_zero() const$/;"	f	class:SymEngine::Integer
is_zero	symengine/nan.h	/^    inline bool is_zero() const$/;"	f	class:SymEngine::NaN
is_zero	symengine/polys/uexprpoly.cpp	/^bool UExprPoly::is_zero() const$/;"	f	class:SymEngine::UExprPoly
is_zero	symengine/rational.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::Rational
is_zero	symengine/real_double.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::RealDouble
is_zero	symengine/real_mpfr.h	/^    virtual bool is_zero() const$/;"	f	class:SymEngine::RealMPFR
is_zero	symengine/series.h	/^    inline virtual bool is_zero() const$/;"	f	class:SymEngine::SeriesBase
isqrt	symengine/integer.cpp	/^RCP<const Integer> isqrt(const Integer &n)$/;"	f	namespace:SymEngine
iterations	benchmarks/nonius.h++	/^        int iterations;$/;"	m	struct:nonius::timing
iterations_per_sample	benchmarks/nonius.h++	/^        int iterations_per_sample;$/;"	m	struct:nonius::execution_plan
iterator	symengine/fields.h	/^    typedef vec_integer_class::const_iterator iterator;$/;"	t	class:SymEngine::GaloisField
iterator	symengine/ntheory.cpp	/^Sieve::iterator::iterator()$/;"	f	class:SymEngine::Sieve::iterator
iterator	symengine/ntheory.cpp	/^Sieve::iterator::iterator(unsigned max)$/;"	f	class:SymEngine::Sieve::iterator
iterator	symengine/ntheory.h	/^    class iterator$/;"	c	class:SymEngine::Sieve
iterator	symengine/polys/uintpoly_flint.h	/^    typedef ContainerForIter<Poly, Cf> iterator;$/;"	t	class:SymEngine::UFlintPoly
iterator	symengine/polys/uintpoly_piranha.h	/^    typedef PiranhaForIter<Cf, Container> iterator;$/;"	t	class:SymEngine::UPiranhaPoly
iterator	symengine/polys/usymenginepoly.h	/^    typedef typename std::map<Key, Cf>::const_iterator iterator;$/;"	t	class:SymEngine::USymEnginePoly
iterator	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef typename list_t::iterator  iterator;$/;"	t	class:Teuchos::std::map
j_	symengine/matrix.h	/^    std::vector<unsigned> j_;$/;"	m	class:SymEngine::CSRMatrix
jackknife	benchmarks/nonius.h++	/^        sample jackknife(Estimator&& estimator, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
jacobi	symengine/ntheory.cpp	/^int jacobi(const Integer &a, const Integer &n)$/;"	f	namespace:SymEngine
jacobian	symengine/dense_matrix.cpp	/^void jacobian(const DenseMatrix &A, const DenseMatrix &x, DenseMatrix &result)$/;"	f	namespace:SymEngine
jacobian	symengine/sparse_matrix.cpp	/^CSRMatrix CSRMatrix::jacobian(const DenseMatrix &A, const DenseMatrix &x)$/;"	f	class:SymEngine::CSRMatrix
jacobian	symengine/sparse_matrix.cpp	/^CSRMatrix CSRMatrix::jacobian(const vec_basic &exprs, const vec_sym &x)$/;"	f	class:SymEngine::CSRMatrix
jscode	symengine/printers/codegen.cpp	/^std::string jscode(const Basic &x)$/;"	f	namespace:SymEngine
julia_str	symengine/printers/strprinter.cpp	/^std::string julia_str(const Basic &x)$/;"	f	namespace:SymEngine
junit_reporter	benchmarks/nonius.h++	/^    struct junit_reporter : reporter {$/;"	s	namespace:nonius
k	benchmarks/nonius.h++	/^        int k;$/;"	m	struct:nonius::chronometer
key_type	symengine/polys/upolybase.h	/^    typedef Key key_type;$/;"	t	class:SymEngine::ODictWrapper
key_type	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef Key key_type;$/;"	t	class:Teuchos::std::map
knownFinalState	symengine/parser/scannerbase.h	/^inline bool ScannerBase::knownFinalState()$/;"	f	class:SymEngine::ScannerBase
kronecker	symengine/ntheory.cpp	/^int kronecker(const Integer &a, const Integer &n)$/;"	f	namespace:SymEngine
kronecker_delta	symengine/functions.cpp	/^RCP<const Basic> kronecker_delta(const RCP<const Basic> &i,$/;"	f	namespace:SymEngine
lambda_real_double_visitor_call	symengine/cwrapper.cpp	/^void lambda_real_double_visitor_call(CLambdaRealDoubleVisitor *self,$/;"	f
lambda_real_double_visitor_free	symengine/cwrapper.cpp	/^void lambda_real_double_visitor_free(CLambdaRealDoubleVisitor *self)$/;"	f
lambda_real_double_visitor_init	symengine/cwrapper.cpp	/^void lambda_real_double_visitor_init(CLambdaRealDoubleVisitor *self,$/;"	f
lambda_real_double_visitor_new	symengine/cwrapper.cpp	/^CLambdaRealDoubleVisitor *lambda_real_double_visitor_new()$/;"	f
lambertw	symengine/functions.cpp	/^RCP<const Basic> lambertw(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
last_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^RCP<StacktraceAddresses> last_stacktrace;$/;"	m	namespace:__anon22	file:
last_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^RCP<StacktraceAddresses> last_stacktrace;$/;"	m	namespace:__anon43	file:
latex	symengine/printers/latex.cpp	/^std::string latex(const Basic &x)$/;"	f	namespace:SymEngine
latex_documents	doc/conf.py	/^latex_documents = [$/;"	v
latex_elements	doc/conf.py	/^latex_elements = {$/;"	v
lcm	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper lcm(const fmpq_poly_wrapper &other) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
lcm	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper lcm(const fmpz_poly_wrapper &other) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
lcm	symengine/ntheory.cpp	/^RCP<const Integer> lcm(const Integer &a, const Integer &b)$/;"	f	namespace:SymEngine
lcm_upoly	symengine/polys/uintpoly_flint.h	/^RCP<const Poly> lcm_upoly(const UFlintPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
lcm_upoly	symengine/polys/uintpoly_piranha.h	/^inline RCP<const UIntPolyPiranha> lcm_upoly(const UIntPolyPiranha &a,$/;"	f	namespace:SymEngine
lcm_upoly	symengine/polys/uintpoly_piranha.h	/^inline RCP<const URatPolyPiranha> lcm_upoly(const URatPolyPiranha &a,$/;"	f	namespace:SymEngine
ldegree	symengine/series_flint.cpp	/^unsigned URatPSeriesFlint::ldegree(const fqp_t &s)$/;"	f	class:SymEngine::URatPSeriesFlint
ldegree	symengine/series_generic.cpp	/^int UnivariateSeries::ldegree(const UExprDict &s)$/;"	f	class:SymEngine::UnivariateSeries
ldegree	symengine/series_piranha.cpp	/^unsigned UPSeriesPiranha::ldegree(const p_expr &s)$/;"	f	class:SymEngine::UPSeriesPiranha
ldegree	symengine/series_piranha.cpp	/^unsigned URatPSeriesPiranha::ldegree(const pp_t &s)$/;"	f	class:SymEngine::URatPSeriesPiranha
leave	symengine/parser/scannerbase.h	/^inline void ScannerBase::leave(int retValue) const$/;"	f	class:SymEngine::ScannerBase
left_open_	symengine/sets.h	/^    bool left_open_, right_open_;$/;"	m	class:SymEngine::Interval
legendre	symengine/ntheory.cpp	/^int legendre(const Integer &a, const Integer &n)$/;"	f	namespace:SymEngine
length	symengine/flint_wrapper.h	/^    long length() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
length	symengine/flint_wrapper.h	/^    long length() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
length	symengine/parser/scannerbase.h	/^        size_t length;$/;"	m	struct:SymEngine::ScannerBase::FinalData
length	symengine/parser/scannerbase.h	/^inline size_t ScannerBase::length() const$/;"	f	class:SymEngine::ScannerBase
levi_civita	symengine/functions.cpp	/^RCP<const Basic> levi_civita(const vec_basic &arg)$/;"	f	namespace:SymEngine
lex	symengine/parser/scanner.h	/^inline int Scanner::lex()$/;"	f	class:SymEngine::Scanner
lex__	symengine/parser/scanner.cpp	/^int Scanner::lex__()$/;"	f	class:SymEngine::Scanner
line	symengine/utilities/catch/catch.hpp	/^        std::size_t line;$/;"	m	struct:Catch::SourceLineInfo
line	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  unsigned int line;$/;"	m	struct:__anon22::line_data	file:
line	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  unsigned int line;$/;"	m	struct:__anon43::line_data	file:
lineInfo	symengine/utilities/catch/catch.hpp	/^        SourceLineInfo lineInfo;$/;"	m	struct:Catch::AssertionInfo
lineNr	symengine/parser/scannerbase.h	/^        size_t lineNr() const$/;"	f	class:SymEngine::ScannerBase::Input
lineNr	symengine/parser/scannerbase.h	/^inline size_t ScannerBase::lineNr() const$/;"	f	class:SymEngine::ScannerBase
line_data	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^struct line_data {$/;"	s	namespace:__anon22	file:
line_data	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^struct line_data {$/;"	s	namespace:__anon43	file:
line_found	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int line_found;$/;"	m	struct:__anon22::line_data	file:
line_found	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  int line_found;$/;"	m	struct:__anon43::line_data	file:
linear_eqns_to_matrix	symengine/solve.cpp	/^linear_eqns_to_matrix(const vec_basic &equations, const vec_sym &syms)$/;"	f	namespace:SymEngine
linsolve	symengine/solve.cpp	/^vec_basic linsolve(const DenseMatrix &system, const vec_sym &syms)$/;"	f	namespace:SymEngine
linsolve	symengine/solve.cpp	/^vec_basic linsolve(const vec_basic &system, const vec_sym &syms)$/;"	f	namespace:SymEngine
linsolve_helper	symengine/solve.cpp	/^vec_basic linsolve_helper(const DenseMatrix &A, const DenseMatrix &b)$/;"	f	namespace:SymEngine
list_	symengine/utilities/teuchos/Teuchos_map.hpp	/^  list_t list_;$/;"	m	class:Teuchos::std::map
list_benchmarks	benchmarks/nonius.h++	/^        bool list_benchmarks = false;$/;"	m	struct:nonius::configuration
list_benchmarks	benchmarks/nonius.h++	/^    inline int list_benchmarks() {$/;"	f	namespace:nonius
list_reporters	benchmarks/nonius.h++	/^        bool list_reporters = false;$/;"	m	struct:nonius::configuration
list_reporters	benchmarks/nonius.h++	/^    inline int list_reporters() {$/;"	f	namespace:nonius
list_t	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef std::list<value_type>  list_t;$/;"	t	class:Teuchos::std::map
literals	symengine/mp_class.h	/^inline namespace literals$/;"	n	namespace:SymEngine
llvm	symengine/llvm_double.h	/^namespace llvm$/;"	n
llvm_double_visitor_call	symengine/cwrapper.cpp	/^void llvm_double_visitor_call(CLLVMDoubleVisitor *self, double *const outs,$/;"	f
llvm_double_visitor_free	symengine/cwrapper.cpp	/^void llvm_double_visitor_free(CLLVMDoubleVisitor *self)$/;"	f
llvm_double_visitor_init	symengine/cwrapper.cpp	/^void llvm_double_visitor_init(CLLVMDoubleVisitor *self, const CVecBasic *args,$/;"	f
llvm_double_visitor_new	symengine/cwrapper.cpp	/^CLLVMDoubleVisitor *llvm_double_visitor_new()$/;"	f
load_symbol_table	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^int load_symbol_table(bfd *abfd, line_data *data)$/;"	f	namespace:__anon22
load_symbol_table	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^int load_symbol_table(bfd *abfd, line_data *data)$/;"	f	namespace:__anon43
loads	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::loads(const std::string &s)$/;"	f	class:SymEngine::LLVMDoubleVisitor
loc_abort_callback_print_stack	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void loc_abort_callback_print_stack(int sig_num)$/;"	f	namespace:__anon22
loc_abort_callback_print_stack	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void loc_abort_callback_print_stack(int sig_num)$/;"	f	namespace:__anon43
loc_enableStackTrace	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^bool& loc_enableStackTrace()$/;"	f	namespace:__anon21
loc_enableStackTrace	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^bool& loc_enableStackTrace()$/;"	f	namespace:__anon42
loc_isTracingActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool& loc_isTracingActiveRCPNodes()$/;"	f	namespace:__anon20
loc_isTracingActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool& loc_isTracingActiveRCPNodes()$/;"	f	namespace:__anon41
loc_printRCPNodeStatisticsOnExit	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool& loc_printRCPNodeStatisticsOnExit()$/;"	f	namespace:__anon20
loc_printRCPNodeStatisticsOnExit	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^bool& loc_printRCPNodeStatisticsOnExit()$/;"	f	namespace:__anon41
loc_rcpNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^Teuchos::RCPNodeTracer::RCPNodeStatistics& loc_rcpNodeStatistics()$/;"	f	namespace:__anon20
loc_rcpNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^Teuchos::RCPNodeTracer::RCPNodeStatistics& loc_rcpNodeStatistics()$/;"	f	namespace:__anon41
loc_segfault_callback_print_stack	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void loc_segfault_callback_print_stack(int sig_num)$/;"	f	namespace:__anon22
loc_segfault_callback_print_stack	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void loc_segfault_callback_print_stack(int sig_num)$/;"	f	namespace:__anon43
local_activeRCPNodesSetup	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^Teuchos::ActiveRCPNodesSetup local_activeRCPNodesSetup;$/;"	m	namespace:__anon19
local_activeRCPNodesSetup	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^Teuchos::ActiveRCPNodesSetup local_activeRCPNodesSetup;$/;"	m	namespace:__anon40
local_stop_	symengine/visitor.h	/^    bool local_stop_;$/;"	m	class:SymEngine::LocalStopVisitor
log	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> log(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
log	symengine/functions.cpp	/^RCP<const Basic> log(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
log	symengine/functions.cpp	/^RCP<const Basic> log(const RCP<const Basic> &arg, const RCP<const Basic> &base)$/;"	f	namespace:SymEngine
log	symengine/series.h	/^    static inline Coeff log(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
log	symengine/series_generic.cpp	/^Expression UnivariateSeries::log(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
log	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::log(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
log_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper log_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
loggamma	symengine/functions.cpp	/^RCP<const Basic> loggamma(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
logical_and	symengine/logic.cpp	/^RCP<const Boolean> logical_and(const set_boolean &s)$/;"	f	namespace:SymEngine
logical_nand	symengine/logic.cpp	/^RCP<const Boolean> logical_nand(const set_boolean &s)$/;"	f	namespace:SymEngine
logical_nor	symengine/logic.cpp	/^RCP<const Boolean> logical_nor(const set_boolean &s)$/;"	f	namespace:SymEngine
logical_not	symengine/logic.cpp	/^RCP<const Boolean> And::logical_not() const$/;"	f	class:SymEngine::And
logical_not	symengine/logic.cpp	/^RCP<const Boolean> Boolean::logical_not() const$/;"	f	class:SymEngine::Boolean
logical_not	symengine/logic.cpp	/^RCP<const Boolean> BooleanAtom::logical_not() const$/;"	f	class:SymEngine::BooleanAtom
logical_not	symengine/logic.cpp	/^RCP<const Boolean> Equality::logical_not() const$/;"	f	class:SymEngine::Equality
logical_not	symengine/logic.cpp	/^RCP<const Boolean> LessThan::logical_not() const$/;"	f	class:SymEngine::LessThan
logical_not	symengine/logic.cpp	/^RCP<const Boolean> Not::logical_not() const$/;"	f	class:SymEngine::Not
logical_not	symengine/logic.cpp	/^RCP<const Boolean> Or::logical_not() const$/;"	f	class:SymEngine::Or
logical_not	symengine/logic.cpp	/^RCP<const Boolean> StrictLessThan::logical_not() const$/;"	f	class:SymEngine::StrictLessThan
logical_not	symengine/logic.cpp	/^RCP<const Boolean> Unequality::logical_not() const$/;"	f	class:SymEngine::Unequality
logical_not	symengine/logic.cpp	/^RCP<const Boolean> logical_not(const RCP<const Boolean> &s)$/;"	f	namespace:SymEngine
logical_or	symengine/logic.cpp	/^RCP<const Boolean> logical_or(const set_boolean &s)$/;"	f	namespace:SymEngine
logical_xnor	symengine/logic.cpp	/^RCP<const Boolean> logical_xnor(const vec_boolean &s)$/;"	f	namespace:SymEngine
logical_xor	symengine/logic.cpp	/^RCP<const Boolean> logical_xor(const vec_boolean &s)$/;"	f	namespace:SymEngine
long_form	benchmarks/nonius.h++	/^            std::string long_form;$/;"	m	struct:nonius::detail::option
long_separator	benchmarks/nonius.h++	/^            std::tuple<bool, std::string::const_iterator> long_separator(std::string const& s) const {$/;"	f	struct:nonius::detail::option
lookup	symengine/parser/parser.cpp	/^int Parser::lookup(bool recovery)$/;"	f	class:SymEngine::Parser
low_mild	benchmarks/nonius.h++	/^        int low_mild = 0;       \/\/ 1.5 to 3 times IQR below Q1$/;"	m	struct:nonius::outlier_classification
low_severe	benchmarks/nonius.h++	/^        int low_severe = 0;     \/\/ more than 3 times IQR below Q1$/;"	m	struct:nonius::outlier_classification
lower_bound	benchmarks/nonius.h++	/^        Duration lower_bound;$/;"	m	struct:nonius::estimate
lowergamma	symengine/functions.cpp	/^RCP<const Basic> lowergamma(const RCP<const Basic> &s,$/;"	f	namespace:SymEngine
luc_matrix	symengine/mp_boost.cpp	/^inline two_by_two_matrix luc_matrix(unsigned long n)$/;"	f	namespace:SymEngine
lucas	symengine/ntheory.cpp	/^RCP<const Integer> lucas(unsigned long n)$/;"	f	namespace:SymEngine
lucas2	symengine/ntheory.cpp	/^void lucas2(const Ptr<RCP<const Integer>> &g, const Ptr<RCP<const Integer>> &s,$/;"	f	namespace:SymEngine
m	symengine/cwrapper.cpp	/^    SymEngine::CSRMatrix m;$/;"	m	struct:CSparseMatrix	file:
m	symengine/cwrapper.cpp	/^    SymEngine::DenseMatrix m;$/;"	m	struct:CDenseMatrix	file:
m	symengine/cwrapper.cpp	/^    SymEngine::LLVMDoubleVisitor m;$/;"	m	struct:CLLVMDoubleVisitor	file:
m	symengine/cwrapper.cpp	/^    SymEngine::LambdaRealDoubleVisitor m;$/;"	m	struct:CLambdaRealDoubleVisitor	file:
m	symengine/cwrapper.cpp	/^    SymEngine::RCP<const SymEngine::Basic> m;$/;"	m	struct:CRCPBasic	file:
m	symengine/cwrapper.cpp	/^    SymEngine::map_basic_basic m;$/;"	m	struct:CMapBasicBasic	file:
m	symengine/cwrapper.cpp	/^    SymEngine::set_basic m;$/;"	m	struct:CSetBasic	file:
m	symengine/cwrapper.cpp	/^    SymEngine::vec_basic m;$/;"	m	struct:CVecBasic	file:
m	symengine/cwrapper.cpp	/^    std::vector<int> m;$/;"	m	struct:CVectorInt	file:
m	symengine/flint_wrapper.h	/^    mpq_t m;$/;"	m	class:SymEngine::mpq_view_flint
m	symengine/flint_wrapper.h	/^    mpz_t m;$/;"	m	class:SymEngine::mpz_view_flint
mC0	symengine/constants.cpp	/^RCP<const Basic> mC0 = mul(minus_one, C0);$/;"	m	namespace:SymEngine	file:
mC1	symengine/constants.cpp	/^RCP<const Basic> mC1 = mul(minus_one, C1);$/;"	m	namespace:SymEngine	file:
mC2	symengine/constants.cpp	/^RCP<const Basic> mC2 = mul(minus_one, C2);$/;"	m	namespace:SymEngine	file:
mC3	symengine/constants.cpp	/^RCP<const Basic> mC3 = mul(minus_one, C3);$/;"	m	namespace:SymEngine	file:
mC4	symengine/constants.cpp	/^RCP<const Basic> mC4 = mul(minus_one, C4);$/;"	m	namespace:SymEngine	file:
mC5	symengine/constants.cpp	/^RCP<const Basic> mC5 = mul(minus_one, C5);$/;"	m	namespace:SymEngine	file:
mC6	symengine/constants.cpp	/^RCP<const Basic> mC6 = mul(minus_one, C6);$/;"	m	namespace:SymEngine	file:
m_	symengine/matrix.h	/^    vec_basic m_;$/;"	m	class:SymEngine::DenseMatrix
m_assertionInfo	symengine/utilities/catch/catch.hpp	/^        AssertionInfo m_assertionInfo;$/;"	m	class:Catch::ResultBuilder
m_bad_cast	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^	explicit m_bad_cast(const std::string&  what_arg ) : msg(what_arg) {}$/;"	f	class:Teuchos::m_bad_cast
m_bad_cast	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^class m_bad_cast : public std::bad_cast {$/;"	c	namespace:Teuchos
m_basic	symengine/expression.h	/^    RCP<const Basic> m_basic;$/;"	m	class:SymEngine::Expression
m_cachedToString	symengine/utilities/catch/catch.hpp	/^            mutable std::string m_cachedToString;$/;"	m	class:Catch::Matchers::Impl::MatcherUntypedBase
m_children	benchmarks/nonius.h++	/^        token_vector m_children ;$/;"	m	class:cpptempl::TokenFor
m_children	benchmarks/nonius.h++	/^        token_vector m_children ;$/;"	m	class:cpptempl::TokenIf
m_count	symengine/utilities/catch/catch.hpp	/^        std::size_t m_count;$/;"	m	struct:Catch::pluralise
m_data	symengine/utilities/catch/catch.hpp	/^        AssertionResultData m_data;$/;"	m	class:Catch::ResultBuilder
m_expr	benchmarks/nonius.h++	/^        std::string m_expr ;$/;"	m	class:cpptempl::TokenIf
m_guardException	symengine/utilities/catch/catch.hpp	/^        bool m_guardException;$/;"	m	class:Catch::ResultBuilder
m_info	symengine/utilities/catch/catch.hpp	/^        AssertionInfo m_info;$/;"	m	class:Catch::AssertionResult
m_items	benchmarks/nonius.h++	/^        data_list m_items ;$/;"	m	class:cpptempl::DataList
m_items	benchmarks/nonius.h++	/^        data_map m_items ;$/;"	m	class:cpptempl::DataMap
m_key	benchmarks/nonius.h++	/^        std::string m_key ;$/;"	m	class:cpptempl::TokenFor
m_key	benchmarks/nonius.h++	/^        std::string m_key ;$/;"	m	class:cpptempl::TokenVar
m_label	symengine/utilities/catch/catch.hpp	/^        std::string m_label;$/;"	m	struct:Catch::pluralise
m_lineInfo	symengine/utilities/catch/catch.hpp	/^        SourceLineInfo m_lineInfo;$/;"	m	class:Catch::NotImplementedException
m_matchers	symengine/utilities/catch/catch.hpp	/^            std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAllOf
m_matchers	symengine/utilities/catch/catch.hpp	/^            std::vector<MatcherBase<ArgT> const*> m_matchers;$/;"	m	struct:Catch::Matchers::Impl::MatchAnyOf
m_method	symengine/utilities/catch/catch.hpp	/^    void (C::*m_method)();$/;"	m	class:Catch::MethodTestCase
m_msg	symengine/symengine_exception.h	/^    std::string m_msg;$/;"	m	class:SymEngine::SymEngineException
m_p	symengine/utilities/catch/catch.hpp	/^        T* m_p;$/;"	m	class:Catch::Ptr
m_rc	symengine/utilities/catch/catch.hpp	/^        mutable unsigned int m_rc;$/;"	m	struct:Catch::SharedImpl
m_reason	benchmarks/nonius.h++	/^        std::string m_reason;$/;"	m	class:cpptempl::TemplateException
m_resultData	symengine/utilities/catch/catch.hpp	/^        AssertionResultData m_resultData;$/;"	m	class:Catch::AssertionResult
m_shouldDebugBreak	symengine/utilities/catch/catch.hpp	/^        bool m_shouldDebugBreak;$/;"	m	class:Catch::ResultBuilder
m_shouldThrow	symengine/utilities/catch/catch.hpp	/^        bool m_shouldThrow;$/;"	m	class:Catch::ResultBuilder
m_stream	symengine/utilities/catch/catch.hpp	/^        static CopyableStream &m_stream()$/;"	f	class:Catch::ResultBuilder
m_text	benchmarks/nonius.h++	/^        std::string m_text ;$/;"	m	class:cpptempl::TokenText
m_type	benchmarks/nonius.h++	/^        std::string m_type ;$/;"	m	class:cpptempl::TokenEnd
m_underlyingMatcher	symengine/utilities/catch/catch.hpp	/^            MatcherBase<ArgT> const& m_underlyingMatcher;$/;"	m	struct:Catch::Matchers::Impl::MatchNotOf
m_usedStream	symengine/utilities/catch/catch.hpp	/^        bool m_usedStream;$/;"	m	class:Catch::ResultBuilder
m_val	benchmarks/nonius.h++	/^        std::string m_val ;$/;"	m	class:cpptempl::TokenFor
m_value	benchmarks/nonius.h++	/^        std::string m_value ;$/;"	m	class:cpptempl::DataValue
m_what	symengine/utilities/catch/catch.hpp	/^        std::string m_what;$/;"	m	class:Catch::NotImplementedException
macroName	symengine/utilities/catch/catch.hpp	/^        char const * macroName;$/;"	m	struct:Catch::AssertionInfo
main	benchmarks/add1.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/eval_double1.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand1.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand2.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand2_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand2b.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand3.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand6.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand6_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand6b.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand6b_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand7.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/expand7_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/lwbench.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/lwbench_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/matrix_add1.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/matrix_add1_ginac.cpp	/^int main()$/;"	f
main	benchmarks/matrix_add2.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/matrix_add2_ginac.cpp	/^int main()$/;"	f
main	benchmarks/matrix_mul1.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/matrix_mul1_ginac.cpp	/^int main()$/;"	f
main	benchmarks/matrix_mul2.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/matrix_mul2_ginac.cpp	/^int main()$/;"	f
main	benchmarks/nonius.h++	/^    inline int main(int argc, char** argv) {$/;"	f	namespace:nonius
main	benchmarks/nonius.h++	/^    int main(std::string const& name, Iterator first, Iterator last) {$/;"	f	namespace:nonius
main	benchmarks/nonius.h++	/^int main(int argc, char** argv) {$/;"	f
main	benchmarks/ntheorybench.cpp	/^int main()$/;"	f
main	benchmarks/parsing.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/series.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/series_expansion_sincos_flint.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/series_expansion_sincos_piranha.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/series_expansion_sinp.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/series_expansion_sinp.cpp	/^int main(int, char *[])$/;"	f
main	benchmarks/symbench.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/symbench_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/symengine_bench.cpp	/^int main(int argc, char *argv[])$/;"	f
main	benchmarks/symengine_bench_ginac.cpp	/^int main(int argc, char *argv[])$/;"	f
main	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^int main(argc, argv) int argc; char *argv[];$/;"	f
main	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^void main() {}$/;"	f
main	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^int main(int argc, char* argv[])$/;"	f
main	build/CMakeFiles/feature_tests.c	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
main	build/CMakeFiles/feature_tests.cxx	/^int main(int argc, char** argv) { (void)argv; return features[argc]; }$/;"	f
main	build/cmake/checkcxx11.cpp	/^int main() {$/;"	f
main	build/cmake/checkgmpxx.cpp	/^int main() {$/;"	f
main	build/cmake/checkstdtostring.cpp	/^int main() {$/;"	f
main	cmake/checkcxx11.cpp	/^int main() {$/;"	f
main	cmake/checkgmpxx.cpp	/^int main() {$/;"	f
main	cmake/checkstdtostring.cpp	/^int main() {$/;"	f
main	symengine/tests/cwrapper/test_cwrapper.c	/^int main(int argc, char *argv[])$/;"	f
main	symengine/utilities/catch/catch.cpp	/^int main(int argc, char* argv[])$/;"	f
makeSafe	symengine/utilities/catch/catch.hpp	/^        static type makeSafe( bool value ) {$/;"	f	class:Catch::SafeBool
make_data	benchmarks/nonius.h++	/^    inline data_ptr make_data(data_list &val)$/;"	f	namespace:cpptempl
make_data	benchmarks/nonius.h++	/^    inline data_ptr make_data(data_map &val)$/;"	f	namespace:cpptempl
make_data	benchmarks/nonius.h++	/^    inline data_ptr make_data(std::string val)$/;"	f	namespace:cpptempl
make_rcp	symengine/symengine_rcp.h	/^inline RCP<T> make_rcp(Args &&... args)$/;"	f	namespace:SymEngine
make_set_union	symengine/sets.cpp	/^RCP<const Set> make_set_union(const set_set &in)$/;"	f	namespace:SymEngine
make_unsigned_imp	symengine/mp_class.h	/^struct make_unsigned_imp<SymEngine::integer_class> {$/;"	s	namespace:boost::detail
man_pages	doc/conf.py	/^man_pages = [$/;"	v
map	symengine/utilities/teuchos/Teuchos_map.hpp	/^    std::map( const std::map<Key,T>& map_in ) : list_( map_in.list_ ) {}$/;"	f	class:Teuchos::std::map::std
map	symengine/utilities/teuchos/Teuchos_map.hpp	/^    std::map() {}$/;"	f	class:Teuchos::std::map::std
map	symengine/utilities/teuchos/Teuchos_map.hpp	/^    virtual ~std::map() {}$/;"	f	class:Teuchos::std::map::~std
map	symengine/utilities/teuchos/Teuchos_map.hpp	/^class std::map {$/;"	c	class:Teuchos::std
map_basic_basic	symengine/dict.h	/^    map_basic_basic;$/;"	t	namespace:SymEngine
map_basic_num	symengine/dict.h	/^    map_basic_num;$/;"	t	namespace:SymEngine
map_int_Expr	symengine/dict.h	/^typedef std::map<int, Expression> map_int_Expr;$/;"	t	namespace:SymEngine
map_integer_uint	symengine/dict.h	/^    map_integer_uint;$/;"	t	namespace:SymEngine
map_uint_mpq	symengine/dict.h	/^typedef std::map<unsigned, rational_class> map_uint_mpq;$/;"	t	namespace:SymEngine
map_uint_mpz	symengine/dict.h	/^typedef std::map<unsigned, integer_class> map_uint_mpz;$/;"	t	namespace:SymEngine
map_vec_mpz	symengine/dict.h	/^typedef std::map<vec_uint, integer_class> map_vec_mpz;$/;"	t	namespace:SymEngine
map_vec_uint	symengine/dict.h	/^typedef std::map<vec_uint, unsigned long long int> map_vec_uint;$/;"	t	namespace:SymEngine
mapbasicbasic_free	symengine/cwrapper.cpp	/^void mapbasicbasic_free(CMapBasicBasic *self)$/;"	f
mapbasicbasic_get	symengine/cwrapper.cpp	/^int mapbasicbasic_get(CMapBasicBasic *self, const basic key, basic mapped)$/;"	f
mapbasicbasic_insert	symengine/cwrapper.cpp	/^void mapbasicbasic_insert(CMapBasicBasic *self, const basic key,$/;"	f
mapbasicbasic_new	symengine/cwrapper.cpp	/^CMapBasicBasic *mapbasicbasic_new()$/;"	f
mapbasicbasic_size	symengine/cwrapper.cpp	/^size_t mapbasicbasic_size(CMapBasicBasic *self)$/;"	f
mapped_type	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef T mapped_type;$/;"	t	class:Teuchos::std::map
master_doc	doc/conf.py	/^master_doc = 'index'$/;"	v
match_common_args	symengine/cse.cpp	/^void match_common_args(const std::string &func_class, const vec_basic &funcs_,$/;"	f	namespace:SymEngine
match_data	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^struct match_data {$/;"	s	namespace:__anon22	file:
match_data	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^struct match_data {$/;"	s	namespace:__anon43	file:
matched	symengine/parser/scannerbase.h	/^inline std::string const &ScannerBase::matched() const$/;"	f	class:SymEngine::std::ScannerBase
matched__	symengine/parser/scanner.cpp	/^size_t ScannerBase::matched__(size_t ch)$/;"	f	class:SymEngine::ScannerBase
matches_long	benchmarks/nonius.h++	/^            bool matches_long(std::string const& s) const {$/;"	f	struct:nonius::detail::option
matches_long	benchmarks/nonius.h++	/^            bool matches_long(std::string const& s, std::string& argument) const {$/;"	f	struct:nonius::detail::option
matches_short	benchmarks/nonius.h++	/^            bool matches_short(std::string const& s) const {$/;"	f	struct:nonius::detail::option
math	symengine/expression.h	/^namespace math$/;"	n	namespace:piranha
math	symengine/polys/uintpoly_piranha.h	/^namespace math$/;"	n	namespace:piranha
mathml	symengine/printers/mathml.cpp	/^std::string mathml(const Basic &x)$/;"	f	namespace:SymEngine
max	symengine/functions.cpp	/^RCP<const Basic> max(const vec_basic &arg)$/;"	f	namespace:SymEngine
maxNumRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    long int maxNumRCPNodes;$/;"	m	struct:Teuchos::RCPNodeTracer::RCPNodeStatistics
maxRetries	bin/appveyor-download.cmd	/^set maxRetries=6$/;"	v
max_abs_coef	symengine/polys/uintpoly.h	/^    integer_class max_abs_coef() const$/;"	f	class:SymEngine::UIntDict
max_coef	symengine/polys/uexprpoly.cpp	/^Expression UExprPoly::max_coef() const$/;"	f	class:SymEngine::UExprPoly
mean	benchmarks/nonius.h++	/^            estimate<double> mean;$/;"	m	struct:nonius::detail::bootstrap_analysis
mean	benchmarks/nonius.h++	/^        Duration mean;$/;"	m	struct:nonius::environment_estimate
mean	benchmarks/nonius.h++	/^        double mean(Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
mean	benchmarks/nonius.h++	/^        estimate<Duration> mean;$/;"	m	struct:nonius::sample_analysis
measure	benchmarks/nonius.h++	/^        TimingOf<Clock, Fun(Args...)> measure(Fun&& fun, Args&&... args) {$/;"	f	namespace:nonius::detail
measure	benchmarks/nonius.h++	/^        void measure(Fun&& fun) { measure(std::forward<Fun>(fun), detail::is_callable<Fun(int)>()); }$/;"	f	struct:nonius::chronometer
measure	benchmarks/nonius.h++	/^        void measure(Fun&& fun, std::false_type) {$/;"	f	struct:nonius::chronometer
measure	benchmarks/nonius.h++	/^        void measure(Fun&& fun, std::true_type) {$/;"	f	struct:nonius::chronometer
measure_environment	benchmarks/nonius.h++	/^        environment<FloatDuration<Clock>> measure_environment(reporter& rep) {$/;"	f	namespace:nonius::detail
measurement_complete	benchmarks/nonius.h++	/^        void measurement_complete(std::vector<fp_seconds> const& samples) {$/;"	f	struct:nonius::reporter
measurement_start	benchmarks/nonius.h++	/^        void measurement_start(execution_plan<fp_seconds> plan) {$/;"	f	struct:nonius::reporter
membuffer	symengine/llvm_double.h	/^    std::string membuffer;$/;"	m	class:SymEngine::LLVMDoubleVisitor
mertens	symengine/ntheory.cpp	/^long mertens(const unsigned long a)$/;"	f	namespace:SymEngine
message	benchmarks/nonius.h++	/^        std::string message;$/;"	m	struct:nonius::timeout_error
message	symengine/utilities/catch/catch.hpp	/^        std::string message;$/;"	m	struct:Catch::AssertionResultData
min	symengine/functions.cpp	/^RCP<const Basic> min(const vec_basic &arg)$/;"	f	namespace:SymEngine
minimum_ticks	benchmarks/nonius.h++	/^        const auto minimum_ticks = 1000;$/;"	m	namespace:nonius::detail
minus_one	symengine/constants.cpp	/^RCP<const Integer> minus_one = integer(-1);$/;"	m	namespace:SymEngine	file:
mismatch	benchmarks/nonius.h++	/^        std::pair<InputIt1, InputIt2> mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2, BinaryPredicate p) {$/;"	f	namespace:nonius::detail
mobius	symengine/ntheory.cpp	/^int mobius(const Integer &a)$/;"	f	namespace:SymEngine
mod	symengine/llvm_double.h	/^    llvm::Module *mod;$/;"	m	class:SymEngine::LLVMDoubleVisitor
mod	symengine/ntheory.cpp	/^RCP<const Integer> mod(const Integer &n, const Integer &d)$/;"	f	namespace:SymEngine
mod_f	symengine/ntheory.cpp	/^RCP<const Integer> mod_f(const Integer &n, const Integer &d)$/;"	f	namespace:SymEngine
mod_inverse	symengine/ntheory.cpp	/^int mod_inverse(const Ptr<RCP<const Integer>> &b, const Integer &a,$/;"	f	namespace:SymEngine
model	benchmarks/nonius.h++	/^                model(Fun const& fun) : fun(fun) {}$/;"	f	struct:nonius::detail::benchmark_function::model
model	benchmarks/nonius.h++	/^                model(Fun&& fun) : fun(std::move(fun)) {}$/;"	f	struct:nonius::detail::benchmark_function::model
model	benchmarks/nonius.h++	/^            struct model : public concept {$/;"	s	struct:nonius::detail::benchmark_function
modulo_	symengine/fields.h	/^    integer_class modulo_;$/;"	m	class:SymEngine::GaloisFieldDict
monomial_mul	symengine/monomials.cpp	/^void monomial_mul(const vec_int &A, const vec_int &B, vec_int &C)$/;"	f	namespace:SymEngine
more	symengine/parser/scannerbase.h	/^inline void ScannerBase::more()$/;"	f	class:SymEngine::ScannerBase
move	symengine/expression.h	/^        : m_basic(std::move(other.m_basic))$/;"	f	class:SymEngine::Expression
move	symengine/fields.h	/^          modulo_(std::move(other.modulo_))$/;"	f	class:SymEngine::GaloisFieldDict
move	symengine/polys/msymenginepoly.h	/^        : UDictWrapper(std::move(other))$/;"	f	class:SymEngine::MExprDict
move	symengine/polys/msymenginepoly.h	/^        : UDictWrapper(std::move(other))$/;"	f	class:SymEngine::MIntDict
move	symengine/polys/uexprpoly.h	/^        : ODictWrapper(std::move(other))$/;"	f	class:SymEngine::UExprDict
move	symengine/polys/uintpoly.h	/^        : ODictWrapper(std::move(other))$/;"	f	class:SymEngine::UIntDict
move	symengine/polys/uratpoly.h	/^        : ODictWrapper(std::move(other))$/;"	f	class:SymEngine::URatDict
mp	symengine/complex_mpc.h	/^    mpc_t mp;$/;"	m	class:SymEngine::mpc_class
mp	symengine/flint_wrapper.h	/^    fmpq_t mp;$/;"	m	class:SymEngine::fmpq_wrapper
mp	symengine/flint_wrapper.h	/^    fmpz_t mp;$/;"	m	class:SymEngine::fmpz_wrapper
mp	symengine/mp_wrapper.h	/^    mpq_t mp;$/;"	m	class:SymEngine::mpq_wrapper
mp	symengine/mp_wrapper.h	/^    mpz_t mp;$/;"	m	class:SymEngine::mpz_wrapper
mp	symengine/real_mpfr.h	/^    mpfr_t mp;$/;"	m	class:SymEngine::mpfr_class
mp_abs	symengine/mp_class.h	/^inline integer_class mp_abs(const integer_class &i)$/;"	f	namespace:SymEngine
mp_abs	symengine/mp_class.h	/^inline rational_class mp_abs(const rational_class &i)$/;"	f	namespace:SymEngine
mp_addmul	symengine/mp_class.h	/^inline void mp_addmul(integer_class &r, const integer_class &a,$/;"	f	namespace:SymEngine
mp_and	symengine/mp_class.h	/^inline void mp_and(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_bin_ui	symengine/mp_boost.cpp	/^void mp_bin_ui(integer_class &res, const integer_class &n, unsigned long r)$/;"	f	namespace:SymEngine
mp_bin_ui	symengine/mp_class.h	/^inline void mp_bin_ui(integer_class &res, const integer_class &n,$/;"	f	namespace:SymEngine
mp_cdiv_q	symengine/mp_class.h	/^inline void mp_cdiv_q(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_cdiv_qr	symengine/mp_boost.cpp	/^void mp_cdiv_qr(integer_class &q, integer_class &r, const integer_class &a,$/;"	f	namespace:SymEngine
mp_cmpabs	symengine/mp_class.h	/^inline int mp_cmpabs(const integer_class &a, const integer_class &b)$/;"	f	namespace:SymEngine
mp_demote	symengine/mp_class.h	/^inline void mp_demote(integer_class &i)$/;"	f	namespace:SymEngine
mp_divexact	symengine/mp_class.h	/^inline void mp_divexact(integer_class &q, const integer_class &a,$/;"	f	namespace:SymEngine
mp_divisible_p	symengine/mp_class.h	/^inline bool mp_divisible_p(const integer_class &a, const integer_class &b)$/;"	f	namespace:SymEngine
mp_fac_ui	symengine/mp_boost.cpp	/^void mp_fac_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_fac_ui	symengine/mp_class.h	/^inline void mp_fac_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_fdiv_q	symengine/mp_class.h	/^inline void mp_fdiv_q(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_fdiv_qr	symengine/mp_boost.cpp	/^void mp_fdiv_qr(integer_class &q, integer_class &r, const integer_class &a,$/;"	f	namespace:SymEngine
mp_fdiv_qr	symengine/mp_class.h	/^inline void mp_fdiv_qr(integer_class &q, integer_class &r,$/;"	f	namespace:SymEngine
mp_fdiv_r	symengine/mp_class.h	/^inline void mp_fdiv_r(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_fib2_ui	symengine/mp_boost.cpp	/^void mp_fib2_ui(integer_class &a, integer_class &b, unsigned long n)$/;"	f	namespace:SymEngine
mp_fib2_ui	symengine/mp_class.h	/^inline void mp_fib2_ui(integer_class &a, integer_class &b, unsigned long n)$/;"	f	namespace:SymEngine
mp_fib_ui	symengine/mp_boost.cpp	/^void mp_fib_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_fib_ui	symengine/mp_class.h	/^inline void mp_fib_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_fits_slong_p	symengine/mp_class.h	/^inline bool mp_fits_slong_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_fits_ulong_p	symengine/mp_class.h	/^inline bool mp_fits_ulong_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_gcd	symengine/mp_class.h	/^inline void mp_gcd(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_gcdext	symengine/mp_boost.cpp	/^void mp_gcdext(integer_class &gcd, integer_class &s, integer_class &t,$/;"	f	namespace:SymEngine
mp_gcdext	symengine/mp_class.h	/^inline void mp_gcdext(integer_class &res, integer_class &r, integer_class &s,$/;"	f	namespace:SymEngine
mp_get_d	symengine/mp_class.h	/^inline double mp_get_d(const integer_class &i)$/;"	f	namespace:SymEngine
mp_get_d	symengine/mp_class.h	/^inline double mp_get_d(const rational_class &i)$/;"	f	namespace:SymEngine
mp_get_si	symengine/mp_class.h	/^inline long mp_get_si(const integer_class &i)$/;"	f	namespace:SymEngine
mp_get_ui	symengine/mp_class.h	/^inline unsigned long mp_get_ui(const integer_class &i)$/;"	f	namespace:SymEngine
mp_invert	symengine/mp_boost.cpp	/^bool mp_invert(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_invert	symengine/mp_class.h	/^inline bool mp_invert(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_jacobi	symengine/mp_boost.cpp	/^int mp_jacobi(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_jacobi	symengine/mp_class.h	/^inline int mp_jacobi(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_kronecker	symengine/mp_boost.cpp	/^int mp_kronecker(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_kronecker	symengine/mp_class.h	/^inline int mp_kronecker(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_lcm	symengine/mp_class.h	/^inline void mp_lcm(integer_class &q, const integer_class &a,$/;"	f	namespace:SymEngine
mp_legendre	symengine/mp_boost.cpp	/^int mp_legendre(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_legendre	symengine/mp_class.h	/^inline int mp_legendre(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
mp_lucnum2_ui	symengine/mp_boost.cpp	/^void mp_lucnum2_ui(integer_class &a, integer_class &b, unsigned long n)$/;"	f	namespace:SymEngine
mp_lucnum2_ui	symengine/mp_class.h	/^inline void mp_lucnum2_ui(integer_class &a, integer_class &b, unsigned long n)$/;"	f	namespace:SymEngine
mp_lucnum_ui	symengine/mp_boost.cpp	/^void mp_lucnum_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_lucnum_ui	symengine/mp_class.h	/^inline void mp_lucnum_ui(integer_class &res, unsigned long n)$/;"	f	namespace:SymEngine
mp_nextprime	symengine/mp_boost.cpp	/^void mp_nextprime(integer_class &res, const integer_class &i)$/;"	f	namespace:SymEngine
mp_nextprime	symengine/mp_class.h	/^inline void mp_nextprime(integer_class &res, const integer_class &i)$/;"	f	namespace:SymEngine
mp_perfect_power_p	symengine/mp_boost.cpp	/^bool mp_perfect_power_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_perfect_power_p	symengine/mp_class.h	/^inline bool mp_perfect_power_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_perfect_square_p	symengine/mp_boost.cpp	/^bool mp_perfect_square_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_perfect_square_p	symengine/mp_class.h	/^inline bool mp_perfect_square_p(const integer_class &i)$/;"	f	namespace:SymEngine
mp_pow_ui	symengine/mp_boost.cpp	/^void mp_pow_ui(rational_class &res, const rational_class &i, unsigned long n)$/;"	f	namespace:SymEngine
mp_pow_ui	symengine/mp_class.h	/^inline void mp_pow_ui(integer_class &res, const integer_class &i,$/;"	f	namespace:SymEngine
mp_pow_ui	symengine/mp_class.h	/^inline void mp_pow_ui(rational_class &res, const rational_class &i,$/;"	f	namespace:SymEngine
mp_powm	symengine/mp_boost.cpp	/^void mp_powm(integer_class &res, const integer_class &base,$/;"	f	namespace:SymEngine
mp_powm	symengine/mp_class.h	/^inline void mp_powm(integer_class &res, const integer_class &a,$/;"	f	namespace:SymEngine
mp_probab_prime_p	symengine/mp_boost.cpp	/^int mp_probab_prime_p(const integer_class &i, unsigned retries)$/;"	f	namespace:SymEngine
mp_probab_prime_p	symengine/mp_class.h	/^inline int mp_probab_prime_p(const integer_class &i, unsigned retries)$/;"	f	namespace:SymEngine
mp_randstate	symengine/mp_class.h	/^    mp_randstate()$/;"	f	class:SymEngine::mp_randstate
mp_randstate	symengine/mp_class.h	/^class mp_randstate$/;"	c	namespace:SymEngine
mp_root	symengine/mp_boost.cpp	/^bool mp_root(integer_class &res, const integer_class &i, const unsigned long n)$/;"	f	namespace:SymEngine
mp_root	symengine/mp_class.h	/^inline bool mp_root(integer_class &res, const integer_class &i, unsigned long n)$/;"	f	namespace:SymEngine
mp_rootrem	symengine/mp_boost.cpp	/^void mp_rootrem(integer_class &a, integer_class &b, const integer_class &i,$/;"	f	namespace:SymEngine
mp_rootrem	symengine/mp_class.h	/^inline void mp_rootrem(integer_class &a, integer_class &b,$/;"	f	namespace:SymEngine
mp_scan1	symengine/mp_boost.cpp	/^unsigned long mp_scan1(const integer_class &i)$/;"	f	namespace:SymEngine
mp_scan1	symengine/mp_class.h	/^inline unsigned long mp_scan1(const integer_class &i)$/;"	f	namespace:SymEngine
mp_set_d	symengine/mp_class.h	/^inline void mp_set_d(integer_class &i, double a)$/;"	f	namespace:SymEngine
mp_sign	symengine/mp_class.h	/^inline int mp_sign(const integer_class &i)$/;"	f	namespace:SymEngine
mp_sign	symengine/mp_class.h	/^inline int mp_sign(const rational_class &i)$/;"	f	namespace:SymEngine
mp_sqrt	symengine/mp_boost.cpp	/^integer_class mp_sqrt(const integer_class &i)$/;"	f	namespace:SymEngine
mp_sqrt	symengine/mp_class.h	/^inline integer_class mp_sqrt(const integer_class &i)$/;"	f	namespace:SymEngine
mp_sqrtrem	symengine/mp_boost.cpp	/^void mp_sqrtrem(integer_class &a, integer_class &b, const integer_class &i)$/;"	f	namespace:SymEngine
mp_sqrtrem	symengine/mp_class.h	/^inline void mp_sqrtrem(integer_class &a, integer_class &b,$/;"	f	namespace:SymEngine
mp_tdiv_qr	symengine/mp_class.h	/^inline void mp_tdiv_qr(integer_class &q, integer_class &r,$/;"	f	namespace:SymEngine
mp_urandomm	symengine/mp_class.h	/^inline void mp_urandomm(integer_class &a, gmp_randstate_t &t,$/;"	f	namespace:SymEngine
mpc_class	symengine/complex_mpc.h	/^    explicit mpc_class(mpc_t m)$/;"	f	class:SymEngine::mpc_class
mpc_class	symengine/complex_mpc.h	/^    explicit mpc_class(mpfr_prec_t prec = 53)$/;"	f	class:SymEngine::mpc_class
mpc_class	symengine/complex_mpc.h	/^    mpc_class(const mpc_class &other)$/;"	f	class:SymEngine::mpc_class
mpc_class	symengine/complex_mpc.h	/^    mpc_class(mpc_class &&other)$/;"	f	class:SymEngine::mpc_class
mpc_class	symengine/complex_mpc.h	/^    mpc_class(std::string s, mpfr_prec_t prec = 53, unsigned base = 10)$/;"	f	class:SymEngine::mpc_class
mpc_class	symengine/complex_mpc.h	/^class mpc_class$/;"	c	namespace:SymEngine
mpfr_class	symengine/real_mpfr.h	/^    explicit mpfr_class(mpfr_prec_t prec = 53)$/;"	f	class:SymEngine::mpfr_class
mpfr_class	symengine/real_mpfr.h	/^    explicit mpfr_class(mpfr_srcptr m)$/;"	f	class:SymEngine::mpfr_class
mpfr_class	symengine/real_mpfr.h	/^    mpfr_class(const mpfr_class &other)$/;"	f	class:SymEngine::mpfr_class
mpfr_class	symengine/real_mpfr.h	/^    mpfr_class(mpfr_class &&other)$/;"	f	class:SymEngine::mpfr_class
mpfr_class	symengine/real_mpfr.h	/^    mpfr_class(std::string s, mpfr_prec_t prec = 53, unsigned base = 10)$/;"	f	class:SymEngine::mpfr_class
mpfr_class	symengine/real_mpfr.h	/^class mpfr_class$/;"	c	namespace:SymEngine
mpq_view_flint	symengine/flint_wrapper.h	/^    mpq_view_flint(const fmpq_wrapper &i)$/;"	f	class:SymEngine::mpq_view_flint
mpq_view_flint	symengine/flint_wrapper.h	/^class mpq_view_flint$/;"	c	namespace:SymEngine
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper()$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper(const T i)$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper(const mpq_t m)$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper(const mpq_wrapper &other)$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper(const mpz_t m)$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^    mpq_wrapper(const mpz_wrapper &n, const mpz_wrapper &d = 1)$/;"	f	class:SymEngine::mpq_wrapper
mpq_wrapper	symengine/mp_wrapper.h	/^class mpq_wrapper$/;"	c	namespace:SymEngine
mpz_view_flint	symengine/flint_wrapper.h	/^    mpz_view_flint(const fmpz_wrapper &i)$/;"	f	class:SymEngine::mpz_view_flint
mpz_view_flint	symengine/flint_wrapper.h	/^class mpz_view_flint$/;"	c	namespace:SymEngine
mpz_wrapper	symengine/mp_wrapper.h	/^    inline mpz_wrapper()$/;"	f	class:SymEngine::mpz_wrapper
mpz_wrapper	symengine/mp_wrapper.h	/^    inline mpz_wrapper(const mpz_t m)$/;"	f	class:SymEngine::mpz_wrapper
mpz_wrapper	symengine/mp_wrapper.h	/^    inline mpz_wrapper(const mpz_wrapper &other)$/;"	f	class:SymEngine::mpz_wrapper
mpz_wrapper	symengine/mp_wrapper.h	/^    inline mpz_wrapper(const std::string &s, unsigned base = 10)$/;"	f	class:SymEngine::mpz_wrapper
mpz_wrapper	symengine/mp_wrapper.h	/^    mpz_wrapper(const T i)$/;"	f	class:SymEngine::mpz_wrapper
mpz_wrapper	symengine/mp_wrapper.h	/^class mpz_wrapper$/;"	c	namespace:SymEngine
msg	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^	std::string msg;$/;"	m	class:Teuchos::m_bad_cast
msubs	symengine/subs.h	/^inline RCP<const Basic> msubs(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
mul	symengine/complex.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::Complex
mul	symengine/complex_double.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const ComplexMPC &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::mul(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/complex_mpc.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
mul	symengine/fields.cpp	/^GaloisFieldDict GaloisFieldDict::mul(const GaloisFieldDict &a,$/;"	f	class:SymEngine::GaloisFieldDict
mul	symengine/infinity.cpp	/^RCP<const Number> Infty::mul(const Number &other) const$/;"	f	class:SymEngine::Infty
mul	symengine/integer.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::Integer
mul	symengine/mul.cpp	/^RCP<const Basic> mul(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	namespace:SymEngine
mul	symengine/mul.cpp	/^RCP<const Basic> mul(const vec_basic &a)$/;"	f	namespace:SymEngine
mul	symengine/nan.cpp	/^RCP<const Number> NaN::mul(const Number &other) const$/;"	f	class:SymEngine::NaN
mul	symengine/polys/msymenginepoly.h	/^    static Wrapper mul(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::UDictWrapper
mul	symengine/polys/uintpoly.h	/^    static UIntDict mul(const UIntDict &a, const UIntDict &b)$/;"	f	class:SymEngine::UIntDict
mul	symengine/polys/upolybase.h	/^    static Wrapper mul(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::ODictWrapper
mul	symengine/rational.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::Rational
mul	symengine/real_double.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::RealDouble
mul	symengine/real_mpfr.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
mul	symengine/series.h	/^    virtual RCP<const Number> mul(const Number &other) const$/;"	f	class:SymEngine::SeriesBase
mul	symengine/series_flint.h	/^    static inline fqp_t mul(const fqp_t &s, const fqp_t &r, unsigned prec)$/;"	f	class:SymEngine::URatPSeriesFlint
mul	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::mul(const UExprDict &a, const UExprDict &b,$/;"	f	class:SymEngine::UnivariateSeries
mul	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::mul(const p_expr &s, const p_expr &r, unsigned prec)$/;"	f	class:SymEngine::UPSeriesPiranha
mul	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::mul(const pp_t &s, const pp_t &r, unsigned prec)$/;"	f	class:SymEngine::URatPSeriesPiranha
mul_dense_dense	symengine/dense_matrix.cpp	/^void mul_dense_dense(const DenseMatrix &A, const DenseMatrix &B, DenseMatrix &C)$/;"	f	namespace:SymEngine
mul_dense_scalar	symengine/dense_matrix.cpp	/^void mul_dense_scalar(const DenseMatrix &A, const RCP<const Basic> &k,$/;"	f	namespace:SymEngine
mul_expand_two	symengine/expand.cpp	/^    void mul_expand_two(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	class:SymEngine::ExpandVisitor
mul_matrix	symengine/dense_matrix.cpp	/^void DenseMatrix::mul_matrix(const MatrixBase &other, MatrixBase &result) const$/;"	f	class:SymEngine::DenseMatrix
mul_matrix	symengine/sparse_matrix.cpp	/^void CSRMatrix::mul_matrix(const MatrixBase &other, MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
mul_mpoly	symengine/polys/msymenginepoly.h	/^RCP<const Poly> mul_mpoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
mul_scalar	symengine/dense_matrix.cpp	/^void DenseMatrix::mul_scalar(const RCP<const Basic> &k,$/;"	f	class:SymEngine::DenseMatrix
mul_scalar	symengine/sparse_matrix.cpp	/^void CSRMatrix::mul_scalar(const RCP<const Basic> &k, MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
mul_upoly	symengine/polys/upolybase.h	/^RCP<const Poly> mul_upoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
mulcomp	symengine/complex.h	/^    inline RCP<const Number> mulcomp(const Complex &other) const$/;"	f	class:SymEngine::Complex
mulcomp	symengine/complex.h	/^    inline RCP<const Number> mulcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
mulcomp	symengine/complex.h	/^    inline RCP<const Number> mulcomp(const Rational &other) const$/;"	f	class:SymEngine::Complex
mulcomp	symengine/complex_double.h	/^    RCP<const Number> mulcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
mulcomp	symengine/complex_double.h	/^    RCP<const Number> mulcomp(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
mulcomp	symengine/complex_double.h	/^    RCP<const Number> mulcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
mulcomp	symengine/complex_double.h	/^    RCP<const Number> mulcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
mulcomp	symengine/complex_double.h	/^    RCP<const Number> mulcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
mulint	symengine/integer.h	/^    inline RCP<const Integer> mulint(const Integer &other) const$/;"	f	class:SymEngine::Integer
mullow	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper mullow(const fmpq_poly_wrapper &o,$/;"	f	class:SymEngine::fmpq_poly_wrapper
mulnum	symengine/number.h	/^inline RCP<const Number> mulnum(const RCP<const Number> &self,$/;"	f	namespace:SymEngine
mulrat	symengine/rational.h	/^    inline RCP<const Number> mulrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
mulrat	symengine/rational.h	/^    inline RCP<const Number> mulrat(const Rational &other) const$/;"	f	class:SymEngine::Rational
mulreal	symengine/real_double.h	/^    RCP<const Number> mulreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
mulreal	symengine/real_double.h	/^    RCP<const Number> mulreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
mulreal	symengine/real_double.h	/^    RCP<const Number> mulreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
mulreal	symengine/real_double.h	/^    RCP<const Number> mulreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealDouble
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
mulreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::mulreal(const RealMPFR &other) const$/;"	f	class:SymEngine::RealMPFR
muls	symengine/cse.cpp	/^    set_basic muls;$/;"	m	class:SymEngine::OptsCSEVisitor	file:
multi_arg_functions	symengine/parser/parser.h	/^        multi_arg_functions = {$/;"	m	class:SymEngine::Parser
multi_arg_functions	symengine/parser/parser_old.cpp	/^        multi_arg_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
multi_arg_set_boolean_functions	symengine/parser/parser.h	/^        multi_arg_set_boolean_functions = {$/;"	m	class:SymEngine::Parser
multi_arg_set_boolean_functions	symengine/parser/parser_old.cpp	/^        multi_arg_set_boolean_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
multi_arg_vec_boolean_functions	symengine/parser/parser.h	/^        multi_arg_vec_boolean_functions = {$/;"	m	class:SymEngine::Parser
multi_arg_vec_boolean_functions	symengine/parser/parser_old.cpp	/^        multi_arg_vec_boolean_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
multieval	symengine/fields.h	/^    vec_integer_class multieval(const vec_integer_class &v) const$/;"	f	class:SymEngine::GaloisField
multieval	symengine/polys/upolybase.h	/^    std::vector<Cf> multieval(const std::vector<Cf> &v) const$/;"	f	class:SymEngine::UNonExprPoly
multinomial_coefficients	symengine/pow.cpp	/^void multinomial_coefficients(unsigned m, unsigned n, map_vec_uint &r)$/;"	f	namespace:SymEngine
multinomial_coefficients_mpz	symengine/pow.cpp	/^void multinomial_coefficients_mpz(unsigned m, unsigned n, map_vec_mpz &r)$/;"	f	namespace:SymEngine
multiple	benchmarks/nonius.h++	/^            bool multiple;$/;"	m	struct:nonius::detail::option
multiplicative_order	symengine/ntheory.cpp	/^bool multiplicative_order(const Ptr<RCP<const Integer>> &o,$/;"	f	namespace:SymEngine
multiply	symengine/expand.cpp	/^    RCP<const Number> multiply = one;$/;"	m	class:SymEngine::ExpandVisitor	file:
multiset_basic	symengine/dict.h	/^typedef std::multiset<RCP<const Basic>, RCPBasicKeyLess> multiset_basic;$/;"	t	namespace:SymEngine
nD_	symengine/solve.cpp	/^    RCP<const Dummy> nD_;$/;"	m	class:SymEngine::InvertComplexVisitor	file:
nPending	symengine/parser/scannerbase.h	/^        size_t nPending() const$/;"	f	class:SymEngine::ScannerBase::Input
n_	symengine/visitor.h	/^    Ptr<const Basic> n_;$/;"	m	class:SymEngine::CoeffVisitor
n_resamples	benchmarks/nonius.h++	/^        int n_resamples = 0;$/;"	m	struct:nonius::standard_reporter
n_samples	benchmarks/nonius.h++	/^        int n_samples = 0;$/;"	m	struct:nonius::standard_reporter
n_samples	benchmarks/nonius.h++	/^        int n_samples;$/;"	m	struct:nonius::csv_reporter
n_samples	benchmarks/nonius.h++	/^        int n_samples;$/;"	m	struct:nonius::html_reporter
n_samples	benchmarks/nonius.h++	/^        int n_samples;$/;"	m	struct:nonius::junit_reporter
name	benchmarks/nonius.h++	/^            std::string name;$/;"	m	struct:nonius::detail::help_text
name	benchmarks/nonius.h++	/^        std::string name;$/;"	m	struct:nonius::benchmark
name	symengine/utilities/catch/catch.hpp	/^    const char* name;$/;"	m	struct:Catch::NameAndDesc
name	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string name() { return "string"; }$/;"	f	class:Teuchos::TypeNameTraits
name	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string name() { return "void*"; }$/;"	f	class:Teuchos::TypeNameTraits
name	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string name() { return TypeNameTraits<T>::name() + "*"; }$/;"	f	class:Teuchos::TypeNameTraits
name	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^  static std::string name()$/;"	f	class:Teuchos::TypeNameTraits
name_	symengine/constants.h	/^    std::string name_;$/;"	m	class:SymEngine::Constant
name_	symengine/functions.h	/^    std::string name_; \/\/! The `f` in `f(x+y, z)`$/;"	m	class:SymEngine::FunctionSymbol
name_	symengine/symbol.h	/^    std::string name_;$/;"	m	class:SymEngine::Symbol
names_	symengine/printers/latex.cpp	/^const std::vector<std::string> LatexPrinter::names_$/;"	m	class:SymEngine::LatexPrinter	file:
names_	symengine/printers/latex.h	/^    static const std::vector<std::string> names_;$/;"	m	class:SymEngine::LatexPrinter
names_	symengine/printers/mathml.cpp	/^const std::vector<std::string> MathMLPrinter::names_$/;"	m	class:SymEngine::MathMLPrinter	file:
names_	symengine/printers/mathml.h	/^    static const std::vector<std::string> names_;$/;"	m	class:SymEngine::MathMLPrinter
names_	symengine/printers/strprinter.cpp	/^const std::vector<std::string> StrPrinter::names_ = init_str_printer_names();$/;"	m	class:SymEngine::StrPrinter	file:
names_	symengine/printers/strprinter.h	/^    static const std::vector<std::string> names_;$/;"	m	class:SymEngine::StrPrinter
ncols	symengine/matrix.h	/^    virtual unsigned ncols() const$/;"	f	class:SymEngine::CSRMatrix
ncols	symengine/matrix.h	/^    virtual unsigned ncols() const$/;"	f	class:SymEngine::DenseMatrix
needs_	symengine/series_visitor.h	/^    bool needs_;$/;"	m	class:SymEngine::NeedsSymbolicExpansionVisitor
needs_symbolic_constants	symengine/series.cpp	/^bool needs_symbolic_constants(const RCP<const Basic> &ex,$/;"	f	namespace:SymEngine
neg	symengine/integer.h	/^    inline RCP<const Integer> neg() const$/;"	f	class:SymEngine::Integer
neg	symengine/mul.cpp	/^RCP<const Basic> neg(const RCP<const Basic> &a)$/;"	f	namespace:SymEngine
neg	symengine/rational.h	/^    inline RCP<const Rational> neg() const$/;"	f	class:SymEngine::Rational
neg_mpoly	symengine/polys/msymenginepoly.h	/^RCP<const Poly> neg_mpoly(const Poly &a)$/;"	f	namespace:SymEngine
neg_upoly	symengine/polys/upolybase.h	/^RCP<const Poly> neg_upoly(const Poly &a)$/;"	f	namespace:SymEngine
negate	symengine/fields.cpp	/^GaloisFieldDict &GaloisFieldDict::negate()$/;"	f	class:SymEngine::GaloisFieldDict
negate	symengine/utilities/catch/catch.hpp	/^        void negate( bool parenthesize ) {$/;"	f	struct:Catch::AssertionResultData
negated	symengine/utilities/catch/catch.hpp	/^        bool negated;$/;"	m	struct:Catch::AssertionResultData
neq	symengine/basic-inl.h	/^inline bool neq(const Basic &a, const Basic &b)$/;"	f	namespace:SymEngine
next	symengine/parser/scanner.cpp	/^size_t ScannerBase::Input::next()$/;"	f	class:SymEngine::ScannerBase::Input
nextToken	symengine/parser/parser.cpp	/^void Parser::nextToken()$/;"	f	class:SymEngine::Parser
next_prime	symengine/ntheory.cpp	/^unsigned Sieve::iterator::next_prime()$/;"	f	class:SymEngine::Sieve::iterator
next_symbol	symengine/cse.cpp	/^    RCP<const Basic> next_symbol()$/;"	f	class:SymEngine::RebuildVisitor
next_symbol_index	symengine/cse.cpp	/^    unsigned next_symbol_index = 0;$/;"	m	class:SymEngine::RebuildVisitor	file:
nextprime	symengine/ntheory.cpp	/^RCP<const Integer> nextprime(const Integer &a)$/;"	f	namespace:SymEngine
noReturn__	symengine/parser/scannerbase.h	/^inline void ScannerBase::noReturn__()$/;"	f	class:SymEngine::ScannerBase
no_analysis	benchmarks/nonius.h++	/^        bool no_analysis = false;$/;"	m	struct:nonius::configuration
no_such_reporter	benchmarks/nonius.h++	/^    struct no_such_reporter : virtual std::exception {$/;"	s	namespace:nonius
nodePtr	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  Teuchos::RCPNode* nodePtr;$/;"	m	struct:__anon20::RCPNodeInfo	file:
nodePtr	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  Teuchos::RCPNode* nodePtr;$/;"	m	struct:__anon41::RCPNodeInfo	file:
node_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  RCPNodeHandle node_; \/\/ NULL if this pointer is null$/;"	m	class:Teuchos::RCP
node_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNode *node_;$/;"	m	class:Teuchos::RCPNodeHandle
node_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNode *node_;$/;"	m	class:Teuchos::RCPNodeThrowDeleter
node_ptr	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNode* node_ptr() const$/;"	f	class:Teuchos::RCPNodeHandle
noexcept	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^    noexcept(false)$/;"	f	namespace:Teuchos
noexcept	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    noexcept(false)$/;"	f	class:Teuchos::RCPNode
nonconst_access_private_node	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCPNodeHandle& RCP<T>::nonconst_access_private_node()$/;"	f	class:Teuchos::RCP
nonius	benchmarks/nonius.h++	/^namespace nonius {$/;"	n
nonnull	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool nonnull( const Ptr<T> &p )$/;"	f	namespace:Teuchos
nonnull	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::nonnull( const RCP<T> &p )$/;"	f	class:Teuchos
now	benchmarks/nonius.h++	/^    struct now {$/;"	s	namespace:nonius
nrows	symengine/matrix.h	/^    virtual unsigned nrows() const$/;"	f	class:SymEngine::CSRMatrix
nrows	symengine/matrix.h	/^    virtual unsigned nrows() const$/;"	f	class:SymEngine::DenseMatrix
nth_root	symengine/number.h	/^    virtual bool nth_root(const Ptr<RCP<const Number>> &, unsigned long n) const$/;"	f	class:SymEngine::Number
nth_root	symengine/rational.cpp	/^bool Rational::nth_root(const Ptr<RCP<const Number>> &the_rat,$/;"	f	class:SymEngine::Rational
ntheory_binomial	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_binomial(basic s, const basic a, unsigned long b)$/;"	f
ntheory_factorial	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_factorial(basic s, unsigned long n)$/;"	f
ntheory_fibonacci	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_fibonacci(basic s, unsigned long a)$/;"	f
ntheory_fibonacci2	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_fibonacci2(basic g, basic s, unsigned long a)$/;"	f
ntheory_gcd	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_gcd(basic s, const basic a, const basic b)$/;"	f
ntheory_gcd_ext	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_gcd_ext(basic g, basic s, basic t, const basic a,$/;"	f
ntheory_lcm	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_lcm(basic s, const basic a, const basic b)$/;"	f
ntheory_lucas	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_lucas(basic s, unsigned long a)$/;"	f
ntheory_lucas2	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_lucas2(basic g, basic s, unsigned long a)$/;"	f
ntheory_mod	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_mod(basic s, const basic n, const basic d)$/;"	f
ntheory_mod_f	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_mod_f(basic s, const basic n, const basic d)$/;"	f
ntheory_mod_inverse	symengine/cwrapper.cpp	/^int ntheory_mod_inverse(basic b, const basic a, const basic m)$/;"	f
ntheory_nextprime	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_nextprime(basic s, const basic a)$/;"	f
ntheory_quotient	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_quotient(basic s, const basic n, const basic d)$/;"	f
ntheory_quotient_f	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_quotient_f(basic s, const basic n, const basic d)$/;"	f
ntheory_quotient_mod	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_quotient_mod(basic q, basic r, const basic n,$/;"	f
ntheory_quotient_mod_f	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE ntheory_quotient_mod_f(basic q, basic r, const basic n,$/;"	f
nthroot_mod	symengine/ntheory.cpp	/^bool nthroot_mod(const Ptr<RCP<const Integer>> &root,$/;"	f	namespace:SymEngine
nthroot_mod_list	symengine/ntheory.cpp	/^void nthroot_mod_list(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine
null	build/cmake/checkcxx11.cpp	/^enum ENull { null };$/;"	e	enum:ENull	file:
null	cmake/checkcxx11.cpp	/^enum ENull { null };$/;"	e	enum:ENull	file:
null	symengine/symengine_rcp.h	/^enum ENull { null };$/;"	e	enum:SymEngine::ENull
null	symengine/utilities/teuchos/Teuchos_ENull.hpp	/^enum ENull { null };$/;"	e	enum:Teuchos::ENull
numActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^int RCPNodeTracer::numActiveRCPNodes()$/;"	f	class:Teuchos::RCPNodeTracer
number	symengine/real_double.cpp	/^RCP<const Number> number(double x)$/;"	f	namespace:SymEngine
number	symengine/real_double.cpp	/^RCP<const Number> number(std::complex<double> x)$/;"	f	namespace:SymEngine
number_is_complex	symengine/cwrapper.cpp	/^int number_is_complex(const basic s)$/;"	f
number_is_negative	symengine/cwrapper.cpp	/^int number_is_negative(const basic s)$/;"	f
number_is_positive	symengine/cwrapper.cpp	/^int number_is_positive(const basic s)$/;"	f
number_is_zero	symengine/cwrapper.cpp	/^int number_is_zero(const basic s)$/;"	f
numer_	symengine/numer_denom.cpp	/^    Ptr<RCP<const Basic>> numer_, denom_;$/;"	m	class:SymEngine::NumerDenomVisitor	file:
numeric_cast	symengine/symengine_casts.h	/^inline To numeric_cast($/;"	f	namespace:SymEngine
numeric_cast	symengine/symengine_casts.h	/^numeric_cast(From f,$/;"	f	namespace:SymEngine
obegin	symengine/fields.h	/^    reverse_iterator obegin() const$/;"	f	class:SymEngine::GaloisField
obegin	symengine/polys/uintpoly_flint.h	/^    r_iterator obegin() const$/;"	f	class:SymEngine::UFlintPoly
obegin	symengine/polys/uintpoly_piranha.h	/^    r_iterator obegin() const$/;"	f	class:SymEngine::UPiranhaPoly
obegin	symengine/polys/usymenginepoly.h	/^    r_iterator obegin() const$/;"	f	class:SymEngine::USymEnginePoly
object_storage	benchmarks/nonius.h++	/^            object_storage() : data() {}$/;"	f	struct:nonius::detail::object_storage
object_storage	benchmarks/nonius.h++	/^            object_storage(const object_storage& other)$/;"	f	struct:nonius::detail::object_storage
object_storage	benchmarks/nonius.h++	/^            object_storage(object_storage&& other)$/;"	f	struct:nonius::detail::object_storage
object_storage	benchmarks/nonius.h++	/^        struct object_storage$/;"	s	namespace:nonius::detail
oend	symengine/fields.h	/^    reverse_iterator oend() const$/;"	f	class:SymEngine::GaloisField
oend	symengine/polys/uintpoly_flint.h	/^    r_iterator oend() const$/;"	f	class:SymEngine::UFlintPoly
oend	symengine/polys/uintpoly_piranha.h	/^    r_iterator oend() const$/;"	f	class:SymEngine::UPiranhaPoly
oend	symengine/polys/usymenginepoly.h	/^    r_iterator oend() const$/;"	f	class:SymEngine::USymEnginePoly
one	symengine/constants.cpp	/^RCP<const Integer> one = integer(1);$/;"	m	namespace:SymEngine	file:
ones	symengine/dense_matrix.cpp	/^void ones(DenseMatrix &A)$/;"	f	namespace:SymEngine
opCast	symengine/utilities/catch/catch.hpp	/^    T& opCast(T const& t) { return const_cast<T&>(t); }$/;"	f	namespace:Catch::Internal
opCast	symengine/utilities/catch/catch.hpp	/^    inline std::nullptr_t opCast(std::nullptr_t) { return nullptr; }$/;"	f	namespace:Catch::Internal
op_precedence	symengine/parser/parser_old.cpp	/^    std::map<std::string, int> op_precedence$/;"	m	class:SymEngine::ExpressionParser	file:
open	symengine/sets.cpp	/^RCP<const Set> Interval::open() const$/;"	f	class:SymEngine::Interval
operator !	symengine/utilities/catch/catch.hpp	/^        MatchNotOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator ! () const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator !	symengine/utilities/catch/catch.hpp	/^        bool operator !() const { return m_p == CATCH_NULL; }$/;"	f	class:Catch::Ptr
operator !=	build/cmake/checkcxx11.cpp	/^    template<class T2> bool operator!=(const RCP<T2> &p2) {$/;"	f	class:RCP
operator !=	cmake/checkcxx11.cpp	/^    template<class T2> bool operator!=(const RCP<T2> &p2) {$/;"	f	class:RCP
operator !=	symengine/expression.h	/^    bool operator!=(const Expression &other) const$/;"	f	class:SymEngine::Expression
operator !=	symengine/fields.h	/^    bool operator!=(const GaloisFieldDict &other) const$/;"	f	class:SymEngine::GaloisFieldDict
operator !=	symengine/flint_wrapper.h	/^    bool operator!=(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator !=	symengine/flint_wrapper.h	/^    inline friend bool operator!=(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator !=	symengine/matrix.h	/^inline bool operator!=(const SymEngine::MatrixBase &lhs,$/;"	f	namespace:SymEngine
operator !=	symengine/mp_wrapper.h	/^    bool operator!=(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator !=	symengine/polys/msymenginepoly.h	/^    bool operator!=(const Wrapper &other) const$/;"	f	class:SymEngine::UDictWrapper
operator !=	symengine/polys/uintpoly_piranha.h	/^    bool operator!=(const PiranhaForIter &rhs)$/;"	f	class:SymEngine::PiranhaForIter
operator !=	symengine/polys/upolybase.h	/^    bool operator!=(const ContainerBaseIter &rhs)$/;"	f	class:SymEngine::ContainerBaseIter
operator !=	symengine/polys/upolybase.h	/^    bool operator!=(const Wrapper &other) const$/;"	f	class:SymEngine::ODictWrapper
operator !=	symengine/symengine_rcp.h	/^    bool operator!=(const RCP<T2> &p2)$/;"	f	class:SymEngine::RCP
operator !=	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool operator!=( const Ptr<T1> &p1, const Ptr<T2> &p2 )$/;"	f	namespace:Teuchos
operator !=	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool operator!=( const Ptr<T> &p, ENull )$/;"	f	namespace:Teuchos
operator !=	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::operator!=( const RCP<T1> &p1, const RCP<T2> &p2 )$/;"	f	class:Teuchos
operator !=	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::operator!=( const RCP<T> &p, ENull )$/;"	f	class:Teuchos
operator !=	symengine/utilities/teuchos/Teuchos_any.hpp	/^inline bool operator!=( const any &a, const any &b )$/;"	f	namespace:Teuchos
operator %	symengine/fields.h	/^    friend GaloisFieldDict operator%(const GaloisFieldDict &a, const T &b)$/;"	f	class:SymEngine::GaloisFieldDict
operator %	symengine/flint_wrapper.h	/^    inline friend fmpz_wrapper operator%(const fmpz_wrapper &a,$/;"	f	class:SymEngine::fmpz_wrapper
operator %=	symengine/fields.h	/^    GaloisFieldDict &operator%=(const GaloisFieldDict &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator %=	symengine/fields.h	/^    GaloisFieldDict &operator%=(const integer_class &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator %=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator%=(const fmpz_wrapper &a)$/;"	f	class:SymEngine::fmpz_wrapper
operator &&	symengine/utilities/catch/catch.hpp	/^            MatchAllOf<ArgT>& operator && ( MatcherBase<ArgT> const& other ) {$/;"	f	struct:Catch::Matchers::Impl::MatchAllOf
operator &&	symengine/utilities/catch/catch.hpp	/^        MatchAllOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator && ( MatcherBase const& other ) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator ()	benchmarks/nonius.h++	/^            void operator()(chronometer meter) const { f->call(meter); }$/;"	f	struct:nonius::detail::benchmark_function
operator ()	benchmarks/nonius.h++	/^            void operator()(int k) const {$/;"	f	struct:nonius::detail::repeater
operator ()	benchmarks/nonius.h++	/^        TimePoint<Clock> operator()() const {$/;"	f	struct:nonius::now
operator ()	benchmarks/nonius.h++	/^        void operator()(chronometer meter) const {$/;"	f	struct:nonius::benchmark
operator ()	symengine/basic-inl.h	/^    std::size_t operator()(const SymEngine::Basic &b) const$/;"	f	struct:std::hash
operator ()	symengine/basic-inl.h	/^hash_t vec_hash<T>::operator()(const T &v) const$/;"	f	class:SymEngine::vec_hash
operator ()	symengine/basic.h	/^    bool operator()(const RCP<const Basic> &x, const RCP<const Basic> &y) const$/;"	f	struct:SymEngine::RCPBasicKeyEq
operator ()	symengine/basic.h	/^    bool operator()(const RCP<const Basic> &x, const RCP<const Basic> &y) const$/;"	f	struct:SymEngine::RCPBasicKeyLess
operator ()	symengine/basic.h	/^    size_t operator()(const RCP<const Basic> &k) const$/;"	f	struct:SymEngine::RCPBasicHash
operator ()	symengine/expression.h	/^    SymEngine::Expression operator()(const SymEngine::Expression &,$/;"	f	struct:piranha::math::partial_impl
operator ()	symengine/expression.h	/^    SymEngine::Expression operator()(const SymEngine::Expression &x,$/;"	f	struct:piranha::math::pow_impl
operator ()	symengine/fields.h	/^        bool operator()(const GaloisFieldDict &a,$/;"	f	struct:SymEngine::GaloisFieldDict::DictLess
operator ()	symengine/fields.h	/^        bool operator()(const std::pair<GaloisFieldDict, unsigned> &a,$/;"	f	struct:SymEngine::GaloisFieldDict::DictLess
operator ()	symengine/integer.h	/^    bool operator()(const RCP<const Integer> &a,$/;"	f	struct:SymEngine::RCPIntegerKeyLess
operator ()	symengine/polys/uintpoly_piranha.h	/^    SymEngine::integer_class operator()(const SymEngine::integer_class &r,$/;"	f	struct:piranha::math::gcd_impl
operator ()	symengine/polys/uintpoly_piranha.h	/^    V operator()(const V &r, const T2 &x) const$/;"	f	struct:piranha::math::pow_impl
operator ()	symengine/polys/uintpoly_piranha.h	/^    operator()(const SymEngine::rational_class &r,$/;"	f	struct:piranha::math::gcd_impl
operator ()	symengine/polys/uintpoly_piranha.h	/^    void operator()(SymEngine::integer_class &r,$/;"	f	struct:piranha::math::divexact_impl
operator ()	symengine/polys/uintpoly_piranha.h	/^    void operator()(SymEngine::rational_class &r,$/;"	f	struct:piranha::math::divexact_impl
operator ()	symengine/printers/strprinter.cpp	/^    bool operator()(const RCP<const Basic> &x, const RCP<const Basic> &y) const$/;"	f	struct:SymEngine::PrinterBasicCmp
operator ()	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Ptr<T> RCP<T>::operator()() const$/;"	f	class:Teuchos::RCP
operator ()	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  bool operator() (const RCP<T1> p1, const RCP<T2> p2) const{$/;"	f	struct:Teuchos::RCPComp
operator ()	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  bool operator() (const RCP<const T1> p1, const RCP<const T2> p2) const{$/;"	f	struct:Teuchos::RCPConstComp
operator ()	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  bool operator()(const rcp_node_list_t::value_type &v1,$/;"	f	class:__anon20::RCPNodeInfoListPred
operator ()	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^  bool operator()(const rcp_node_list_t::value_type &v1,$/;"	f	class:__anon41::RCPNodeInfoListPred
operator *	build/cmake/checkcxx11.cpp	/^    T& operator*() const {$/;"	f	class:RCP
operator *	build/cmake/checkcxx11.cpp	/^    inline T& operator*() const { return *ptr_; }$/;"	f	class:Ptr
operator *	cmake/checkcxx11.cpp	/^    T& operator*() const {$/;"	f	class:RCP
operator *	cmake/checkcxx11.cpp	/^    inline T& operator*() const { return *ptr_; }$/;"	f	class:Ptr
operator *	symengine/expression.h	/^    friend Expression operator*(const Expression &a, const Expression &b)$/;"	f	class:SymEngine::Expression
operator *	symengine/fields.h	/^    friend GaloisFieldDict operator*(const GaloisFieldDict &a,$/;"	f	class:SymEngine::GaloisFieldDict
operator *	symengine/flint_wrapper.h	/^    friend fmpq_poly_wrapper operator*(const fmpq_poly_wrapper &a,$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator *	symengine/flint_wrapper.h	/^    friend fmpq_wrapper operator*(const fmpq_wrapper &a, const fmpq_wrapper &b)$/;"	f	class:SymEngine::fmpq_wrapper
operator *	symengine/flint_wrapper.h	/^    friend fmpz_poly_wrapper operator*(const fmpz_poly_wrapper &a,$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator *	symengine/flint_wrapper.h	/^    inline friend fmpz_wrapper operator*(const fmpz_wrapper &a,$/;"	f	class:SymEngine::fmpz_wrapper
operator *	symengine/mp_boost.cpp	/^    two_by_two_matrix operator*(const two_by_two_matrix &other)$/;"	f	struct:SymEngine::two_by_two_matrix
operator *	symengine/mp_wrapper.h	/^    friend mpq_wrapper operator*(const mpq_wrapper &a, const mpq_wrapper &b)$/;"	f	class:SymEngine::mpq_wrapper
operator *	symengine/polys/msymenginepoly.h	/^    friend Wrapper operator*(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::UDictWrapper
operator *	symengine/polys/uintpoly_piranha.h	/^    std::pair<unsigned int, const Cf &> operator*()$/;"	f	class:SymEngine::PiranhaForIter
operator *	symengine/polys/upolybase.h	/^    friend Wrapper operator*(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::ODictWrapper
operator *	symengine/polys/upolybase.h	/^    std::pair<long, Int> operator*()$/;"	f	class:SymEngine::ContainerBaseIter
operator *	symengine/symengine_rcp.h	/^    T &operator*() const$/;"	f	class:SymEngine::RCP
operator *	symengine/symengine_rcp.h	/^    inline T &operator*() const$/;"	f	class:SymEngine::Ptr
operator *	symengine/utilities/catch/catch.hpp	/^        T& operator*() const { return *m_p; }$/;"	f	class:Catch::Ptr
operator *	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^T& Ptr<T>::operator*() const$/;"	f	class:Teuchos::Ptr
operator *	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T& RCP<T>::operator*() const$/;"	f	class:Teuchos::RCP
operator *=	symengine/expression.h	/^    Expression &operator*=(const Expression &other)$/;"	f	class:SymEngine::Expression
operator *=	symengine/fields.h	/^    GaloisFieldDict &operator*=(const GaloisFieldDict &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator *=	symengine/fields.h	/^    GaloisFieldDict &operator*=(const integer_class &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator *=	symengine/flint_wrapper.h	/^    fmpq_wrapper operator*=(const fmpq_wrapper &a)$/;"	f	class:SymEngine::fmpq_wrapper
operator *=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator*=(const fmpz_wrapper &a)$/;"	f	class:SymEngine::fmpz_wrapper
operator *=	symengine/flint_wrapper.h	/^    void operator*=(const fmpq_poly_wrapper &o)$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator *=	symengine/flint_wrapper.h	/^    void operator*=(const fmpz_poly_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator *=	symengine/mp_wrapper.h	/^    mpq_wrapper operator*=(const mpq_wrapper &a)$/;"	f	class:SymEngine::mpq_wrapper
operator *=	symengine/polys/msymenginepoly.h	/^    Wrapper &operator*=(const Wrapper &other)$/;"	f	class:SymEngine::UDictWrapper
operator *=	symengine/polys/upolybase.h	/^    Wrapper &operator*=(const Wrapper &other)$/;"	f	class:SymEngine::ODictWrapper
operator +	symengine/expression.h	/^    friend Expression operator+(const Expression &a, const Expression &b)$/;"	f	class:SymEngine::Expression
operator +	symengine/fields.h	/^    friend GaloisFieldDict operator+(const GaloisFieldDict &a, const T &b)$/;"	f	class:SymEngine::GaloisFieldDict
operator +	symengine/flint_wrapper.h	/^    friend fmpq_poly_wrapper operator+(const fmpq_poly_wrapper &a,$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator +	symengine/flint_wrapper.h	/^    friend fmpq_wrapper operator+(const fmpq_wrapper &a, const fmpq_wrapper &b)$/;"	f	class:SymEngine::fmpq_wrapper
operator +	symengine/flint_wrapper.h	/^    inline friend fmpz_wrapper operator+(const fmpz_wrapper &a,$/;"	f	class:SymEngine::fmpz_wrapper
operator +	symengine/mp_wrapper.h	/^    friend mpq_wrapper operator+(const mpq_wrapper &a, const mpq_wrapper &b)$/;"	f	class:SymEngine::mpq_wrapper
operator +	symengine/polys/msymenginepoly.h	/^    friend Wrapper operator+(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::UDictWrapper
operator +	symengine/polys/upolybase.h	/^    friend Wrapper operator+(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::ODictWrapper
operator +	symengine/utilities/catch/catch.hpp	/^        std::string operator+() {$/;"	f	struct:Catch::StreamEndStop
operator +	symengine/utilities/catch/catch.hpp	/^    T const& operator + ( T const& value, StreamEndStop ) {$/;"	f	namespace:Catch
operator ++	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator++()$/;"	f	class:SymEngine::fmpz_wrapper
operator ++	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator++(int)$/;"	f	class:SymEngine::fmpz_wrapper
operator ++	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator++()$/;"	f	class:SymEngine::mpz_wrapper
operator ++	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator++(int)$/;"	f	class:SymEngine::mpz_wrapper
operator ++	symengine/polys/uintpoly_piranha.h	/^    PiranhaForIter operator++()$/;"	f	class:SymEngine::PiranhaForIter
operator ++	symengine/polys/upolybase.h	/^    ContainerForIter operator++()$/;"	f	class:SymEngine::ContainerForIter
operator ++	symengine/polys/upolybase.h	/^    ContainerRevIter operator++()$/;"	f	class:SymEngine::ContainerRevIter
operator +=	symengine/expression.h	/^    Expression &operator+=(const Expression &other)$/;"	f	class:SymEngine::Expression
operator +=	symengine/fields.h	/^    GaloisFieldDict &operator+=(const GaloisFieldDict &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator +=	symengine/fields.h	/^    GaloisFieldDict &operator+=(const integer_class &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator +=	symengine/flint_wrapper.h	/^    fmpq_wrapper operator+=(const fmpq_wrapper &a)$/;"	f	class:SymEngine::fmpq_wrapper
operator +=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator+=(const fmpz_wrapper &a)$/;"	f	class:SymEngine::fmpz_wrapper
operator +=	symengine/flint_wrapper.h	/^    void operator+=(const fmpq_poly_wrapper &o)$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator +=	symengine/flint_wrapper.h	/^    void operator+=(const fmpz_poly_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator +=	symengine/mp_wrapper.h	/^    mpq_wrapper operator+=(const mpq_wrapper &a)$/;"	f	class:SymEngine::mpq_wrapper
operator +=	symengine/polys/msymenginepoly.h	/^    Wrapper &operator+=(const Wrapper &other)$/;"	f	class:SymEngine::UDictWrapper
operator +=	symengine/polys/upolybase.h	/^    Wrapper &operator+=(const Wrapper &other)$/;"	f	class:SymEngine::ODictWrapper
operator -	symengine/expression.h	/^    Expression operator-() const$/;"	f	class:SymEngine::Expression
operator -	symengine/expression.h	/^    friend Expression operator-(const Expression &a, const Expression &b)$/;"	f	class:SymEngine::Expression
operator -	symengine/fields.h	/^    GaloisFieldDict operator-() const$/;"	f	class:SymEngine::GaloisFieldDict
operator -	symengine/fields.h	/^    friend GaloisFieldDict operator-(const GaloisFieldDict &a, const T &b)$/;"	f	class:SymEngine::GaloisFieldDict
operator -	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper operator-() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator -	symengine/flint_wrapper.h	/^    fmpq_wrapper operator-() const$/;"	f	class:SymEngine::fmpq_wrapper
operator -	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper operator-() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator -	symengine/flint_wrapper.h	/^    friend fmpq_poly_wrapper operator-(const fmpq_poly_wrapper &a,$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator -	symengine/flint_wrapper.h	/^    friend fmpq_wrapper operator-(const fmpq_wrapper &a, const fmpq_wrapper &b)$/;"	f	class:SymEngine::fmpq_wrapper
operator -	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator-() const$/;"	f	class:SymEngine::fmpz_wrapper
operator -	symengine/flint_wrapper.h	/^    inline friend fmpz_wrapper operator-(const fmpz_wrapper &a,$/;"	f	class:SymEngine::fmpz_wrapper
operator -	symengine/mp_wrapper.h	/^    friend mpq_wrapper operator-(const mpq_wrapper &a, const mpq_wrapper &b)$/;"	f	class:SymEngine::mpq_wrapper
operator -	symengine/mp_wrapper.h	/^    inline friend mpz_wrapper operator-(const T b, const mpz_wrapper &a)$/;"	f	class:SymEngine::mpz_wrapper
operator -	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator-() const$/;"	f	class:SymEngine::mpz_wrapper
operator -	symengine/mp_wrapper.h	/^    mpq_wrapper operator-() const$/;"	f	class:SymEngine::mpq_wrapper
operator -	symengine/polys/msymenginepoly.h	/^    Wrapper operator-() const$/;"	f	class:SymEngine::UDictWrapper
operator -	symengine/polys/msymenginepoly.h	/^    friend Wrapper operator-(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::UDictWrapper
operator -	symengine/polys/upolybase.h	/^    Wrapper operator-() const$/;"	f	class:SymEngine::ODictWrapper
operator -	symengine/polys/upolybase.h	/^    friend Wrapper operator-(const Wrapper &a, const Wrapper &b)$/;"	f	class:SymEngine::ODictWrapper
operator --	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator--()$/;"	f	class:SymEngine::fmpz_wrapper
operator --	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator--(int)$/;"	f	class:SymEngine::fmpz_wrapper
operator --	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator--()$/;"	f	class:SymEngine::mpz_wrapper
operator --	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator--(int)$/;"	f	class:SymEngine::mpz_wrapper
operator -=	symengine/expression.h	/^    Expression &operator-=(const Expression &other)$/;"	f	class:SymEngine::Expression
operator -=	symengine/fields.h	/^    GaloisFieldDict &operator-=(const GaloisFieldDict &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator -=	symengine/fields.h	/^    GaloisFieldDict &operator-=(const integer_class &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator -=	symengine/flint_wrapper.h	/^    fmpq_wrapper operator-=(const fmpq_wrapper &a)$/;"	f	class:SymEngine::fmpq_wrapper
operator -=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator-=(const fmpz_wrapper &a)$/;"	f	class:SymEngine::fmpz_wrapper
operator -=	symengine/flint_wrapper.h	/^    void operator-=(const fmpq_poly_wrapper &o)$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator -=	symengine/flint_wrapper.h	/^    void operator-=(const fmpz_poly_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator -=	symengine/mp_wrapper.h	/^    mpq_wrapper operator-=(const mpq_wrapper &a)$/;"	f	class:SymEngine::mpq_wrapper
operator -=	symengine/polys/msymenginepoly.h	/^    Wrapper &operator-=(const Wrapper &other)$/;"	f	class:SymEngine::UDictWrapper
operator -=	symengine/polys/upolybase.h	/^    Wrapper &operator-=(const Wrapper &other)$/;"	f	class:SymEngine::ODictWrapper
operator ->	benchmarks/nonius.h++	/^        Data* operator ->() {$/;"	f	class:cpptempl::data_ptr
operator ->	build/cmake/checkcxx11.cpp	/^    T* operator->() const {$/;"	f	class:RCP
operator ->	build/cmake/checkcxx11.cpp	/^    inline T* operator->() const { return ptr_; }$/;"	f	class:Ptr
operator ->	cmake/checkcxx11.cpp	/^    T* operator->() const {$/;"	f	class:RCP
operator ->	cmake/checkcxx11.cpp	/^    inline T* operator->() const { return ptr_; }$/;"	f	class:Ptr
operator ->	symengine/polys/uintpoly_piranha.h	/^    std::shared_ptr<std::pair<unsigned int, const Cf &>> operator->()$/;"	f	class:SymEngine::PiranhaForIter
operator ->	symengine/polys/upolybase.h	/^    std::shared_ptr<std::pair<unsigned, Int>> operator->()$/;"	f	class:SymEngine::ContainerBaseIter
operator ->	symengine/symengine_rcp.h	/^    T *operator->() const$/;"	f	class:SymEngine::RCP
operator ->	symengine/symengine_rcp.h	/^    inline T *operator->() const$/;"	f	class:SymEngine::Ptr
operator ->	symengine/utilities/catch/catch.hpp	/^        T* operator->() const { return m_p; }$/;"	f	class:Catch::Ptr
operator ->	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^T* Ptr<T>::operator->() const$/;"	f	class:Teuchos::Ptr
operator ->	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^T* RCP<T>::operator->() const$/;"	f	class:Teuchos::RCP
operator /	symengine/expression.h	/^    friend Expression operator\/(const Expression &a, const Expression &b)$/;"	f	class:SymEngine::Expression
operator /	symengine/fields.h	/^    friend GaloisFieldDict operator\/(const GaloisFieldDict &a, const T &b)$/;"	f	class:SymEngine::GaloisFieldDict
operator /	symengine/flint_wrapper.h	/^    friend fmpq_poly_wrapper operator\/(const fmpq_poly_wrapper &a,$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator /	symengine/flint_wrapper.h	/^    friend fmpq_wrapper operator\/(const fmpq_wrapper &a, const fmpq_wrapper &b)$/;"	f	class:SymEngine::fmpq_wrapper
operator /	symengine/flint_wrapper.h	/^    inline friend fmpz_wrapper operator\/(const fmpz_wrapper &a,$/;"	f	class:SymEngine::fmpz_wrapper
operator /	symengine/mp_wrapper.h	/^    friend mpq_wrapper operator\/(const mpq_wrapper &a, const mpq_wrapper &b)$/;"	f	class:SymEngine::mpq_wrapper
operator /	symengine/polys/uexprpoly.h	/^    friend UExprDict operator\/(const UExprDict &a, const Expression &b)$/;"	f	class:SymEngine::UExprDict
operator /=	symengine/expression.h	/^    Expression &operator\/=(const Expression &other)$/;"	f	class:SymEngine::Expression
operator /=	symengine/fields.h	/^    GaloisFieldDict &operator\/=(const GaloisFieldDict &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator /=	symengine/fields.h	/^    GaloisFieldDict &operator\/=(const integer_class &other)$/;"	f	class:SymEngine::GaloisFieldDict
operator /=	symengine/flint_wrapper.h	/^    fmpq_wrapper operator\/=(const fmpq_wrapper &a)$/;"	f	class:SymEngine::fmpq_wrapper
operator /=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator\/=(const fmpz_wrapper &a)$/;"	f	class:SymEngine::fmpz_wrapper
operator /=	symengine/mp_wrapper.h	/^    mpq_wrapper operator\/=(const mpq_wrapper &a)$/;"	f	class:SymEngine::mpq_wrapper
operator /=	symengine/polys/uexprpoly.h	/^    UExprDict &operator\/=(const Expression &other)$/;"	f	class:SymEngine::UExprDict
operator <	symengine/flint_wrapper.h	/^    bool operator<(const fmpq_poly_wrapper &o) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator <	symengine/flint_wrapper.h	/^    bool operator<(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator <	symengine/flint_wrapper.h	/^    inline friend bool operator<(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator <	symengine/mp_wrapper.h	/^    bool operator<(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator <<	benchmarks/nonius.h++	/^        inline std::ostream& operator<<(std::ostream& os, help_text h) {$/;"	f	namespace:nonius::detail
operator <<	symengine/basic-inl.h	/^inline std::ostream &operator<<(std::ostream &out, const SymEngine::Basic &p)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::map_basic_basic &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::map_basic_num &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::map_int_Expr &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::set_basic &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::umap_basic_num &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::vec_basic &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out, const SymEngine::vec_pair &d)$/;"	f	namespace:SymEngine
operator <<	symengine/dict.cpp	/^std::ostream &operator<<(std::ostream &out,$/;"	f	namespace:SymEngine
operator <<	symengine/expression.h	/^    friend std::ostream &operator<<(std::ostream &os, const Expression &expr)$/;"	f	class:SymEngine::Expression
operator <<	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator<<(unsigned long u) const$/;"	f	class:SymEngine::fmpz_wrapper
operator <<	symengine/matrix.h	/^inline std::ostream &operator<<(std::ostream &out,$/;"	f
operator <<	symengine/mp_wrapper.cpp	/^std::ostream &operator<<(std::ostream &os, const fmpq_wrapper &f)$/;"	f	namespace:SymEngine
operator <<	symengine/mp_wrapper.cpp	/^std::ostream &operator<<(std::ostream &os, const fmpz_wrapper &f)$/;"	f	namespace:SymEngine
operator <<	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator<<(unsigned long u) const$/;"	f	class:SymEngine::mpz_wrapper
operator <<	symengine/polys/uexprpoly.h	/^    friend std::ostream &operator<<(std::ostream &os, const UExprDict &expr)$/;"	f	class:SymEngine::UExprDict
operator <<	symengine/utilities/catch/catch.hpp	/^        ResultBuilder& operator << ( T const& value ) {$/;"	f	class:Catch::ResultBuilder
operator <<	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^std::ostream& Teuchos::operator<<( std::ostream& out, const Ptr<T>& p )$/;"	f	class:Teuchos
operator <<	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^std::ostream& Teuchos::operator<<( std::ostream& out, const RCP<T>& p )$/;"	f	class:Teuchos
operator <<	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^std::ostream& operator<<(std::ostream& out, const RCPNodeHandle& node)$/;"	f	namespace:Teuchos
operator <<	symengine/utilities/teuchos/Teuchos_any.hpp	/^inline std::ostream & operator<<(std::ostream & os, const any &rhs)$/;"	f	namespace:Teuchos
operator <<=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator<<=(unsigned long u)$/;"	f	class:SymEngine::fmpz_wrapper
operator <<=	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator<<=(unsigned long u)$/;"	f	class:SymEngine::mpz_wrapper
operator <=	symengine/flint_wrapper.h	/^    bool operator<=(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator <=	symengine/flint_wrapper.h	/^    inline friend bool operator<=(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator <=	symengine/mp_wrapper.h	/^    bool operator<=(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator =	benchmarks/nonius.h++	/^            benchmark_function& operator=(benchmark_function const& that) {$/;"	f	struct:nonius::detail::benchmark_function
operator =	benchmarks/nonius.h++	/^            benchmark_function& operator=(benchmark_function&& that) {$/;"	f	struct:nonius::detail::benchmark_function
operator =	benchmarks/nonius.h++	/^    inline void data_ptr::operator = (const data_map& data) {$/;"	f	class:cpptempl::data_ptr
operator =	benchmarks/nonius.h++	/^    inline void data_ptr::operator = (const data_ptr& data) {$/;"	f	class:cpptempl::data_ptr
operator =	benchmarks/nonius.h++	/^    inline void data_ptr::operator = (const std::string& data) {$/;"	f	class:cpptempl::data_ptr
operator =	benchmarks/nonius.h++	/^    void data_ptr::operator = (const T& data) {$/;"	f	class:cpptempl::data_ptr
operator =	build/cmake/checkcxx11.cpp	/^    Ptr<T>& operator=(const Ptr<T>& ptr) { ptr_ = ptr.get(); return *this; }$/;"	f	class:Ptr
operator =	build/cmake/checkcxx11.cpp	/^    RCP<T>& operator=(RCP<T> &&r_ptr) {$/;"	f	class:RCP
operator =	build/cmake/checkcxx11.cpp	/^    RCP<T>& operator=(const RCP<T> &r_ptr) {$/;"	f	class:RCP
operator =	cmake/checkcxx11.cpp	/^    Ptr<T>& operator=(const Ptr<T>& ptr) { ptr_ = ptr.get(); return *this; }$/;"	f	class:Ptr
operator =	cmake/checkcxx11.cpp	/^    RCP<T>& operator=(RCP<T> &&r_ptr) {$/;"	f	class:RCP
operator =	cmake/checkcxx11.cpp	/^    RCP<T>& operator=(const RCP<T> &r_ptr) {$/;"	f	class:RCP
operator =	symengine/complex_mpc.h	/^    mpc_class &operator=(const mpc_class &other)$/;"	f	class:SymEngine::mpc_class
operator =	symengine/complex_mpc.h	/^    mpc_class &operator=(mpc_class &&other)$/;"	f	class:SymEngine::mpc_class
operator =	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper &operator=(const fmpq_poly_wrapper &other)$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator =	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper &operator=(fmpq_poly_wrapper &&other)$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator =	symengine/flint_wrapper.h	/^    fmpq_wrapper &operator=(const fmpq_wrapper &other)$/;"	f	class:SymEngine::fmpq_wrapper
operator =	symengine/flint_wrapper.h	/^    fmpz_poly_factor_wrapper &operator=(const fmpz_poly_factor_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
operator =	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper &operator=(const fmpz_poly_wrapper &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator =	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper &operator=(fmpz_poly_wrapper &&other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator =	symengine/flint_wrapper.h	/^    inline fmpz_wrapper &operator=(const fmpz_wrapper &other)$/;"	f	class:SymEngine::fmpz_wrapper
operator =	symengine/mp_boost.cpp	/^    two_by_two_matrix &operator=(const two_by_two_matrix &other)$/;"	f	struct:SymEngine::two_by_two_matrix
operator =	symengine/mp_wrapper.h	/^    inline mpz_wrapper &operator=(T other)$/;"	f	class:SymEngine::mpz_wrapper
operator =	symengine/mp_wrapper.h	/^    inline mpz_wrapper &operator=(const mpz_wrapper &other)$/;"	f	class:SymEngine::mpz_wrapper
operator =	symengine/mp_wrapper.h	/^    mpq_wrapper &operator=(const mpq_wrapper &other)$/;"	f	class:SymEngine::mpq_wrapper
operator =	symengine/parser/parserbase.h	/^inline SType &SType::operator=(Tp_ &&rhs)$/;"	f	class:SymEngine::Meta__::SType
operator =	symengine/polys/msymenginepoly.h	/^    Wrapper &operator=(Wrapper &&other)$/;"	f	class:SymEngine::UDictWrapper
operator =	symengine/real_mpfr.h	/^    mpfr_class &operator=(const mpfr_class &other)$/;"	f	class:SymEngine::mpfr_class
operator =	symengine/real_mpfr.h	/^    mpfr_class &operator=(mpfr_class &&other)$/;"	f	class:SymEngine::mpfr_class
operator =	symengine/sparse_matrix.cpp	/^CSRMatrix &CSRMatrix::operator=(CSRMatrix &&other)$/;"	f	class:SymEngine::CSRMatrix
operator =	symengine/symengine_rcp.h	/^    Ptr<T> &operator=(const Ptr<T> &ptr)$/;"	f	class:SymEngine::Ptr
operator =	symengine/symengine_rcp.h	/^    RCP<T> &operator=(RCP<T> &&r_ptr)$/;"	f	class:SymEngine::RCP
operator =	symengine/symengine_rcp.h	/^    RCP<T> &operator=(const RCP<T> &r_ptr)$/;"	f	class:SymEngine::RCP
operator =	symengine/utilities/catch/catch.hpp	/^        CopyableStream& operator=( CopyableStream const& other ) {$/;"	f	struct:Catch::CopyableStream
operator =	symengine/utilities/catch/catch.hpp	/^        Ptr& operator = ( Ptr const& other ){$/;"	f	class:Catch::Ptr
operator =	symengine/utilities/catch/catch.hpp	/^        Ptr& operator = ( T* p ){$/;"	f	class:Catch::Ptr
operator =	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^Ptr<T>& Ptr<T>::operator=(const Ptr<T>& ptr_in)$/;"	f	class:Teuchos::Ptr
operator =	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>& RCP<T>::operator=(ENull)$/;"	f	class:Teuchos::RCP
operator =	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>& RCP<T>::operator=(const RCP<T>& r_ptr)$/;"	f	class:Teuchos::RCP
operator =	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  RCPNodeHandle& operator=(const RCPNodeHandle& node_ref)$/;"	f	class:Teuchos::RCPNodeHandle
operator =	symengine/utilities/teuchos/Teuchos_any.hpp	/^  any & operator=(const ValueType & rhs)$/;"	f	class:Teuchos::any
operator =	symengine/utilities/teuchos/Teuchos_any.hpp	/^  any & operator=(const any & rhs)$/;"	f	class:Teuchos::any
operator ==	build/cmake/checkcxx11.cpp	/^    template<class T2> bool operator==(const RCP<T2> &p2) {$/;"	f	class:RCP
operator ==	build/cmake/checkcxx11.cpp	/^inline bool operator==(const RCP<T> &p, ENull)$/;"	f
operator ==	cmake/checkcxx11.cpp	/^    template<class T2> bool operator==(const RCP<T2> &p2) {$/;"	f	class:RCP
operator ==	cmake/checkcxx11.cpp	/^inline bool operator==(const RCP<T> &p, ENull)$/;"	f
operator ==	symengine/expression.h	/^    bool operator==(const Expression &other) const$/;"	f	class:SymEngine::Expression
operator ==	symengine/fields.h	/^    bool operator==(const GaloisFieldDict &other) const$/;"	f	class:SymEngine::GaloisFieldDict
operator ==	symengine/flint_wrapper.h	/^    bool operator==(const fmpq_poly_wrapper &o) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
operator ==	symengine/flint_wrapper.h	/^    bool operator==(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator ==	symengine/flint_wrapper.h	/^    bool operator==(const fmpz_poly_wrapper &other) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
operator ==	symengine/flint_wrapper.h	/^    inline friend bool operator==(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator ==	symengine/matrix.h	/^inline bool operator==(const SymEngine::MatrixBase &lhs,$/;"	f	namespace:SymEngine
operator ==	symengine/mp_wrapper.h	/^    bool operator==(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator ==	symengine/polys/msymenginepoly.h	/^    bool operator==(const Wrapper &other) const$/;"	f	class:SymEngine::UDictWrapper
operator ==	symengine/polys/uintpoly_piranha.h	/^    bool operator==(const PiranhaForIter &rhs)$/;"	f	class:SymEngine::PiranhaForIter
operator ==	symengine/polys/upolybase.h	/^    bool operator==(const ContainerBaseIter &rhs)$/;"	f	class:SymEngine::ContainerBaseIter
operator ==	symengine/polys/upolybase.h	/^    bool operator==(const Wrapper &other) const$/;"	f	class:SymEngine::ODictWrapper
operator ==	symengine/symengine_rcp.h	/^    bool operator==(const RCP<T2> &p2)$/;"	f	class:SymEngine::RCP
operator ==	symengine/symengine_rcp.h	/^inline bool operator==(const RCP<T> &p, ENull)$/;"	f	namespace:SymEngine
operator ==	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool operator==( const Ptr<T1> &p1, const Ptr<T2> &p2 )$/;"	f	namespace:Teuchos
operator ==	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^bool operator==( const Ptr<T> &p, ENull )$/;"	f	namespace:Teuchos
operator ==	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::operator==( const RCP<T1> &p1, const RCP<T2> &p2 )$/;"	f	class:Teuchos
operator ==	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool Teuchos::operator==( const RCP<T> &p, ENull )$/;"	f	class:Teuchos
operator ==	symengine/utilities/teuchos/Teuchos_any.hpp	/^inline bool operator==( const any &a, const any &b )$/;"	f	namespace:Teuchos
operator >	symengine/flint_wrapper.h	/^    bool operator>(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator >	symengine/flint_wrapper.h	/^    inline friend bool operator>(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator >	symengine/mp_wrapper.h	/^    bool operator>(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator >=	symengine/flint_wrapper.h	/^    bool operator>=(const fmpq_wrapper &other) const$/;"	f	class:SymEngine::fmpq_wrapper
operator >=	symengine/flint_wrapper.h	/^    inline friend bool operator>=(const fmpz_wrapper &a, const fmpz_wrapper &b)$/;"	f	class:SymEngine::fmpz_wrapper
operator >=	symengine/mp_wrapper.h	/^    bool operator>=(const mpq_wrapper &other) const$/;"	f	class:SymEngine::mpq_wrapper
operator >>	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator>>(unsigned long u) const$/;"	f	class:SymEngine::fmpz_wrapper
operator >>	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator>>(unsigned long u) const$/;"	f	class:SymEngine::mpz_wrapper
operator >>=	symengine/flint_wrapper.h	/^    inline fmpz_wrapper operator>>=(unsigned long u)$/;"	f	class:SymEngine::fmpz_wrapper
operator >>=	symengine/mp_wrapper.h	/^    inline mpz_wrapper operator>>=(unsigned long u)$/;"	f	class:SymEngine::mpz_wrapper
operator SafeBool::type	symengine/utilities/catch/catch.hpp	/^        operator SafeBool::type() const { return SafeBool::makeSafe( m_p != CATCH_NULL ); }$/;"	f	class:Catch::Ptr
operator []	benchmarks/nonius.h++	/^    inline data_ptr& data_map::operator [](const std::string& key) {$/;"	f	class:cpptempl::data_map
operator []	symengine/utilities/teuchos/Teuchos_map.hpp	/^    mapped_type& operator[]( const key_type& k )$/;"	f	class:Teuchos::std::map
operator environment_estimate<Duration2>	benchmarks/nonius.h++	/^        operator environment_estimate<Duration2>() const {$/;"	f	struct:nonius::environment_estimate
operator estimate<Duration2>	benchmarks/nonius.h++	/^        operator estimate<Duration2>() const {$/;"	f	struct:nonius::estimate
operator execution_plan<Duration2>	benchmarks/nonius.h++	/^        operator execution_plan<Duration2>() const {$/;"	f	struct:nonius::execution_plan
operator mpq_srcptr	symengine/flint_wrapper.h	/^    operator mpq_srcptr() const$/;"	f	class:SymEngine::mpq_view_flint
operator mpz_srcptr	symengine/flint_wrapper.h	/^    operator mpz_srcptr() const$/;"	f	class:SymEngine::mpz_view_flint
operator sample_analysis<Duration2>	benchmarks/nonius.h++	/^        operator sample_analysis<Duration2>() const {$/;"	f	struct:nonius::sample_analysis
operator |	symengine/utilities/catch/catch.hpp	/^    inline ResultDisposition::Flags operator | ( ResultDisposition::Flags lhs, ResultDisposition::Flags rhs ) {$/;"	f	namespace:Catch
operator ||	symengine/utilities/catch/catch.hpp	/^            MatchAnyOf<ArgT>& operator || ( MatcherBase<ArgT> const& other ) {$/;"	f	struct:Catch::Matchers::Impl::MatchAnyOf
operator ||	symengine/utilities/catch/catch.hpp	/^        MatchAnyOf<ComparatorT> MatcherBase<ObjectT, ComparatorT>::operator || ( MatcherBase const& other ) const {$/;"	f	class:Catch::Matchers::Impl::MatcherBase
operator_end	symengine/parser/parser_old.cpp	/^    std::vector<int> operator_end;$/;"	m	class:SymEngine::ExpressionParser	file:
operator_error	symengine/parser/parser_old.cpp	/^    bool operator_error(std::string prev, std::string current)$/;"	f	class:SymEngine::ExpressionParser	file:
optInArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> optInArg( T& arg )$/;"	f	namespace:Teuchos
opt_cse	symengine/cse.cpp	/^umap_basic_basic opt_cse(const vec_basic &exprs)$/;"	f	namespace:SymEngine
opt_subs	symengine/cse.cpp	/^    umap_basic_basic &opt_subs;$/;"	m	class:SymEngine::OptsCSEVisitor	file:
opt_subs	symengine/cse.cpp	/^    umap_basic_basic &opt_subs;$/;"	m	class:SymEngine::RebuildVisitor	file:
option	benchmarks/nonius.h++	/^            option(std::string long_form, std::string short_form, std::string description, std::string argument = std::string(), bool multiple = false)$/;"	f	struct:nonius::detail::option
option	benchmarks/nonius.h++	/^        struct option {$/;"	s	namespace:nonius::detail
options	benchmarks/nonius.h++	/^            option_set const& options;$/;"	m	struct:nonius::detail::help_text
order	symengine/diophantine.cpp	/^bool order(const DenseMatrix &t, const std::vector<DenseMatrix> &basis,$/;"	f	namespace:SymEngine
ordered_compare	symengine/dict.h	/^inline int ordered_compare(const T &A, const T &B)$/;"	f	namespace:SymEngine
ordered_eq	symengine/dict.h	/^inline bool ordered_eq(const T &A, const T &B)$/;"	f	namespace:SymEngine
os	benchmarks/nonius.h++	/^        std::function<std::ostream&()> os;$/;"	m	struct:nonius::reporter
oss	symengine/utilities/catch/catch.hpp	/^        std::ostringstream oss;$/;"	m	struct:Catch::CopyableStream
other	symengine/parser/parserbase.h	/^    Base(Base const &other) = delete;$/;"	m	class:SymEngine::Meta__::Base
other	symengine/parser/scannerbase.h	/^    ScannerBase(ScannerBase const &other) = delete;$/;"	m	class:SymEngine::ScannerBase
other	symengine/utilities/catch/catch.hpp	/^        SourceLineInfo(SourceLineInfo const& other)          = default;$/;"	m	struct:Catch::SourceLineInfo
out	symengine/parser/scannerbase.h	/^inline std::ostream &ScannerBase::out()$/;"	f	class:SymEngine::ScannerBase
outArg	build/cmake/checkcxx11.cpp	/^Ptr<T> outArg( T& arg )$/;"	f
outArg	cmake/checkcxx11.cpp	/^Ptr<T> outArg( T& arg )$/;"	f
outArg	symengine/symengine_rcp.h	/^inline Ptr<T> outArg(T &arg)$/;"	f	namespace:SymEngine
outArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> outArg( T& arg )$/;"	f	namespace:Teuchos
outlier_classification	benchmarks/nonius.h++	/^    struct outlier_classification {$/;"	s	namespace:nonius
outlier_variance	benchmarks/nonius.h++	/^            double outlier_variance;$/;"	m	struct:nonius::detail::bootstrap_analysis
outlier_variance	benchmarks/nonius.h++	/^        double outlier_variance;$/;"	m	struct:nonius::sample_analysis
outlier_variance	benchmarks/nonius.h++	/^        inline double outlier_variance(estimate<double> mean, estimate<double> stddev, int n) {$/;"	f	namespace:nonius::detail
outliers	benchmarks/nonius.h++	/^        outlier_classification outliers;$/;"	m	struct:nonius::environment_estimate
outliers	benchmarks/nonius.h++	/^        outlier_classification outliers;$/;"	m	struct:nonius::sample_analysis
output_file	benchmarks/nonius.h++	/^        std::string output_file;$/;"	m	struct:nonius::configuration
override	build/cmake/checkcxx11.cpp	/^    virtual void print() override;$/;"	m	class:B	file:
override	cmake/checkcxx11.cpp	/^    virtual void print() override;$/;"	m	class:B	file:
p	symengine/series_visitor.h	/^    Poly p;$/;"	m	class:SymEngine::SeriesVisitor
p_	symengine/matrix.h	/^    std::vector<unsigned> p_;$/;"	m	class:SymEngine::CSRMatrix
p_	symengine/series.h	/^    const Poly p_;$/;"	m	class:SymEngine::SeriesBase
p_pushStream	symengine/parser/scanner.cpp	/^void ScannerBase::p_pushStream(std::string const &name, std::istream *streamPtr)$/;"	f	class:SymEngine::ScannerBase
parenthesize	symengine/printers/latex.cpp	/^std::string LatexPrinter::parenthesize(const std::string &expr)$/;"	f	class:SymEngine::LatexPrinter
parenthesize	symengine/printers/strprinter.cpp	/^std::string StrPrinter::parenthesize(const std::string &x)$/;"	f	class:SymEngine::StrPrinter
parenthesizeLE	symengine/printers/strprinter.cpp	/^std::string StrPrinter::parenthesizeLE(const RCP<const Basic> &x,$/;"	f	class:SymEngine::StrPrinter
parenthesizeLT	symengine/printers/strprinter.cpp	/^std::string StrPrinter::parenthesizeLT(const RCP<const Basic> &x,$/;"	f	class:SymEngine::StrPrinter
parenthesized	symengine/utilities/catch/catch.hpp	/^        bool parenthesized;$/;"	m	struct:Catch::AssertionResultData
parse	benchmarks/nonius.h++	/^            static bool parse(std::string const&) { return true; }$/;"	f	struct:nonius::detail::parser
parse	benchmarks/nonius.h++	/^            static double parse(std::string const& s) { return std::stod(s); }$/;"	f	struct:nonius::detail::parser
parse	benchmarks/nonius.h++	/^            static int parse(std::string const& s) { return std::stoi(s); }$/;"	f	struct:nonius::detail::parser
parse	benchmarks/nonius.h++	/^            static std::string parse(std::string const& s) { return s; }$/;"	f	struct:nonius::detail::parser
parse	benchmarks/nonius.h++	/^        void parse(T& variable, detail::arguments& args, std::string const& option) {$/;"	f	namespace:nonius::detail
parse	benchmarks/nonius.h++	/^        void parse(T& variable, detail::arguments& args, std::string const& option, Predicate&& is_valid) {$/;"	f	namespace:nonius::detail
parse	benchmarks/nonius.h++	/^    inline std::string parse(std::string templ_text, data_map &data)$/;"	f	namespace:cpptempl
parse	benchmarks/nonius.h++	/^    inline void parse(std::ostream &stream, std::string templ_text, data_map &data)$/;"	f	namespace:cpptempl
parse	symengine/parser/parser.cpp	/^int Parser::parse() try {$/;"	f	class:SymEngine::Parser
parse_args	benchmarks/nonius.h++	/^        configuration parse_args(std::string const& name, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
parse_arguments	benchmarks/nonius.h++	/^        arguments parse_arguments(option_set const& options, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
parse_expr	symengine/parser/parser_old.cpp	/^    RCP<const Basic> parse_expr(const std::string &in)$/;"	f	class:SymEngine::ExpressionParser
parse_long	benchmarks/nonius.h++	/^        inline void parse_long(option const& o, arguments& args, std::string&& arg) {$/;"	f	namespace:nonius::detail
parse_old	symengine/parser/parser_old.cpp	/^RCP<const Basic> parse_old(const std::string &s, bool convert_xor)$/;"	f	namespace:SymEngine
parse_short	benchmarks/nonius.h++	/^        void parse_short(option const& o, arguments& args, Iterator& first, Iterator last) {$/;"	f	namespace:nonius::detail
parse_string	symengine/parser/parser_old.cpp	/^    RCP<const Basic> parse_string(unsigned int l, unsigned int h)$/;"	f	class:SymEngine::ExpressionParser	file:
parse_tree	benchmarks/nonius.h++	/^    inline void parse_tree(token_vector &tokens, token_vector &tree, TokenType until)$/;"	f	namespace:cpptempl
parse_val	benchmarks/nonius.h++	/^    inline data_ptr parse_val(std::string key, data_map &data)$/;"	f	namespace:cpptempl
parser	benchmarks/nonius.h++	/^        struct parser<bool> {$/;"	s	namespace:nonius::detail
parser	benchmarks/nonius.h++	/^        struct parser<double> {$/;"	s	namespace:nonius::detail
parser	benchmarks/nonius.h++	/^        struct parser<int> {$/;"	s	namespace:nonius::detail
parser	benchmarks/nonius.h++	/^        struct parser<std::string> {$/;"	s	namespace:nonius::detail
partial_impl	symengine/expression.h	/^struct partial_impl<T, typename std::$/;"	s	namespace:piranha::math
percentage	benchmarks/nonius.h++	/^        inline std::string percentage(double d) {$/;"	f	namespace:nonius::detail
percentage_ratio	benchmarks/nonius.h++	/^        inline std::string percentage_ratio(double part, double whole) {$/;"	f	namespace:nonius::detail
perfect_power	symengine/integer.cpp	/^bool perfect_power(const Integer &n)$/;"	f	namespace:SymEngine
perfect_square	symengine/integer.cpp	/^bool perfect_square(const Integer &n)$/;"	f	namespace:SymEngine
performOptionalSelector	symengine/utilities/catch/catch.hpp	/^inline id performOptionalSelector( id obj, SEL sel ) {$/;"	f
permuteFwd	symengine/dense_matrix.cpp	/^void permuteFwd(DenseMatrix &A, permutelist &pl)$/;"	f	namespace:SymEngine
permutelist	symengine/matrix.h	/^typedef std::vector<std::pair<int, int>> permutelist;$/;"	t	namespace:SymEngine
pi	symengine/constants.cpp	/^RCP<const Constant> pi = constant("pi");$/;"	m	namespace:SymEngine	file:
piecewise	symengine/logic.h	/^inline RCP<const Basic> piecewise(PiecewiseVec &&vec)$/;"	f	namespace:SymEngine
piranha	symengine/expression.h	/^namespace piranha$/;"	n
piranha	symengine/polys/uintpoly_piranha.h	/^namespace piranha$/;"	n
pivot	symengine/dense_matrix.cpp	/^unsigned pivot(DenseMatrix &B, unsigned r, unsigned c)$/;"	f	namespace:SymEngine
pivoted_LU	symengine/dense_matrix.cpp	/^void pivoted_LU(const DenseMatrix &A, DenseMatrix &L, DenseMatrix &U,$/;"	f	namespace:SymEngine
pivoted_LU	symengine/dense_matrix.cpp	/^void pivoted_LU(const DenseMatrix &A, DenseMatrix &LU, permutelist &pl)$/;"	f	namespace:SymEngine
pivoted_LU_solve	symengine/dense_matrix.cpp	/^void pivoted_LU_solve(const DenseMatrix &A, const DenseMatrix &b,$/;"	f	namespace:SymEngine
pivoted_fraction_free_gauss_jordan_elimination	symengine/dense_matrix.cpp	/^void pivoted_fraction_free_gauss_jordan_elimination(const DenseMatrix &A,$/;"	f	namespace:SymEngine
pivoted_fraction_free_gaussian_elimination	symengine/dense_matrix.cpp	/^void pivoted_fraction_free_gaussian_elimination(const DenseMatrix &A,$/;"	f	namespace:SymEngine
pivoted_gauss_jordan_elimination	symengine/dense_matrix.cpp	/^void pivoted_gauss_jordan_elimination(const DenseMatrix &A, DenseMatrix &B,$/;"	f	namespace:SymEngine
pivoted_gaussian_elimination	symengine/dense_matrix.cpp	/^void pivoted_gaussian_elimination(const DenseMatrix &A, DenseMatrix &B,$/;"	f	namespace:SymEngine
placeholder	symengine/utilities/teuchos/Teuchos_any.hpp	/^  class placeholder$/;"	c	class:Teuchos::any
pluralise	symengine/utilities/catch/catch.hpp	/^    struct pluralise {$/;"	s	namespace:Catch
point	benchmarks/nonius.h++	/^        Duration point;$/;"	m	struct:nonius::estimate
poly	symengine/flint_wrapper.h	/^    fmpq_poly_t poly;$/;"	m	class:SymEngine::fmpq_poly_wrapper
poly	symengine/flint_wrapper.h	/^    fmpz_poly_t poly;$/;"	m	class:SymEngine::fmpz_poly_wrapper
poly_	symengine/polys/msymenginepoly.h	/^    Container poly_;$/;"	m	class:SymEngine::MSymEnginePoly
poly_	symengine/polys/upolybase.h	/^    Container poly_;$/;"	m	class:SymEngine::UPolyBase
poly_mul	symengine/rings.cpp	/^void poly_mul(const umap_vec_mpz &A, const umap_vec_mpz &B, umap_vec_mpz &C)$/;"	f	namespace:SymEngine
poly_print	symengine/expression.cpp	/^std::string poly_print(const Expression &x)$/;"	f	namespace:SymEngine::detail
polygamma	symengine/functions.cpp	/^RCP<const Basic> polygamma(const RCP<const Basic> &n_,$/;"	f	namespace:SymEngine
popStream	symengine/parser/scanner.cpp	/^bool ScannerBase::popStream()$/;"	f	class:SymEngine::ScannerBase
popToken__	symengine/parser/parser.cpp	/^void ParserBase::popToken__()$/;"	f	class:SymEngine::ParserBase
pop__	symengine/parser/parser.cpp	/^void ParserBase::pop__(size_t count)$/;"	f	class:SymEngine::ParserBase
positive_root	symengine/mp_boost.cpp	/^bool positive_root(integer_class &res, const integer_class &i,$/;"	f	namespace:SymEngine
postCode	symengine/parser/scanner.h	/^inline void Scanner::postCode(PostEnum__ type)$/;"	f	class:SymEngine::Scanner
postorder_traversal	symengine/visitor.cpp	/^void postorder_traversal(const Basic &b, Visitor &v)$/;"	f	namespace:SymEngine
postorder_traversal_stop	symengine/visitor.cpp	/^void postorder_traversal_stop(const Basic &b, StopVisitor &v)$/;"	f	namespace:SymEngine
pow	symengine/complex.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::Complex
pow	symengine/complex_double.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const ComplexMPC &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::pow(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/complex_mpc.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
pow	symengine/fields.h	/^    static GaloisFieldDict pow(const GaloisFieldDict &a, unsigned int p)$/;"	f	class:SymEngine::GaloisFieldDict
pow	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper pow(unsigned int n) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
pow	symengine/flint_wrapper.h	/^    fmpz_poly_wrapper pow(unsigned int n) const$/;"	f	class:SymEngine::fmpz_poly_wrapper
pow	symengine/infinity.cpp	/^RCP<const Number> Infty::pow(const Number &other) const$/;"	f	class:SymEngine::Infty
pow	symengine/integer.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::Integer
pow	symengine/mp_boost.cpp	/^    two_by_two_matrix pow(unsigned long n)$/;"	f	struct:SymEngine::two_by_two_matrix
pow	symengine/mp_boost.cpp	/^integer_class pow(const integer_class &a, unsigned long b)$/;"	f	namespace:SymEngine
pow	symengine/nan.cpp	/^RCP<const Number> NaN::pow(const Number &other) const$/;"	f	class:SymEngine::NaN
pow	symengine/polys/msymenginepoly.h	/^    static Wrapper pow(const Wrapper &a, unsigned int p)$/;"	f	class:SymEngine::UDictWrapper
pow	symengine/polys/upolybase.h	/^    static Wrapper pow(const Wrapper &a, unsigned int p)$/;"	f	class:SymEngine::ODictWrapper
pow	symengine/pow.cpp	/^RCP<const Basic> pow(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	namespace:SymEngine
pow	symengine/rational.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::Rational
pow	symengine/real_double.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::RealDouble
pow	symengine/real_mpfr.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
pow	symengine/series.h	/^    virtual RCP<const Number> pow(const Number &other) const$/;"	f	class:SymEngine::SeriesBase
pow	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::pow(const fqp_t &s, int n, unsigned prec)$/;"	f	class:SymEngine::URatPSeriesFlint
pow	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::pow(const UExprDict &base, int exp, unsigned prec)$/;"	f	class:SymEngine::UnivariateSeries
pow	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::pow(const p_expr &s, int n, unsigned prec)$/;"	f	class:SymEngine::UPSeriesPiranha
pow	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::pow(const pp_t &s, int n, unsigned prec)$/;"	f	class:SymEngine::URatPSeriesPiranha
pow_ex	symengine/expression.h	/^inline Expression pow_ex(const Expression &base, const Expression &exp)$/;"	f	namespace:SymEngine
pow_expand	symengine/expand.cpp	/^    void pow_expand(umap_basic_num &base_dict, unsigned n)$/;"	f	class:SymEngine::ExpandVisitor
pow_impl	symengine/expression.h	/^struct pow_impl<T, U,$/;"	s	namespace:piranha::math
pow_impl	symengine/polys/uintpoly_piranha.h	/^struct pow_impl<V, U,$/;"	s	namespace:piranha::math
pow_mpoly	symengine/polys/msymenginepoly.h	/^RCP<const Poly> pow_mpoly(const Poly &a, unsigned int n)$/;"	f	namespace:SymEngine
pow_negint	symengine/integer.cpp	/^RCP<const Number> Integer::pow_negint(const Integer &other) const$/;"	f	class:SymEngine::Integer
pow_number	symengine/complex.cpp	/^RCP<const Number> pow_number(const Complex &x, unsigned long n)$/;"	f	namespace:SymEngine
pow_upoly	symengine/fields.h	/^inline RCP<const GaloisField> pow_upoly(const GaloisField &a, unsigned int p)$/;"	f	namespace:SymEngine
pow_upoly	symengine/polys/uintpoly_flint.h	/^RCP<const Poly> pow_upoly(const UFlintPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
pow_upoly	symengine/polys/uintpoly_piranha.h	/^RCP<const Poly> pow_upoly(const UPiranhaPoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
pow_upoly	symengine/polys/usymenginepoly.h	/^RCP<const Poly> pow_upoly(const USymEnginePoly<Container, BaseType, Poly> &a,$/;"	f	namespace:SymEngine
powcomp	symengine/complex.cpp	/^RCP<const Number> Complex::powcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
powcomp	symengine/complex_double.h	/^    RCP<const Number> powcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
powcomp	symengine/complex_double.h	/^    RCP<const Number> powcomp(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
powcomp	symengine/complex_double.h	/^    RCP<const Number> powcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
powcomp	symengine/complex_double.h	/^    RCP<const Number> powcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
powcomp	symengine/complex_double.h	/^    RCP<const Number> powcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
power_num	symengine/mul.cpp	/^void Mul::power_num(const Ptr<RCP<const Number>> &coef, map_basic_basic &d,$/;"	f	class:SymEngine::Mul
powermod	symengine/ntheory.cpp	/^bool powermod(const Ptr<RCP<const Integer>> &powm, const RCP<const Integer> &a,$/;"	f	namespace:SymEngine
powermod_list	symengine/ntheory.cpp	/^void powermod_list(std::vector<RCP<const Integer>> &pows,$/;"	f	namespace:SymEngine
powint	symengine/integer.h	/^    inline RCP<const Number> powint(const Integer &other) const$/;"	f	class:SymEngine::Integer
pownum	symengine/number.h	/^inline RCP<const Number> pownum(const RCP<const Number> &self,$/;"	f	namespace:SymEngine
powrat	symengine/rational.cpp	/^RCP<const Basic> Rational::powrat(const Rational &other) const$/;"	f	class:SymEngine::Rational
powrat	symengine/rational.h	/^    inline RCP<const Number> powrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
powreal	symengine/real_double.h	/^    RCP<const Number> powreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
powreal	symengine/real_double.h	/^    RCP<const Number> powreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
powreal	symengine/real_double.h	/^    RCP<const Number> powreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
powreal	symengine/real_double.h	/^    RCP<const Number> powreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealDouble
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
powreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::powreal(const RealMPFR &other) const$/;"	f	class:SymEngine::RealMPFR
prat2synum	symengine/tests/basic/test_series_expansion_URatP.cpp	/^static inline RCP<const Number> prat2synum(const piranha::rational &p_rat)$/;"	f	file:
preCode	symengine/parser/scanner.h	/^inline void Scanner::preCode()$/;"	f	class:SymEngine::Scanner
prePostDestroy_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  EPrePostDestruction prePostDestroy_;$/;"	m	class:Teuchos::EmbeddedObjDealloc
pre_delete_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void pre_delete_extra_data()$/;"	f	class:Teuchos::RCPNode
prec	symengine/series_visitor.h	/^    const unsigned prec;$/;"	m	class:SymEngine::SeriesVisitor
prec_	symengine/eval_arb.cpp	/^    long prec_;$/;"	m	class:SymEngine::EvalArbVisitor	file:
precedence	symengine/printers/strprinter.h	/^    PrecedenceEnum precedence;$/;"	m	class:SymEngine::Precedence
preorder_traversal	symengine/visitor.cpp	/^void preorder_traversal(const Basic &b, Visitor &v)$/;"	f	namespace:SymEngine
preorder_traversal_local_stop	symengine/visitor.cpp	/^void preorder_traversal_local_stop(const Basic &b, LocalStopVisitor &v)$/;"	f	namespace:SymEngine
preorder_traversal_stop	symengine/visitor.cpp	/^void preorder_traversal_stop(const Basic &b, StopVisitor &v)$/;"	f	namespace:SymEngine
prepare	benchmarks/nonius.h++	/^        execution_plan<FloatDuration<Clock>> prepare(configuration cfg, environment<FloatDuration<Clock>> env) const {$/;"	f	struct:nonius::benchmark
pretty_duration	benchmarks/nonius.h++	/^        inline std::string pretty_duration(fp_seconds secs) {$/;"	f	namespace:nonius::detail
prime_factor_multiplicities	symengine/ntheory.cpp	/^void prime_factor_multiplicities(map_integer_uint &primes_mul, const Integer &n)$/;"	f	namespace:SymEngine
prime_factors	symengine/ntheory.cpp	/^void prime_factors(std::vector<RCP<const Integer>> &prime_list,$/;"	f	namespace:SymEngine
primitive_root	symengine/ntheory.cpp	/^bool primitive_root(const Ptr<RCP<const Integer>> &g, const Integer &n)$/;"	f	namespace:SymEngine
primitive_root_list	symengine/ntheory.cpp	/^void primitive_root_list(std::vector<RCP<const Integer>> &roots,$/;"	f	namespace:SymEngine
print	symengine/parser/scanner.h	/^inline void Scanner::print()$/;"	f	class:SymEngine::Scanner
print	symengine/utilities/teuchos/Teuchos_any.hpp	/^    void print(std::ostream & os) const$/;"	f	class:Teuchos::any::holder
print	symengine/utilities/teuchos/Teuchos_any.hpp	/^  void print(std::ostream& os) const$/;"	f	class:Teuchos::any
printActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::printActiveRCPNodes(std::ostream &out)$/;"	f	class:Teuchos::RCPNodeTracer
printRCPNodeStatistics	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::printRCPNodeStatistics($/;"	f	class:Teuchos::RCPNodeTracer
print__	symengine/parser/parser.cpp	/^void Parser::print__()$/;"	f	class:SymEngine::Parser
print__	symengine/parser/scanner.cpp	/^void ScannerBase::print__() const$/;"	f	class:SymEngine::ScannerBase
print_coefficient_impl	symengine/expression.h	/^struct print_coefficient_impl<U, typename std::$/;"	s	namespace:piranha
print_div	symengine/printers/latex.cpp	/^std::string LatexPrinter::print_div(const std::string &num,$/;"	f	class:SymEngine::LatexPrinter
print_div	symengine/printers/strprinter.cpp	/^std::string StrPrinter::print_div(const std::string &num,$/;"	f	class:SymEngine::StrPrinter
print_double	symengine/printers/strprinter.cpp	/^std::string print_double(double d)$/;"	f	namespace:SymEngine
print_environment_estimate	benchmarks/nonius.h++	/^        void print_environment_estimate(environment_estimate<fp_seconds> e, int iterations) {$/;"	f	struct:nonius::standard_reporter
print_help	benchmarks/nonius.h++	/^    inline int print_help(std::string const& name) {$/;"	f	namespace:nonius
print_map	symengine/dict.cpp	/^inline std::ostream &print_map(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon26
print_map	symengine/dict.cpp	/^inline std::ostream &print_map(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon5
print_map_rcp	symengine/dict.cpp	/^inline std::ostream &print_map_rcp(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon26
print_map_rcp	symengine/dict.cpp	/^inline std::ostream &print_map_rcp(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon5
print_mul	symengine/printers/latex.cpp	/^std::string LatexPrinter::print_mul()$/;"	f	class:SymEngine::LatexPrinter
print_mul	symengine/printers/strprinter.cpp	/^std::string StrPrinter::print_mul()$/;"	f	class:SymEngine::StrPrinter
print_outlier_count	benchmarks/nonius.h++	/^        void print_outlier_count(const char* description, int count, int total) {$/;"	f	struct:nonius::standard_reporter
print_outliers	benchmarks/nonius.h++	/^        void print_outliers(outlier_classification o) {$/;"	f	struct:nonius::standard_reporter
print_rational_class	symengine/printers/latex.cpp	/^void print_rational_class(const rational_class &r, std::ostringstream &s)$/;"	f	namespace:SymEngine
print_stack_on_segfault	symengine/symengine_rcp.cpp	/^void print_stack_on_segfault()$/;"	f	namespace:SymEngine
print_stack_on_segfault	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void Teuchos::print_stack_on_segfault()$/;"	f	class:Teuchos
print_statistic_estimate	benchmarks/nonius.h++	/^        void print_statistic_estimate(const char* name, estimate<fp_seconds> estimate) {$/;"	f	struct:nonius::standard_reporter
print_vec	symengine/dict.cpp	/^inline std::ostream &print_vec(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon26
print_vec	symengine/dict.cpp	/^inline std::ostream &print_vec(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon5
print_vec_rcp	symengine/dict.cpp	/^inline std::ostream &print_vec_rcp(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon26
print_vec_rcp	symengine/dict.cpp	/^inline std::ostream &print_vec_rcp(std::ostream &out, T &d)$/;"	f	namespace:SymEngine::__anon5
print_with_args	symengine/printers/latex.cpp	/^void LatexPrinter::print_with_args(const Basic &x, const std::string &join,$/;"	f	class:SymEngine::LatexPrinter
probab_prime_p	symengine/ntheory.cpp	/^int probab_prime_p(const Integer &a, unsigned reps)$/;"	f	namespace:SymEngine
process_section	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void process_section(bfd *abfd, asection *section, void *_data)$/;"	f	namespace:__anon22
process_section	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void process_section(bfd *abfd, asection *section, void *_data)$/;"	f	namespace:__anon43
progress_stream	benchmarks/nonius.h++	/^        std::ostream& progress_stream() {$/;"	f	struct:nonius::reporter
project	doc/conf.py	/^project = u'SymEngine'$/;"	v
ptr	benchmarks/nonius.h++	/^        std::shared_ptr<Data> ptr;$/;"	m	class:cpptempl::data_ptr
ptr	build/cmake/checkcxx11.cpp	/^    Ptr<T> ptr() const { return Ptr<T>(get()); }$/;"	f	class:RCP
ptr	build/cmake/checkcxx11.cpp	/^    inline const Ptr<T> ptr() const { return *this; }$/;"	f	class:Ptr
ptr	cmake/checkcxx11.cpp	/^    Ptr<T> ptr() const { return Ptr<T>(get()); }$/;"	f	class:RCP
ptr	cmake/checkcxx11.cpp	/^    inline const Ptr<T> ptr() const { return *this; }$/;"	f	class:Ptr
ptr	symengine/flint_wrapper.h	/^    mpz_srcptr ptr = nullptr;$/;"	m	class:SymEngine::mpz_view_flint
ptr	symengine/symengine_rcp.h	/^    Ptr<T> ptr() const$/;"	f	class:SymEngine::RCP
ptr	symengine/symengine_rcp.h	/^    inline const Ptr<T> ptr() const$/;"	f	class:SymEngine::Ptr
ptr	symengine/utilities/teuchos/Teuchos_Ptr.hpp	/^const Ptr<T> Ptr<T>::ptr() const$/;"	f	class:Teuchos::Ptr
ptr	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> ptr( T* p )$/;"	f	namespace:Teuchos
ptr	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Ptr<T> RCP<T>::ptr() const$/;"	f	class:Teuchos::RCP
ptrFromRef	symengine/symengine_rcp.h	/^inline Ptr<T> ptrFromRef(T &arg)$/;"	f	namespace:SymEngine
ptrFromRef	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T> ptrFromRef( T& arg )$/;"	f	namespace:Teuchos
ptrInArg	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<const T> ptrInArg( T& arg )$/;"	f	namespace:Teuchos
ptr_	build/cmake/checkcxx11.cpp	/^    T *ptr_;$/;"	m	class:Ptr	file:
ptr_	build/cmake/checkcxx11.cpp	/^    T *ptr_;$/;"	m	class:RCP	file:
ptr_	cmake/checkcxx11.cpp	/^    T *ptr_;$/;"	m	class:Ptr	file:
ptr_	cmake/checkcxx11.cpp	/^    T *ptr_;$/;"	m	class:RCP	file:
ptr_	symengine/polys/uintpoly_piranha.h	/^    ptr_type ptr_;$/;"	m	class:SymEngine::PiranhaForIter
ptr_	symengine/polys/upolybase.h	/^    RCP<const T> ptr_;$/;"	m	class:SymEngine::ContainerBaseIter
ptr_	symengine/symengine_rcp.h	/^    RCP(RCP<T> &&rp) SYMENGINE_NOEXCEPT : ptr_(rp.ptr_)$/;"	f	class:SymEngine::RCP
ptr_	symengine/symengine_rcp.h	/^    SYMENGINE_NOEXCEPT : ptr_(r_ptr.get())$/;"	f	class:SymEngine::RCP
ptr_	symengine/symengine_rcp.h	/^    T *ptr_;$/;"	m	class:SymEngine::Ptr
ptr_	symengine/symengine_rcp.h	/^    T *ptr_;$/;"	m	class:SymEngine::RCP
ptr_	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^  T *ptr_;$/;"	m	class:Teuchos::Ptr
ptr_	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  T *ptr_; \/\/ NULL if this pointer is null$/;"	m	class:Teuchos::RCP
ptr_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  T *ptr_;$/;"	m	class:Teuchos::RCPNodeTmpl
ptr_const_cast	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T2> ptr_const_cast(const Ptr<T1>& p1)$/;"	f	namespace:Teuchos
ptr_dynamic_cast	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T2> ptr_dynamic_cast($/;"	f	namespace:Teuchos
ptr_implicit_cast	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T2> ptr_implicit_cast(const Ptr<T1>& p1)$/;"	f	namespace:Teuchos
ptr_static_cast	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^Ptr<T2> ptr_static_cast(const Ptr<T1>& p1)$/;"	f	namespace:Teuchos
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T ptr_t;$/;"	t	class:Teuchos::DeallocArrayDelete
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T ptr_t;$/;"	t	class:Teuchos::DeallocDelete
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T ptr_t;$/;"	t	class:Teuchos::DeallocFunctorDelete
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T ptr_t;$/;"	t	class:Teuchos::DeallocFunctorHandleDelete
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef T ptr_t;$/;"	t	class:Teuchos::DeallocNull
ptr_t	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  typedef typename Dealloc::ptr_t ptr_t;$/;"	t	class:Teuchos::EmbeddedObjDealloc
ptr_type	symengine/polys/uintpoly_piranha.h	/^    typedef decltype(std::declval<Container &>()._container().begin()) ptr_type;$/;"	t	class:SymEngine::PiranhaForIter
push	symengine/parser/scannerbase.h	/^inline void ScannerBase::push(size_t ch)$/;"	f	class:SymEngine::ScannerBase
push	symengine/parser/scannerbase.h	/^inline void ScannerBase::push(std::string const &str)$/;"	f	class:SymEngine::ScannerBase
pushStream	symengine/parser/scanner.cpp	/^void ScannerBase::pushStream(std::istream &istr)$/;"	f	class:SymEngine::ScannerBase
pushStream	symengine/parser/scanner.cpp	/^void ScannerBase::pushStream(std::string const &name)$/;"	f	class:SymEngine::ScannerBase
pushToken__	symengine/parser/parser.cpp	/^void ParserBase::pushToken__(int token)$/;"	f	class:SymEngine::ParserBase
push__	symengine/parser/parser.cpp	/^void ParserBase::push__(size_t state)$/;"	f	class:SymEngine::ParserBase
push_back	benchmarks/nonius.h++	/^    inline void data_ptr::push_back(const data_ptr& data) {$/;"	f	class:cpptempl::data_ptr
pushedInput	symengine/parser/scannerbase.h	/^        Input pushedInput;$/;"	m	struct:SymEngine::ScannerBase::StreamStruct
pushedName	symengine/parser/scannerbase.h	/^        std::string pushedName;$/;"	m	struct:SymEngine::ScannerBase::StreamStruct
pygments_style	doc/conf.py	/^pygments_style = 'sphinx'$/;"	v
qnxnto	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
qnxnto	build/CMakeFiles/3.13.3/CompilerIdCXX/CMakeCXXCompilerId.cpp	/^char const* qnxnto = "INFO" ":" "qnxnto[]";$/;"	v
quadratic_residues	symengine/ntheory.cpp	/^vec_integer_class quadratic_residues(const Integer &a)$/;"	f	namespace:SymEngine
quo_upoly	symengine/polys/upolybase.h	/^RCP<const Poly> quo_upoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
quotient	symengine/ntheory.cpp	/^RCP<const Integer> quotient(const Integer &n, const Integer &d)$/;"	f	namespace:SymEngine
quotient_f	symengine/ntheory.cpp	/^RCP<const Integer> quotient_f(const Integer &n, const Integer &d)$/;"	f	namespace:SymEngine
quotient_mod	symengine/ntheory.cpp	/^void quotient_mod(const Ptr<RCP<const Integer>> &q,$/;"	f	namespace:SymEngine
quotient_mod_f	symengine/ntheory.cpp	/^void quotient_mod_f(const Ptr<RCP<const Integer>> &q,$/;"	f	namespace:SymEngine
r_iterator	symengine/polys/uintpoly_flint.h	/^    typedef ContainerRevIter<Poly, Cf> r_iterator;$/;"	t	class:SymEngine::UFlintPoly
r_iterator	symengine/polys/uintpoly_piranha.h	/^    typedef ContainerRevIter<Poly, const Cf &> r_iterator;$/;"	t	class:SymEngine::UPiranhaPoly
r_iterator	symengine/polys/usymenginepoly.h	/^    typedef typename std::map<Key, Cf>::const_reverse_iterator r_iterator;$/;"	t	class:SymEngine::USymEnginePoly
rank	symengine/dense_matrix.cpp	/^unsigned DenseMatrix::rank() const$/;"	f	class:SymEngine::DenseMatrix
rank	symengine/sparse_matrix.cpp	/^unsigned CSRMatrix::rank() const$/;"	f	class:SymEngine::CSRMatrix
rational	symengine/rational.h	/^inline RCP<const Number> rational(long n, long d)$/;"	f	namespace:SymEngine
rational_class	symengine/mp_class.h	/^        rational_class;$/;"	t	namespace:SymEngine
rational_get_mpq	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE rational_get_mpq(mpq_t a, const basic s)$/;"	f
rational_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE rational_set(basic s, const basic a, const basic b)$/;"	f
rational_set_mpq	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE rational_set_mpq(basic s, const mpq_t i)$/;"	f
rational_set_si	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE rational_set_si(basic s, long a, long b)$/;"	f
rational_set_ui	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE rational_set_ui(basic s, unsigned long a, unsigned long b)$/;"	f
rawMemoryToString	symengine/utilities/catch/catch.hpp	/^    std::string rawMemoryToString( const T& object ) {$/;"	f	namespace:Catch::Detail
rcp	build/cmake/checkcxx11.cpp	/^inline RCP<T> rcp(T* p)$/;"	f
rcp	cmake/checkcxx11.cpp	/^inline RCP<T> rcp(T* p)$/;"	f
rcp	symengine/symengine_rcp.h	/^inline RCP<T> rcp(T *p)$/;"	f	namespace:SymEngine
rcp	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcp( T* p, bool owns_mem )$/;"	f	class:Teuchos
rcp	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^RCP<T> rcp( T* p, Dealloc_T dealloc, bool owns_mem )$/;"	f	namespace:Teuchos
rcpCloneNode	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpCloneNode(const RCP<T> &p)$/;"	f	class:Teuchos
rcpFromPtr	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^RCP<T> rcpFromPtr( const Ptr<T>& ptr )$/;"	f	namespace:Teuchos
rcpFromRef	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpFromRef( T& r )$/;"	f	class:Teuchos
rcpFromUndefRef	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpFromUndefRef( T& r )$/;"	f	class:Teuchos
rcpWithDealloc	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithDealloc( T* p, Dealloc_T dealloc, bool owns_mem )$/;"	f	class:Teuchos
rcpWithDeallocUndef	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithDeallocUndef( T* p, Dealloc_T dealloc, bool owns_mem )$/;"	f	class:Teuchos
rcpWithEmbeddedObj	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithEmbeddedObj( T* p, const Embedded &embedded, bool owns_mem )$/;"	f	class:Teuchos
rcpWithEmbeddedObjPostDestroy	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithEmbeddedObjPostDestroy($/;"	f	class:Teuchos
rcpWithEmbeddedObjPreDestroy	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithEmbeddedObjPreDestroy($/;"	f	class:Teuchos
rcpWithInvertedObjOwnership	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcpWithInvertedObjOwnership(const RCP<T> &child,$/;"	f	class:Teuchos
rcp_	symengine/utilities/teuchos/Teuchos_PtrDecl.hpp	/^  RCP<T> rcp_;$/;"	m	class:Teuchos::Ptr
rcp_const_cast	build/cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_const_cast(const RCP<T1>& p1)$/;"	f
rcp_const_cast	cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_const_cast(const RCP<T1>& p1)$/;"	f
rcp_const_cast	symengine/symengine_rcp.h	/^inline RCP<T2> rcp_const_cast(const RCP<T1> &p1)$/;"	f	namespace:SymEngine
rcp_const_cast	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcp_const_cast(const RCP<T1>& p1)$/;"	f	class:Teuchos
rcp_dynamic_cast	build/cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_dynamic_cast(const RCP<T1>& p1)$/;"	f
rcp_dynamic_cast	cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_dynamic_cast(const RCP<T1>& p1)$/;"	f
rcp_dynamic_cast	symengine/symengine_rcp.h	/^inline RCP<T2> rcp_dynamic_cast(const RCP<T1> &p1)$/;"	f	namespace:SymEngine
rcp_dynamic_cast	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcp_dynamic_cast(const RCP<T1>& p1, bool throw_on_fail)$/;"	f	class:Teuchos
rcp_from_this	symengine/symengine_rcp.h	/^    inline RCP<T> rcp_from_this()$/;"	f	class:SymEngine::EnableRCPFromThis
rcp_from_this	symengine/symengine_rcp.h	/^    inline RCP<const T> rcp_from_this() const$/;"	f	class:SymEngine::EnableRCPFromThis
rcp_from_this_cast	symengine/symengine_rcp.h	/^    inline RCP<const T2> rcp_from_this_cast() const$/;"	f	class:SymEngine::EnableRCPFromThis
rcp_implicit_cast	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcp_implicit_cast(const RCP<T1>& p1)$/;"	f	class:Teuchos
rcp_node_list	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^rcp_node_list_t*& rcp_node_list()$/;"	f	namespace:__anon20
rcp_node_list	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^rcp_node_list_t*& rcp_node_list()$/;"	f	namespace:__anon41
rcp_node_list_t	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^typedef std::multimap<const void*, RCPNodeInfo> rcp_node_list_t;$/;"	t	namespace:__anon20	file:
rcp_node_list_t	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^typedef std::multimap<const void*, RCPNodeInfo> rcp_node_list_t;$/;"	t	namespace:__anon41	file:
rcp_static_cast	build/cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_static_cast(const RCP<T1>& p1)$/;"	f
rcp_static_cast	cmake/checkcxx11.cpp	/^inline RCP<T2> rcp_static_cast(const RCP<T1>& p1)$/;"	f
rcp_static_cast	symengine/symengine_rcp.h	/^inline RCP<T2> rcp_static_cast(const RCP<T1> &p1)$/;"	f	namespace:SymEngine
rcp_static_cast	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Teuchos::rcp_static_cast(const RCP<T1>& p1)$/;"	f	class:Teuchos
rdiv	symengine/complex.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::Complex
rdiv	symengine/complex_double.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rdiv(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/complex_mpc.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
rdiv	symengine/integer.cpp	/^RCP<const Number> Integer::rdiv(const Number &other) const$/;"	f	class:SymEngine::Integer
rdiv	symengine/number.cpp	/^RCP<const Number> Number::rdiv(const Number &other) const$/;"	f	class:SymEngine::Number
rdiv	symengine/rational.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::Rational
rdiv	symengine/real_double.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::RealDouble
rdiv	symengine/real_mpfr.h	/^    virtual RCP<const Number> rdiv(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
rdivcomp	symengine/complex.h	/^    inline RCP<const Number> rdivcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
rdivcomp	symengine/complex_double.h	/^    RCP<const Number> rdivcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
rdivcomp	symengine/complex_double.h	/^    RCP<const Number> rdivcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
rdivcomp	symengine/complex_double.h	/^    RCP<const Number> rdivcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
rdivcomp	symengine/complex_double.h	/^    RCP<const Number> rdivcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
rdivrat	symengine/rational.h	/^    inline RCP<const Number> rdivrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
rdivreal	symengine/real_double.h	/^    RCP<const Number> rdivreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
rdivreal	symengine/real_double.h	/^    RCP<const Number> rdivreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
rdivreal	symengine/real_double.h	/^    RCP<const Number> rdivreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
rdivreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rdivreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
rdivreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rdivreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
rdivreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rdivreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
rdivreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rdivreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
rdivreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rdivreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
reRead	symengine/parser/scanner.cpp	/^void ScannerBase::Input::reRead(size_t ch)$/;"	f	class:SymEngine::ScannerBase::Input
reRead	symengine/parser/scanner.cpp	/^void ScannerBase::Input::reRead(std::string const &str, size_t fm)$/;"	f	class:SymEngine::ScannerBase::Input
read_line_from_file	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string read_line_from_file(std::string filename, unsigned int line_number)$/;"	f	namespace:__anon22
read_line_from_file	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string read_line_from_file(std::string filename, unsigned int line_number)$/;"	f	namespace:__anon43
real	symengine/cwrapper.h	/^    double real;$/;"	m	struct:dcomplex
real_	symengine/as_real_imag.cpp	/^    Ptr<RCP<const Basic>> real_, imag_;$/;"	m	class:SymEngine::RealImagVisitor	file:
real_	symengine/complex.h	/^    rational_class real_;$/;"	m	class:SymEngine::Complex
real_double	symengine/real_double.cpp	/^RCP<const RealDouble> real_double(double x)$/;"	f	namespace:SymEngine
real_double_get_d	symengine/cwrapper.cpp	/^double real_double_get_d(const basic s)$/;"	f
real_double_set_d	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE real_double_set_d(basic s, double d)$/;"	f
real_mpfr	symengine/real_mpfr.h	/^inline RCP<const RealMPFR> real_mpfr(mpfr_class x)$/;"	f	namespace:SymEngine
real_mpfr_get	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE real_mpfr_get(mpfr_ptr m, const basic s)$/;"	f
real_mpfr_get_d	symengine/cwrapper.cpp	/^double real_mpfr_get_d(const basic s)$/;"	f
real_mpfr_get_prec	symengine/cwrapper.cpp	/^mpfr_prec_t real_mpfr_get_prec(const basic s)$/;"	f
real_mpfr_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE real_mpfr_set(basic s, mpfr_srcptr m)$/;"	f
real_mpfr_set_d	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE real_mpfr_set_d(basic s, double d, int prec)$/;"	f
real_mpfr_set_str	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE real_mpfr_set_str(basic s, const char *c, int prec)$/;"	f
real_part	symengine/complex.cpp	/^RCP<const Number> Complex::real_part() const$/;"	f	class:SymEngine::Complex
real_part	symengine/complex_double.cpp	/^RCP<const Number> ComplexDouble::real_part() const$/;"	f	class:SymEngine::ComplexDouble
real_part	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::real_part() const$/;"	f	class:SymEngine::ComplexMPC
reconcile	symengine/polys/msymenginepoly.cpp	/^unsigned int reconcile(vec_uint &v1, vec_uint &v2, set_basic &s,$/;"	f	namespace:SymEngine
reconstructExpression	symengine/utilities/catch/catch.hpp	/^        std::string const& reconstructExpression() const {$/;"	f	class:Catch::AssertionResultData::std
reconstructedExpression	symengine/utilities/catch/catch.hpp	/^        mutable std::string reconstructedExpression;$/;"	m	struct:Catch::AssertionResultData
redo	symengine/parser/scanner.cpp	/^void ScannerBase::redo(size_t nChars)$/;"	f	class:SymEngine::ScannerBase
reduce__	symengine/parser/parser.cpp	/^inline void ParserBase::reduce__(PI__ const &pi)$/;"	f	class:SymEngine::ParserBase
reduced_row_echelon_form	symengine/dense_matrix.cpp	/^void reduced_row_echelon_form(const DenseMatrix &A, DenseMatrix &b,$/;"	f	namespace:SymEngine
refcount_	symengine/symengine_rcp.h	/^    mutable std::atomic<unsigned int> refcount_; \/\/ reference counter$/;"	m	class:SymEngine::EnableRCPFromThis
refcount_	symengine/symengine_rcp.h	/^    mutable unsigned int refcount_; \/\/ reference counter$/;"	m	class:SymEngine::EnableRCPFromThis
release	doc/conf.py	/^release = '0.1'$/;"	v
release	symengine/utilities/catch/catch.hpp	/^        virtual void release() const {$/;"	f	struct:Catch::SharedImpl
release	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^Ptr<T> RCP<T>::release()$/;"	f	class:Teuchos::RCP
release	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void release()$/;"	f	class:Teuchos::RCPNodeThrowDeleter
removeRCPNode	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::removeRCPNode( RCPNode* rcp_node )$/;"	f	class:Teuchos::RCPNodeTracer
remove_leading_whitespace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string remove_leading_whitespace(const std::string &str)$/;"	f	namespace:__anon22
remove_leading_whitespace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string remove_leading_whitespace(const std::string &str)$/;"	f	namespace:__anon43
remove_reference	symengine/symengine_casts.h	/^struct remove_reference {$/;"	s	namespace:SymEngine
remove_reference	symengine/symengine_casts.h	/^struct remove_reference<T &> {$/;"	s	namespace:SymEngine
repeat	benchmarks/nonius.h++	/^        repeater<typename std::decay<Fun>::type> repeat(Fun&& fun) {$/;"	f	namespace:nonius::detail
repeater	benchmarks/nonius.h++	/^        struct repeater {$/;"	s	namespace:nonius::detail
replacement_symbol_ptrs	symengine/llvm_double.h	/^        replacement_symbol_ptrs;$/;"	m	class:SymEngine::LLVMDoubleVisitor
replacements	symengine/cse.cpp	/^    vec_pair &replacements;$/;"	m	class:SymEngine::RebuildVisitor	file:
report_stream	benchmarks/nonius.h++	/^        std::ostream& report_stream() {$/;"	f	struct:nonius::reporter
reporter	benchmarks/nonius.h++	/^        std::string reporter;$/;"	m	struct:nonius::configuration
reporter	benchmarks/nonius.h++	/^    struct reporter {$/;"	s	namespace:nonius
reporter_registrar	benchmarks/nonius.h++	/^        reporter_registrar(reporter_registry& registry, std::string name, reporter* registrant) {$/;"	f	struct:nonius::reporter_registrar
reporter_registrar	benchmarks/nonius.h++	/^    struct reporter_registrar {$/;"	s	namespace:nonius
res	symengine/parser/parser.h	/^    RCP<const Basic> res;$/;"	m	class:SymEngine::Parser
resample	benchmarks/nonius.h++	/^        sample resample(URng& rng, int resamples, Iterator first, Iterator last, Estimator& estimator) {$/;"	f	namespace:nonius::detail
resamples	benchmarks/nonius.h++	/^        int resamples = 100000;$/;"	m	struct:nonius::configuration
resamples	benchmarks/nonius.h++	/^        int resamples;$/;"	m	struct:nonius::junit_reporter
reset	build/cmake/checkcxx11.cpp	/^    void reset() {$/;"	f	class:RCP
reset	cmake/checkcxx11.cpp	/^    void reset() {$/;"	f	class:RCP
reset	symengine/symengine_rcp.h	/^    void reset()$/;"	f	class:SymEngine::RCP
reset	symengine/utilities/catch/catch.hpp	/^        void reset() {$/;"	f	class:Catch::Ptr
reset	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^void RCP<T>::reset()$/;"	f	class:Teuchos::RCP
reset	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^void RCP<T>::reset(T2* p, bool has_ownership_in)$/;"	f	class:Teuchos::RCP
reset__	symengine/parser/scanner.cpp	/^void ScannerBase::reset__()$/;"	f	class:SymEngine::ScannerBase
resize	symengine/dense_matrix.cpp	/^void DenseMatrix::resize(unsigned row, unsigned col)$/;"	f	class:SymEngine::DenseMatrix
resolution	benchmarks/nonius.h++	/^        std::vector<double> resolution(int k) {$/;"	f	namespace:nonius::detail
result	benchmarks/nonius.h++	/^        Result result;$/;"	m	struct:nonius::timing
result	benchmarks/nonius.h++	/^        struct result {$/;"	s	struct:nonius::junit_reporter
resultDisposition	symengine/utilities/catch/catch.hpp	/^        ResultDisposition::Flags resultDisposition;$/;"	m	struct:Catch::AssertionInfo
resultType	symengine/utilities/catch/catch.hpp	/^        ResultWas::OfType resultType;$/;"	m	struct:Catch::AssertionResultData
result_	symengine/eval_arb.cpp	/^    arb_ptr result_;$/;"	m	class:SymEngine::EvalArbVisitor	file:
result_	symengine/eval_double.cpp	/^    T result_;$/;"	m	class:SymEngine::EvalDoubleVisitor	file:
result_	symengine/eval_mpc.cpp	/^    mpc_ptr result_;$/;"	m	class:SymEngine::EvalMPCVisitor	file:
result_	symengine/eval_mpfr.cpp	/^    mpfr_ptr result_;$/;"	m	class:SymEngine::EvalMPFRVisitor	file:
result_	symengine/lambda_double.h	/^    fn result_;$/;"	m	class:SymEngine::LambdaDoubleVisitor
result_	symengine/llvm_double.h	/^    llvm::Value *result_;$/;"	m	class:SymEngine::LLVMDoubleVisitor
result_	symengine/solve.cpp	/^    RCP<const Set> result_;$/;"	m	class:SymEngine::InvertComplexVisitor	file:
result_	symengine/subs.h	/^    RCP<const Basic> result_;$/;"	m	class:SymEngine::XReplaceVisitor
result_	symengine/visitor.h	/^    RCP<const Basic> result_;$/;"	m	class:SymEngine::TransformVisitor
results	symengine/lambda_double.h	/^    std::vector<fn> results;$/;"	m	class:SymEngine::LambdaDoubleVisitor
retryNumber	bin/appveyor-download.cmd	/^set retryNumber=0$/;"	v
return__	symengine/parser/scannerbase.h	/^inline bool ScannerBase::return__()$/;"	f	class:SymEngine::ScannerBase
reverse_iterator	symengine/fields.h	/^    typedef vec_integer_class::const_reverse_iterator reverse_iterator;$/;"	t	class:SymEngine::GaloisField
revert_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper revert_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
rewrite_as_exp	symengine/rewrite.cpp	/^RCP<const Basic> rewrite_as_exp(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
rewrite_as_gamma	symengine/functions.cpp	/^RCP<const Basic> Beta::rewrite_as_gamma() const$/;"	f	class:SymEngine::Beta
rewrite_as_gamma	symengine/functions.cpp	/^RCP<const Basic> LogGamma::rewrite_as_gamma() const$/;"	f	class:SymEngine::LogGamma
rewrite_as_zeta	symengine/functions.cpp	/^RCP<const Basic> Dirichlet_eta::rewrite_as_zeta() const$/;"	f	class:SymEngine::Dirichlet_eta
rewrite_as_zeta	symengine/functions.cpp	/^RCP<const Basic> PolyGamma::rewrite_as_zeta() const$/;"	f	class:SymEngine::PolyGamma
rhs	symengine/parser/scannerbase.h	/^    ScannerBase &operator=(ScannerBase const &rhs) = delete;$/;"	m	class:SymEngine::ScannerBase
right	benchmarks/symbench.cpp	/^RCP<const Basic> right(const RCP<const Basic> &f, const RCP<const Number> &a,$/;"	f
right	benchmarks/symbench_ginac.cpp	/^ex right(ex f, numeric a, numeric b, ex x, int n)$/;"	f
right_open_	symengine/sets.h	/^    bool left_open_, right_open_;$/;"	m	class:SymEngine::Interval
rnd_	symengine/eval_mpc.cpp	/^    mpfr_rnd_t rnd_;$/;"	m	class:SymEngine::EvalMPCVisitor	file:
rnd_	symengine/eval_mpfr.cpp	/^    mpfr_rnd_t rnd_;$/;"	m	class:SymEngine::EvalMPFRVisitor	file:
root	symengine/flint_wrapper.h	/^    inline fmpz_wrapper root(unsigned int n) const$/;"	f	class:SymEngine::fmpz_wrapper
root	symengine/series_flint.cpp	/^fmpq_wrapper URatPSeriesFlint::root(fmpq_wrapper &c, unsigned n)$/;"	f	class:SymEngine::URatPSeriesFlint
root	symengine/series_generic.cpp	/^Expression UnivariateSeries::root(Expression &c, unsigned n)$/;"	f	class:SymEngine::UnivariateSeries
root	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::root(Expression &c, unsigned n)$/;"	f	class:SymEngine::UPSeriesPiranha
root	symengine/series_piranha.cpp	/^piranha::rational URatPSeriesPiranha::root(piranha::rational &c, unsigned n)$/;"	f	class:SymEngine::URatPSeriesPiranha
row_	symengine/matrix.h	/^    unsigned row_;$/;"	m	class:SymEngine::CSRMatrix
row_	symengine/matrix.h	/^    unsigned row_;$/;"	m	class:SymEngine::DenseMatrix
row_add_row_dense	symengine/dense_matrix.cpp	/^void row_add_row_dense(DenseMatrix &A, unsigned i, unsigned j,$/;"	f	namespace:SymEngine
row_del	symengine/dense_matrix.cpp	/^void DenseMatrix::row_del(unsigned k)$/;"	f	class:SymEngine::DenseMatrix
row_exchange_dense	symengine/dense_matrix.cpp	/^void row_exchange_dense(DenseMatrix &A, unsigned i, unsigned j)$/;"	f	namespace:SymEngine
row_insert	symengine/dense_matrix.cpp	/^void DenseMatrix::row_insert(const DenseMatrix &B, unsigned pos)$/;"	f	class:SymEngine::DenseMatrix
row_join	symengine/dense_matrix.cpp	/^void DenseMatrix::row_join(const DenseMatrix &B)$/;"	f	class:SymEngine::DenseMatrix
row_mul_scalar_dense	symengine/dense_matrix.cpp	/^void row_mul_scalar_dense(DenseMatrix &A, unsigned i, RCP<const Basic> &c)$/;"	f	namespace:SymEngine
rpow	symengine/complex.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::Complex
rpow	symengine/complex_double.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rpow(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/complex_mpc.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
rpow	symengine/infinity.cpp	/^RCP<const Number> Infty::rpow(const Number &other) const$/;"	f	class:SymEngine::Infty
rpow	symengine/integer.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::Integer
rpow	symengine/nan.cpp	/^RCP<const Number> NaN::rpow(const Number &other) const$/;"	f	class:SymEngine::NaN
rpow	symengine/rational.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::Rational
rpow	symengine/real_double.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::RealDouble
rpow	symengine/real_mpfr.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
rpow	symengine/series.h	/^    virtual RCP<const Number> rpow(const Number &other) const$/;"	f	class:SymEngine::SeriesBase
rpowcomp	symengine/complex_double.h	/^    RCP<const Number> rpowcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
rpowcomp	symengine/complex_double.h	/^    RCP<const Number> rpowcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
rpowcomp	symengine/complex_double.h	/^    RCP<const Number> rpowcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
rpowcomp	symengine/complex_double.h	/^    RCP<const Number> rpowcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
rpowrat	symengine/rational.cpp	/^RCP<const Basic> Rational::rpowrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
rpowreal	symengine/real_double.h	/^    RCP<const Number> rpowreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
rpowreal	symengine/real_double.h	/^    RCP<const Number> rpowreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
rpowreal	symengine/real_double.h	/^    RCP<const Number> rpowreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
rpowreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rpowreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
rpowreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rpowreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
rpowreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rpowreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
rpowreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rpowreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
rpowreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rpowreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
rsub	symengine/complex.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::Complex
rsub	symengine/complex_double.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::rsub(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/complex_mpc.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
rsub	symengine/integer.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::Integer
rsub	symengine/number.cpp	/^RCP<const Number> Number::rsub(const Number &other) const$/;"	f	class:SymEngine::Number
rsub	symengine/rational.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::Rational
rsub	symengine/real_double.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::RealDouble
rsub	symengine/real_mpfr.h	/^    virtual RCP<const Number> rsub(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
rsubcomp	symengine/complex.h	/^    inline RCP<const Number> rsubcomp(const Complex &other) const$/;"	f	class:SymEngine::Complex
rsubcomp	symengine/complex.h	/^    inline RCP<const Number> rsubcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
rsubcomp	symengine/complex.h	/^    inline RCP<const Number> rsubcomp(const Rational &other) const$/;"	f	class:SymEngine::Complex
rsubcomp	symengine/complex_double.h	/^    RCP<const Number> rsubcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
rsubcomp	symengine/complex_double.h	/^    RCP<const Number> rsubcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
rsubcomp	symengine/complex_double.h	/^    RCP<const Number> rsubcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
rsubcomp	symengine/complex_double.h	/^    RCP<const Number> rsubcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
rsubrat	symengine/rational.h	/^    inline RCP<const Number> rsubrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
rsubreal	symengine/real_double.h	/^    RCP<const Number> rsubreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
rsubreal	symengine/real_double.h	/^    RCP<const Number> rsubreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
rsubreal	symengine/real_double.h	/^    RCP<const Number> rsubreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
rsubreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rsubreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
rsubreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rsubreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
rsubreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rsubreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
rsubreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rsubreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
rsubreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::rsubreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
rule	symengine/parser/scannerbase.h	/^        size_t rule;$/;"	m	struct:SymEngine::ScannerBase::FinalData
run	benchmarks/nonius.h++	/^        std::vector<FloatDuration<Clock>> run(configuration cfg, environment<FloatDuration<Clock>> env, execution_plan<FloatDuration<Clock>> plan) const {$/;"	f	struct:nonius::benchmark
run_for_at_least	benchmarks/nonius.h++	/^        TimingOf<Clock, Fun(int)> run_for_at_least(Duration<Clock> how_long, int seed, Fun&& fun) {$/;"	f	namespace:nonius::detail
run_it	benchmarks/nonius.h++	/^    inline int run_it(configuration cfg) {$/;"	f	namespace:nonius
runs	benchmarks/nonius.h++	/^        int runs() const { return k; }$/;"	f	struct:nonius::chronometer
s	symengine/parser/parser_old.cpp	/^    std::string s;$/;"	m	class:SymEngine::ExpressionParser	file:
s	symengine/printers/mathml.h	/^    std::ostringstream s;$/;"	m	class:SymEngine::MathMLPrinter
s	symengine/utilities/catch/catch.hpp	/^        static std::ostream &s;$/;"	m	struct:Catch::Detail::IsStreamInsertable
s	symengine/visitor.cpp	/^    set_basic s;$/;"	m	class:SymEngine::FreeSymbolsVisitor	file:
s	symengine/visitor.h	/^    set_basic s;$/;"	m	class:SymEngine::AtomsVisitor
s_0	symengine/parser/parser.cpp	/^SR__ s_0[] = {$/;"	m	namespace:__anon29	file:
s_0	symengine/parser/parser.cpp	/^SR__ s_0[] = {$/;"	m	namespace:__anon8	file:
s_1	symengine/parser/parser.cpp	/^SR__ s_1[] = {$/;"	m	namespace:__anon29	file:
s_1	symengine/parser/parser.cpp	/^SR__ s_1[] = {$/;"	m	namespace:__anon8	file:
s_10	symengine/parser/parser.cpp	/^SR__ s_10[] = {$/;"	m	namespace:__anon29	file:
s_10	symengine/parser/parser.cpp	/^SR__ s_10[] = {$/;"	m	namespace:__anon8	file:
s_11	symengine/parser/parser.cpp	/^SR__ s_11[] = {$/;"	m	namespace:__anon29	file:
s_11	symengine/parser/parser.cpp	/^SR__ s_11[] = {$/;"	m	namespace:__anon8	file:
s_12	symengine/parser/parser.cpp	/^SR__ s_12[] = {$/;"	m	namespace:__anon29	file:
s_12	symengine/parser/parser.cpp	/^SR__ s_12[] = {$/;"	m	namespace:__anon8	file:
s_13	symengine/parser/parser.cpp	/^SR__ s_13[] = {$/;"	m	namespace:__anon29	file:
s_13	symengine/parser/parser.cpp	/^SR__ s_13[] = {$/;"	m	namespace:__anon8	file:
s_14	symengine/parser/parser.cpp	/^SR__ s_14[] = {$/;"	m	namespace:__anon29	file:
s_14	symengine/parser/parser.cpp	/^SR__ s_14[] = {$/;"	m	namespace:__anon8	file:
s_15	symengine/parser/parser.cpp	/^SR__ s_15[] = {$/;"	m	namespace:__anon29	file:
s_15	symengine/parser/parser.cpp	/^SR__ s_15[] = {$/;"	m	namespace:__anon8	file:
s_16	symengine/parser/parser.cpp	/^SR__ s_16[] = {$/;"	m	namespace:__anon29	file:
s_16	symengine/parser/parser.cpp	/^SR__ s_16[] = {$/;"	m	namespace:__anon8	file:
s_17	symengine/parser/parser.cpp	/^SR__ s_17[] = {$/;"	m	namespace:__anon29	file:
s_17	symengine/parser/parser.cpp	/^SR__ s_17[] = {$/;"	m	namespace:__anon8	file:
s_18	symengine/parser/parser.cpp	/^SR__ s_18[] = {$/;"	m	namespace:__anon29	file:
s_18	symengine/parser/parser.cpp	/^SR__ s_18[] = {$/;"	m	namespace:__anon8	file:
s_19	symengine/parser/parser.cpp	/^SR__ s_19[] = {$/;"	m	namespace:__anon29	file:
s_19	symengine/parser/parser.cpp	/^SR__ s_19[] = {$/;"	m	namespace:__anon8	file:
s_2	symengine/parser/parser.cpp	/^SR__ s_2[] = {$/;"	m	namespace:__anon29	file:
s_2	symengine/parser/parser.cpp	/^SR__ s_2[] = {$/;"	m	namespace:__anon8	file:
s_20	symengine/parser/parser.cpp	/^SR__ s_20[] = {$/;"	m	namespace:__anon29	file:
s_20	symengine/parser/parser.cpp	/^SR__ s_20[] = {$/;"	m	namespace:__anon8	file:
s_21	symengine/parser/parser.cpp	/^SR__ s_21[] = {$/;"	m	namespace:__anon29	file:
s_21	symengine/parser/parser.cpp	/^SR__ s_21[] = {$/;"	m	namespace:__anon8	file:
s_22	symengine/parser/parser.cpp	/^SR__ s_22[] = {$/;"	m	namespace:__anon29	file:
s_22	symengine/parser/parser.cpp	/^SR__ s_22[] = {$/;"	m	namespace:__anon8	file:
s_23	symengine/parser/parser.cpp	/^SR__ s_23[] = {$/;"	m	namespace:__anon29	file:
s_23	symengine/parser/parser.cpp	/^SR__ s_23[] = {$/;"	m	namespace:__anon8	file:
s_24	symengine/parser/parser.cpp	/^SR__ s_24[] = {$/;"	m	namespace:__anon29	file:
s_24	symengine/parser/parser.cpp	/^SR__ s_24[] = {$/;"	m	namespace:__anon8	file:
s_25	symengine/parser/parser.cpp	/^SR__ s_25[] = {$/;"	m	namespace:__anon29	file:
s_25	symengine/parser/parser.cpp	/^SR__ s_25[] = {$/;"	m	namespace:__anon8	file:
s_26	symengine/parser/parser.cpp	/^SR__ s_26[] = {$/;"	m	namespace:__anon29	file:
s_26	symengine/parser/parser.cpp	/^SR__ s_26[] = {$/;"	m	namespace:__anon8	file:
s_27	symengine/parser/parser.cpp	/^SR__ s_27[] = {$/;"	m	namespace:__anon29	file:
s_27	symengine/parser/parser.cpp	/^SR__ s_27[] = {$/;"	m	namespace:__anon8	file:
s_28	symengine/parser/parser.cpp	/^SR__ s_28[] = {$/;"	m	namespace:__anon29	file:
s_28	symengine/parser/parser.cpp	/^SR__ s_28[] = {$/;"	m	namespace:__anon8	file:
s_29	symengine/parser/parser.cpp	/^SR__ s_29[] = {$/;"	m	namespace:__anon29	file:
s_29	symengine/parser/parser.cpp	/^SR__ s_29[] = {$/;"	m	namespace:__anon8	file:
s_3	symengine/parser/parser.cpp	/^SR__ s_3[] = {$/;"	m	namespace:__anon29	file:
s_3	symengine/parser/parser.cpp	/^SR__ s_3[] = {$/;"	m	namespace:__anon8	file:
s_30	symengine/parser/parser.cpp	/^SR__ s_30[] = {$/;"	m	namespace:__anon29	file:
s_30	symengine/parser/parser.cpp	/^SR__ s_30[] = {$/;"	m	namespace:__anon8	file:
s_31	symengine/parser/parser.cpp	/^SR__ s_31[] = {$/;"	m	namespace:__anon29	file:
s_31	symengine/parser/parser.cpp	/^SR__ s_31[] = {$/;"	m	namespace:__anon8	file:
s_32	symengine/parser/parser.cpp	/^SR__ s_32[] = {$/;"	m	namespace:__anon29	file:
s_32	symengine/parser/parser.cpp	/^SR__ s_32[] = {$/;"	m	namespace:__anon8	file:
s_33	symengine/parser/parser.cpp	/^SR__ s_33[] = {$/;"	m	namespace:__anon29	file:
s_33	symengine/parser/parser.cpp	/^SR__ s_33[] = {$/;"	m	namespace:__anon8	file:
s_34	symengine/parser/parser.cpp	/^SR__ s_34[] = {$/;"	m	namespace:__anon29	file:
s_34	symengine/parser/parser.cpp	/^SR__ s_34[] = {$/;"	m	namespace:__anon8	file:
s_35	symengine/parser/parser.cpp	/^SR__ s_35[] = {$/;"	m	namespace:__anon29	file:
s_35	symengine/parser/parser.cpp	/^SR__ s_35[] = {$/;"	m	namespace:__anon8	file:
s_36	symengine/parser/parser.cpp	/^SR__ s_36[] = {$/;"	m	namespace:__anon29	file:
s_36	symengine/parser/parser.cpp	/^SR__ s_36[] = {$/;"	m	namespace:__anon8	file:
s_37	symengine/parser/parser.cpp	/^SR__ s_37[] = {$/;"	m	namespace:__anon29	file:
s_37	symengine/parser/parser.cpp	/^SR__ s_37[] = {$/;"	m	namespace:__anon8	file:
s_38	symengine/parser/parser.cpp	/^SR__ s_38[] = {$/;"	m	namespace:__anon29	file:
s_38	symengine/parser/parser.cpp	/^SR__ s_38[] = {$/;"	m	namespace:__anon8	file:
s_39	symengine/parser/parser.cpp	/^SR__ s_39[] = {$/;"	m	namespace:__anon29	file:
s_39	symengine/parser/parser.cpp	/^SR__ s_39[] = {$/;"	m	namespace:__anon8	file:
s_4	symengine/parser/parser.cpp	/^SR__ s_4[] = {$/;"	m	namespace:__anon29	file:
s_4	symengine/parser/parser.cpp	/^SR__ s_4[] = {$/;"	m	namespace:__anon8	file:
s_40	symengine/parser/parser.cpp	/^SR__ s_40[] = {$/;"	m	namespace:__anon29	file:
s_40	symengine/parser/parser.cpp	/^SR__ s_40[] = {$/;"	m	namespace:__anon8	file:
s_41	symengine/parser/parser.cpp	/^SR__ s_41[] = {$/;"	m	namespace:__anon29	file:
s_41	symengine/parser/parser.cpp	/^SR__ s_41[] = {$/;"	m	namespace:__anon8	file:
s_42	symengine/parser/parser.cpp	/^SR__ s_42[] = {$/;"	m	namespace:__anon29	file:
s_42	symengine/parser/parser.cpp	/^SR__ s_42[] = {$/;"	m	namespace:__anon8	file:
s_43	symengine/parser/parser.cpp	/^SR__ s_43[] = {$/;"	m	namespace:__anon29	file:
s_43	symengine/parser/parser.cpp	/^SR__ s_43[] = {$/;"	m	namespace:__anon8	file:
s_44	symengine/parser/parser.cpp	/^SR__ s_44[] = {$/;"	m	namespace:__anon29	file:
s_44	symengine/parser/parser.cpp	/^SR__ s_44[] = {$/;"	m	namespace:__anon8	file:
s_45	symengine/parser/parser.cpp	/^SR__ s_45[] = {$/;"	m	namespace:__anon29	file:
s_45	symengine/parser/parser.cpp	/^SR__ s_45[] = {$/;"	m	namespace:__anon8	file:
s_46	symengine/parser/parser.cpp	/^SR__ s_46[] = {$/;"	m	namespace:__anon29	file:
s_46	symengine/parser/parser.cpp	/^SR__ s_46[] = {$/;"	m	namespace:__anon8	file:
s_5	symengine/parser/parser.cpp	/^SR__ s_5[] = {$/;"	m	namespace:__anon29	file:
s_5	symengine/parser/parser.cpp	/^SR__ s_5[] = {$/;"	m	namespace:__anon8	file:
s_6	symengine/parser/parser.cpp	/^SR__ s_6[] = {$/;"	m	namespace:__anon29	file:
s_6	symengine/parser/parser.cpp	/^SR__ s_6[] = {$/;"	m	namespace:__anon8	file:
s_7	symengine/parser/parser.cpp	/^SR__ s_7[] = {$/;"	m	namespace:__anon29	file:
s_7	symengine/parser/parser.cpp	/^SR__ s_7[] = {$/;"	m	namespace:__anon8	file:
s_8	symengine/parser/parser.cpp	/^SR__ s_8[] = {$/;"	m	namespace:__anon29	file:
s_8	symengine/parser/parser.cpp	/^SR__ s_8[] = {$/;"	m	namespace:__anon8	file:
s_9	symengine/parser/parser.cpp	/^SR__ s_9[] = {$/;"	m	namespace:__anon29	file:
s_9	symengine/parser/parser.cpp	/^SR__ s_9[] = {$/;"	m	namespace:__anon8	file:
s_dfaBase__	symengine/parser/scanner.cpp	/^int const (*ScannerBase::s_dfaBase__[])[42] = {$/;"	m	namespace:SymEngine	file:
s_dfaBase__	symengine/parser/scannerbase.h	/^    static int const (*s_dfaBase__[])[42];$/;"	m	class:SymEngine::ScannerBase
s_dfa__	symengine/parser/scanner.cpp	/^int const ScannerBase::s_dfa__[][42] = {$/;"	m	class:SymEngine::ScannerBase	file:
s_dfa__	symengine/parser/scannerbase.h	/^    static int const s_dfa__[][42];$/;"	m	class:SymEngine::ScannerBase
s_istreamNr	symengine/parser/scanner.cpp	/^size_t ScannerBase::s_istreamNr = 0;$/;"	m	class:SymEngine::ScannerBase	file:
s_istreamNr	symengine/parser/scannerbase.h	/^    static size_t s_istreamNr; \/\/ file. With istreams it receives$/;"	m	class:SymEngine::ScannerBase
s_len	symengine/parser/parser_old.cpp	/^    unsigned int s_len;$/;"	m	class:SymEngine::ExpressionParser	file:
s_productionInfo	symengine/parser/parser.cpp	/^PI__ const s_productionInfo[] = {$/;"	m	namespace:__anon29	file:
s_productionInfo	symengine/parser/parser.cpp	/^PI__ const s_productionInfo[] = {$/;"	m	namespace:__anon8	file:
s_ranges__	symengine/parser/scanner.cpp	/^size_t const ScannerBase::s_ranges__[] = {$/;"	m	class:SymEngine::ScannerBase	file:
s_ranges__	symengine/parser/scannerbase.h	/^    static size_t const s_ranges__[];$/;"	m	class:SymEngine::ScannerBase
s_rf__	symengine/parser/scannerbase.h	/^    static size_t const s_rf__[][2];$/;"	m	class:SymEngine::ScannerBase
s_state	symengine/parser/parser.cpp	/^SR__ *s_state[] = {$/;"	m	namespace:__anon29	file:
s_state	symengine/parser/parser.cpp	/^SR__ *s_state[] = {$/;"	m	namespace:__anon8	file:
s_unavailable	symengine/parser/scannerbase.h	/^    static size_t const s_unavailable = std::numeric_limits<size_t>::max();$/;"	m	class:SymEngine::ScannerBase
same	symengine/utilities/teuchos/Teuchos_any.hpp	/^    bool same( const placeholder &other ) const$/;"	f	class:Teuchos::any::holder
same	symengine/utilities/teuchos/Teuchos_any.hpp	/^  bool same( const any &other ) const$/;"	f	class:Teuchos::any
same_node	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  bool same_node(const RCPNodeHandle &node2) const$/;"	f	class:Teuchos::RCPNodeHandle
sample_analysis	benchmarks/nonius.h++	/^    struct sample_analysis {$/;"	s	namespace:nonius
samples	benchmarks/nonius.h++	/^        int samples = 100;$/;"	m	struct:nonius::configuration
samples	benchmarks/nonius.h++	/^        std::vector<Duration> samples;$/;"	m	struct:nonius::sample_analysis
samples_seen	benchmarks/nonius.h++	/^        int samples_seen = 0;$/;"	m	struct:nonius::outlier_classification
sdiff	symengine/dense_matrix.cpp	/^void sdiff(const DenseMatrix &A, const RCP<const Basic> &x, DenseMatrix &result)$/;"	f	namespace:SymEngine
sdiff	symengine/derivative.cpp	/^RCP<const Basic> sdiff(const RCP<const Basic> &arg, const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
sec	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> sec(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
sec	symengine/functions.cpp	/^RCP<const Basic> sec(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
sech	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> sech(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
sech	symengine/functions.cpp	/^RCP<const Basic> sech(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
secondArg	symengine/utilities/catch/catch.hpp	/^        char const * secondArg;$/;"	m	struct:Catch::AssertionInfo
seed	symengine/mp_class.h	/^    void seed(const integer_class &i)$/;"	f	class:SymEngine::mp_randstate
seen_subexp	symengine/cse.cpp	/^    set_basic seen_subexp;$/;"	m	class:SymEngine::OptsCSEVisitor	file:
series	symengine/series.cpp	/^RCP<const SeriesCoeffInterface> series(const RCP<const Basic> &ex,$/;"	f	namespace:SymEngine
series	symengine/series_flint.cpp	/^RCP<const URatPSeriesFlint> URatPSeriesFlint::series(const RCP<const Basic> &t,$/;"	f	class:SymEngine::URatPSeriesFlint
series	symengine/series_generic.cpp	/^RCP<const UnivariateSeries> UnivariateSeries::series(const RCP<const Basic> &t,$/;"	f	class:SymEngine::UnivariateSeries
series	symengine/series_piranha.cpp	/^RCP<const UPSeriesPiranha> UPSeriesPiranha::series(const RCP<const Basic> &t,$/;"	f	class:SymEngine::UPSeriesPiranha
series	symengine/series_piranha.cpp	/^URatPSeriesPiranha::series(const RCP<const Basic> &t, const std::string &x,$/;"	f	class:SymEngine::URatPSeriesPiranha
series	symengine/series_visitor.h	/^    RCP<const Series> series(const RCP<const Basic> &x)$/;"	f	class:SymEngine::SeriesVisitor
series_acos	symengine/series.h	/^    static inline Poly series_acos(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_acos	symengine/series_flint.h	/^    static inline fqp_t series_acos(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_asin	symengine/series.h	/^    static inline Poly series_asin(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_asin	symengine/series_flint.h	/^    static inline fqp_t series_asin(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_asinh	symengine/series.h	/^    static inline Poly series_asinh(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_asinh	symengine/series_flint.h	/^    static inline fqp_t series_asinh(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_atan	symengine/series.h	/^    static inline Poly series_atan(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_atan	symengine/series_flint.h	/^    static inline fqp_t series_atan(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_atanh	symengine/series.h	/^    static inline Poly series_atanh(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_atanh	symengine/series_flint.h	/^    static inline fqp_t series_atanh(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_coeff	symengine/tests/basic/test_series_expansion_UP.cpp	/^#define series_coeff(/;"	d	file:
series_coeff	symengine/tests/basic/test_series_expansion_URatF.cpp	/^#define series_coeff(/;"	d	file:
series_coeff	symengine/tests/basic/test_series_expansion_URatP.cpp	/^#define series_coeff(/;"	d	file:
series_coeff	symengine/tests/basic/test_series_generic.cpp	/^#define series_coeff(/;"	d	file:
series_cos	symengine/series.h	/^    static inline Poly series_cos(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_cos	symengine/series_flint.h	/^    static inline fqp_t series_cos(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_cosh	symengine/series.h	/^    static inline Poly series_cosh(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_cosh	symengine/series_flint.h	/^    static inline fqp_t series_cosh(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_cot	symengine/series.h	/^    static inline Poly series_cot(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_csc	symengine/series.h	/^    static inline Poly series_csc(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_exp	symengine/series.h	/^    static inline Poly series_exp(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_exp	symengine/series_flint.h	/^    static inline fqp_t series_exp(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_invert	symengine/series.h	/^    static inline Poly series_invert(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_invert	symengine/series_flint.h	/^    static inline fqp_t series_invert(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_invfunc	symengine/series.cpp	/^RCP<const SeriesCoeffInterface> series_invfunc(const RCP<const Basic> &ex,$/;"	f	namespace:SymEngine
series_lambertw	symengine/series.h	/^    static inline Poly series_lambertw(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_lambertw	symengine/series_flint.h	/^    static inline fqp_t series_lambertw(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_log	symengine/series.h	/^    static inline Poly series_log(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_log	symengine/series_flint.h	/^    static inline fqp_t series_log(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_nthroot	symengine/series.h	/^    static inline Poly series_nthroot(const Poly &s, int n, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_nthroot	symengine/series_flint.h	/^    static inline fqp_t series_nthroot(const fqp_t &s, int n, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_reverse	symengine/series.h	/^    static inline Poly series_reverse(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_reverse	symengine/series_flint.h	/^    static inline fqp_t series_reverse(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_sec	symengine/series.h	/^    static inline Poly series_sec(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_sin	symengine/series.h	/^    static inline Poly series_sin(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_sin	symengine/series_flint.h	/^    static inline fqp_t series_sin(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_sinh	symengine/series.h	/^    static inline Poly series_sinh(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_sinh	symengine/series_flint.h	/^    static inline fqp_t series_sinh(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_tan	symengine/series.h	/^    static inline Poly series_tan(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_tan	symengine/series_flint.h	/^    static inline fqp_t series_tan(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
series_tanh	symengine/series.h	/^    static inline Poly series_tanh(const Poly &s, const Poly &var,$/;"	f	class:SymEngine::SeriesBase
series_tanh	symengine/series_flint.h	/^    static inline fqp_t series_tanh(const fqp_t &s, const fqp_t &var,$/;"	f	class:SymEngine::URatPSeriesFlint
set	symengine/dense_matrix.cpp	/^void DenseMatrix::set(unsigned i, unsigned j, const RCP<const Basic> &e)$/;"	f	class:SymEngine::DenseMatrix
set	symengine/sparse_matrix.cpp	/^void CSRMatrix::set(unsigned i, unsigned j, const RCP<const Basic> &e)$/;"	f	class:SymEngine::CSRMatrix
setDebug	symengine/parser/parserbase.h	/^inline void ParserBase::setDebug(bool mode)$/;"	f	class:SymEngine::ParserBase
setDebug	symengine/parser/scanner.cpp	/^void ScannerBase::setDebug(bool onOff)$/;"	f	class:SymEngine::ScannerBase
setFilename	symengine/parser/scannerbase.h	/^inline void ScannerBase::setFilename(std::string const &name)$/;"	f	class:SymEngine::ScannerBase
setMatched	symengine/parser/scannerbase.h	/^inline void ScannerBase::setMatched(std::string const &text)$/;"	f	class:SymEngine::ScannerBase
setMatchedSize	symengine/parser/scanner.cpp	/^void ScannerBase::setMatchedSize(size_t length)$/;"	f	class:SymEngine::ScannerBase
setObj	symengine/utilities/teuchos/Teuchos_RCPDecl.hpp	/^  void setObj( const Embedded &embedded ) { embedded_ = embedded; }$/;"	f	class:Teuchos::EmbeddedObjDealloc
setPending	symengine/parser/scannerbase.h	/^        void setPending(size_t size)$/;"	f	class:SymEngine::ScannerBase::Input
setPrintRCPNodeStatisticsOnExit	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::setPrintRCPNodeStatisticsOnExit($/;"	f	class:Teuchos::RCPNodeTracer
setTracingActiveRCPNodes	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeTracer::setTracingActiveRCPNodes(bool tracingActiveNodes)$/;"	f	class:Teuchos::RCPNodeTracer
set_	symengine/logic.h	/^    RCP<const Set> set_;$/;"	m	class:SymEngine::Contains
set_as_vec	symengine/cse.cpp	/^vec_basic set_as_vec(const set_basic &s)$/;"	f	namespace:SymEngine
set_basic	symengine/dict.h	/^typedef std::set<RCP<const Basic>, RCPBasicKeyLess> set_basic;$/;"	t	namespace:SymEngine
set_boolean	symengine/logic.h	/^typedef std::set<RCP<const Boolean>, RCPBasicKeyLess> set_boolean;$/;"	t	namespace:SymEngine
set_children	benchmarks/nonius.h++	/^    inline void Token::set_children( token_vector & )$/;"	f	class:cpptempl::Token
set_children	benchmarks/nonius.h++	/^    inline void TokenFor::set_children( token_vector &children )$/;"	f	class:cpptempl::TokenFor
set_children	benchmarks/nonius.h++	/^    inline void TokenIf::set_children( token_vector &children )$/;"	f	class:cpptempl::TokenIf
set_clear	symengine/ntheory.cpp	/^void Sieve::set_clear(bool clear)$/;"	f	class:SymEngine::Sieve
set_coeff	symengine/flint_wrapper.h	/^    void set_coeff(unsigned int n, const fmpq_wrapper &z)$/;"	f	class:SymEngine::fmpq_poly_wrapper
set_coeff	symengine/flint_wrapper.h	/^    void set_coeff(unsigned int n, const fmpz_wrapper &z)$/;"	f	class:SymEngine::fmpz_poly_wrapper
set_complement	symengine/sets.cpp	/^RCP<const Set> Complement::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Complement
set_complement	symengine/sets.cpp	/^RCP<const Set> ConditionSet::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ConditionSet
set_complement	symengine/sets.cpp	/^RCP<const Set> EmptySet::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::EmptySet
set_complement	symengine/sets.cpp	/^RCP<const Set> FiniteSet::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::FiniteSet
set_complement	symengine/sets.cpp	/^RCP<const Set> ImageSet::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ImageSet
set_complement	symengine/sets.cpp	/^RCP<const Set> Interval::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Interval
set_complement	symengine/sets.cpp	/^RCP<const Set> Union::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Union
set_complement	symengine/sets.cpp	/^RCP<const Set> UniversalSet::set_complement(const RCP<const Set> &o) const$/;"	f	class:SymEngine::UniversalSet
set_complement	symengine/sets.cpp	/^RCP<const Set> set_complement(const RCP<const Set> &universe,$/;"	f	namespace:SymEngine
set_complement_helper	symengine/sets.cpp	/^RCP<const Set> set_complement_helper(const RCP<const Set> &container,$/;"	f	namespace:SymEngine
set_diff	symengine/cse.cpp	/^std::vector<unsigned> set_diff(const std::set<unsigned> &a,$/;"	f	namespace:SymEngine
set_double	symengine/llvm_double.cpp	/^void LLVMDoubleVisitor::set_double(double d)$/;"	f	class:SymEngine::LLVMDoubleVisitor
set_extra_data	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^void Teuchos::set_extra_data( const T1 &extra_data, const std::string& name,$/;"	f	class:Teuchos
set_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNode::set_extra_data($/;"	f	class:Teuchos::RCPNode
set_extra_data	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void set_extra_data($/;"	f	class:Teuchos::RCPNodeHandle
set_has_ownership	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^void RCP<T>::set_has_ownership()$/;"	f	class:Teuchos::RCP
set_insertion_number	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void set_insertion_number(int insertion_number_in)$/;"	f	class:Teuchos::RCPNode
set_intersection	symengine/sets.cpp	/^RCP<const Set> Complement::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Complement
set_intersection	symengine/sets.cpp	/^RCP<const Set> ConditionSet::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ConditionSet
set_intersection	symengine/sets.cpp	/^RCP<const Set> EmptySet::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::EmptySet
set_intersection	symengine/sets.cpp	/^RCP<const Set> FiniteSet::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::FiniteSet
set_intersection	symengine/sets.cpp	/^RCP<const Set> ImageSet::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ImageSet
set_intersection	symengine/sets.cpp	/^RCP<const Set> Interval::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Interval
set_intersection	symengine/sets.cpp	/^RCP<const Set> Union::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Union
set_intersection	symengine/sets.cpp	/^RCP<const Set> UniversalSet::set_intersection(const RCP<const Set> &o) const$/;"	f	class:SymEngine::UniversalSet
set_intersection	symengine/sets.cpp	/^RCP<const Set> set_intersection(const set_set &in)$/;"	f	namespace:SymEngine
set_one	symengine/flint_wrapper.h	/^    void set_one()$/;"	f	class:SymEngine::fmpq_poly_wrapper
set_result	symengine/parser/parser_old.cpp	/^    RCP<const Basic> set_result(const std::string &expr)$/;"	f	class:SymEngine::ExpressionParser	file:
set_set	symengine/sets.h	/^typedef std::set<RCP<const Set>, RCPBasicKeyLess> set_set;$/;"	t	namespace:SymEngine
set_sieve_size	symengine/ntheory.cpp	/^void Sieve::set_sieve_size(unsigned size)$/;"	f	class:SymEngine::Sieve
set_union	symengine/sets.cpp	/^RCP<const Set> Complement::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Complement
set_union	symengine/sets.cpp	/^RCP<const Set> ConditionSet::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ConditionSet
set_union	symengine/sets.cpp	/^RCP<const Set> EmptySet::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::EmptySet
set_union	symengine/sets.cpp	/^RCP<const Set> FiniteSet::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::FiniteSet
set_union	symengine/sets.cpp	/^RCP<const Set> ImageSet::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::ImageSet
set_union	symengine/sets.cpp	/^RCP<const Set> Interval::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Interval
set_union	symengine/sets.cpp	/^RCP<const Set> Union::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::Union
set_union	symengine/sets.cpp	/^RCP<const Set> UniversalSet::set_union(const RCP<const Set> &o) const$/;"	f	class:SymEngine::UniversalSet
set_union	symengine/sets.cpp	/^RCP<const Set> set_union(const set_set &in)$/;"	f	namespace:SymEngine
set_weak_self_ptr	symengine/symengine_rcp.h	/^    void set_weak_self_ptr(const RCP<T> &w)$/;"	f	class:SymEngine::EnableRCPFromThis
set_weak_self_ptr	symengine/symengine_rcp.h	/^    void set_weak_self_ptr(const RCP<const T> &w) const$/;"	f	class:SymEngine::EnableRCPFromThis
set_zero	symengine/flint_wrapper.h	/^    void set_zero()$/;"	f	class:SymEngine::fmpq_poly_wrapper
setbasic_erase	symengine/cwrapper.cpp	/^int setbasic_erase(CSetBasic *self, const basic value)$/;"	f
setbasic_find	symengine/cwrapper.cpp	/^int setbasic_find(CSetBasic *self, basic value)$/;"	f
setbasic_free	symengine/cwrapper.cpp	/^void setbasic_free(CSetBasic *self)$/;"	f
setbasic_get	symengine/cwrapper.cpp	/^void setbasic_get(CSetBasic *self, int n, basic result)$/;"	f
setbasic_insert	symengine/cwrapper.cpp	/^int setbasic_insert(CSetBasic *self, const basic value)$/;"	f
setbasic_new	symengine/cwrapper.cpp	/^CSetBasic *setbasic_new()$/;"	f
setbasic_size	symengine/cwrapper.cpp	/^size_t setbasic_size(CSetBasic *self)$/;"	f
shared_lib_callback	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^int shared_lib_callback(struct dl_phdr_info *info,$/;"	f	namespace:__anon22
shared_lib_callback	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^int shared_lib_callback(struct dl_phdr_info *info,$/;"	f	namespace:__anon43
shares_resource	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^bool RCP<T>::shares_resource(const RCP<T2>& r_ptr) const$/;"	f	class:Teuchos::RCP
short_form	benchmarks/nonius.h++	/^            std::string short_form;$/;"	m	struct:nonius::detail::option
shouldContinueOnFailure	symengine/utilities/catch/catch.hpp	/^    inline bool shouldContinueOnFailure( int flags )    { return ( flags & ResultDisposition::ContinueOnFailure ) != 0; }$/;"	f	namespace:Catch
shouldSuppressFailure	symengine/utilities/catch/catch.hpp	/^    inline bool shouldSuppressFailure( int flags )      { return ( flags & ResultDisposition::SuppressFail ) != 0; }$/;"	f	namespace:Catch
show_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void Teuchos::show_stacktrace()$/;"	f	class:Teuchos
sign	symengine/functions.cpp	/^RCP<const Basic> sign(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
sin	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> sin(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
sin	symengine/functions.cpp	/^RCP<const Basic> sin(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
sin	symengine/series.h	/^    static inline Coeff sin(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
sin	symengine/series_generic.cpp	/^Expression UnivariateSeries::sin(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
sin	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::sin(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
sin_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper sin_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
sin_table	symengine/constants.cpp	/^RCP<const Basic> sin_table[]$/;"	m	namespace:SymEngine	file:
single_arg_boolean_boolean_functions	symengine/parser/parser.h	/^        single_arg_boolean_boolean_functions = {$/;"	m	class:SymEngine::Parser
single_arg_boolean_boolean_functions	symengine/parser/parser_old.cpp	/^        single_arg_boolean_boolean_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
single_arg_boolean_func	symengine/parser/parser.h	/^    typedef RCP<const Boolean> (*single_arg_boolean_func)($/;"	t	class:SymEngine::Parser
single_arg_boolean_func	symengine/parser/parser_old.cpp	/^    typedef RCP<const Boolean> (*single_arg_boolean_func)($/;"	t	class:SymEngine::ExpressionParser	file:
single_arg_boolean_functions	symengine/parser/parser.h	/^        single_arg_boolean_functions = {$/;"	m	class:SymEngine::Parser
single_arg_boolean_functions	symengine/parser/parser_old.cpp	/^        single_arg_boolean_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
single_arg_func	symengine/parser/parser.h	/^    typedef RCP<const Basic> (*single_arg_func)(const RCP<const Basic> &);$/;"	t	class:SymEngine::Parser
single_arg_func	symengine/parser/parser_old.cpp	/^    typedef RCP<const Basic> (*single_arg_func)(const RCP<const Basic> &);$/;"	t	class:SymEngine::ExpressionParser	file:
single_arg_functions	symengine/parser/parser.h	/^        single_arg_functions = {$/;"	m	class:SymEngine::Parser
single_arg_functions	symengine/parser/parser_old.cpp	/^        single_arg_functions = {$/;"	m	class:SymEngine::ExpressionParser	file:
single_casted_Eq	symengine/parser/parser.h	/^    single_arg_boolean_func single_casted_Eq = Eq;$/;"	m	class:SymEngine::Parser
single_casted_Eq	symengine/parser/parser_old.cpp	/^    single_arg_boolean_func single_casted_Eq = Eq;$/;"	m	class:SymEngine::ExpressionParser	file:
single_casted_log	symengine/parser/parser.h	/^    single_arg_func single_casted_log = log;$/;"	m	class:SymEngine::Parser
single_casted_log	symengine/parser/parser_old.cpp	/^    single_arg_func single_casted_log = log;$/;"	m	class:SymEngine::ExpressionParser	file:
single_casted_zeta	symengine/parser/parser.h	/^    single_arg_func single_casted_zeta = zeta;$/;"	m	class:SymEngine::Parser
single_casted_zeta	symengine/parser/parser_old.cpp	/^    single_arg_func single_casted_zeta = zeta;$/;"	m	class:SymEngine::ExpressionParser	file:
sinh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> sinh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
sinh	symengine/functions.cpp	/^RCP<const Basic> sinh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
sinh	symengine/series.h	/^    static inline Coeff sinh(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
sinh	symengine/series_generic.cpp	/^Expression UnivariateSeries::sinh(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
sinh	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::sinh(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
sinh_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper sinh_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
size	symengine/fields.h	/^    inline int size() const$/;"	f	class:SymEngine::GaloisField
size	symengine/fields.h	/^    size_t size() const$/;"	f	class:SymEngine::GaloisFieldDict
size	symengine/polys/uintpoly_flint.h	/^    int size() const$/;"	f	class:SymEngine::UFlintPoly
size	symengine/polys/uintpoly_piranha.h	/^    int size() const$/;"	f	class:SymEngine::UPiranhaPoly
size	symengine/polys/upolybase.h	/^    size_t size() const$/;"	f	class:SymEngine::ODictWrapper
size	symengine/polys/usymenginepoly.h	/^    int size() const$/;"	f	class:SymEngine::USymEnginePoly
sizeof	symengine/cwrapper.cpp	/^static_assert(sizeof(CRCPBasic) == sizeof(CRCPBasic_C),$/;"	v
sizer	symengine/utilities/catch/catch.hpp	/^    struct FalseType { char sizer[2]; };$/;"	m	struct:Catch::Detail::FalseType
sizer	symengine/utilities/catch/catch.hpp	/^    struct TrueType { char sizer[1]; };$/;"	m	struct:Catch::Detail::TrueType
sjacobian	symengine/dense_matrix.cpp	/^void sjacobian(const DenseMatrix &A, const DenseMatrix &x, DenseMatrix &result)$/;"	f	namespace:SymEngine
solve	symengine/solve.cpp	/^RCP<const Set> solve(const RCP<const Basic> &f, const RCP<const Symbol> &sym,$/;"	f	namespace:SymEngine
solve_poly	symengine/solve.cpp	/^RCP<const Set> solve_poly(const RCP<const Basic> &f,$/;"	f	namespace:SymEngine
solve_poly_cubic	symengine/solve.cpp	/^RCP<const Set> solve_poly_cubic(const vec_basic &coeffs,$/;"	f	namespace:SymEngine
solve_poly_heuristics	symengine/solve.cpp	/^RCP<const Set> solve_poly_heuristics(const vec_basic &coeffs,$/;"	f	namespace:SymEngine
solve_poly_linear	symengine/solve.cpp	/^RCP<const Set> solve_poly_linear(const vec_basic &coeffs,$/;"	f	namespace:SymEngine
solve_poly_quadratic	symengine/solve.cpp	/^RCP<const Set> solve_poly_quadratic(const vec_basic &coeffs,$/;"	f	namespace:SymEngine
solve_poly_quartic	symengine/solve.cpp	/^RCP<const Set> solve_poly_quartic(const vec_basic &coeffs,$/;"	f	namespace:SymEngine
solve_rational	symengine/solve.cpp	/^RCP<const Set> solve_rational(const RCP<const Basic> &f,$/;"	f	namespace:SymEngine
solve_trig	symengine/solve.cpp	/^RCP<const Set> solve_trig(const RCP<const Basic> &f,$/;"	f	namespace:SymEngine
sorted_keys	symengine/dict.h	/^std::vector<typename M::key_type> sorted_keys(const M &d)$/;"	f	namespace:SymEngine
source_suffix	doc/conf.py	/^source_suffix = '.rst'$/;"	v
sparse_matrix_eq	symengine/cwrapper.cpp	/^int sparse_matrix_eq(CSparseMatrix *lhs, CSparseMatrix *rhs)$/;"	f
sparse_matrix_free	symengine/cwrapper.cpp	/^void sparse_matrix_free(CSparseMatrix *self)$/;"	f
sparse_matrix_get_basic	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE sparse_matrix_get_basic(basic s, const CSparseMatrix *mat,$/;"	f
sparse_matrix_init	symengine/cwrapper.cpp	/^void sparse_matrix_init(CSparseMatrix *s)$/;"	f
sparse_matrix_new	symengine/cwrapper.cpp	/^CSparseMatrix *sparse_matrix_new()$/;"	f
sparse_matrix_rows_cols	symengine/cwrapper.cpp	/^void sparse_matrix_rows_cols(CSparseMatrix *s, unsigned long int rows,$/;"	f
sparse_matrix_set_basic	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE sparse_matrix_set_basic(CSparseMatrix *mat,$/;"	f
sparse_matrix_str	symengine/cwrapper.cpp	/^char *sparse_matrix_str(const CSparseMatrix *s)$/;"	f
split_mul_coef	symengine/printers/latex.cpp	/^bool LatexPrinter::split_mul_coef()$/;"	f	class:SymEngine::LatexPrinter
split_mul_coef	symengine/printers/strprinter.cpp	/^bool StrPrinter::split_mul_coef()$/;"	f	class:SymEngine::StrPrinter
sq2	symengine/constants.cpp	/^RCP<const Basic> sq2 = sqrt_(i2);$/;"	m	namespace:SymEngine	file:
sq3	symengine/constants.cpp	/^RCP<const Basic> sq3 = sqrt_(i3);$/;"	m	namespace:SymEngine	file:
sq5	symengine/constants.cpp	/^RCP<const Basic> sq5 = sqrt_(i5);$/;"	m	namespace:SymEngine	file:
sqrt	symengine/functions.cpp	/^RCP<const Basic> sqrt(RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
sqrt	symengine/pow.h	/^inline RCP<const Basic> sqrt(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
sqrt_	symengine/constants.cpp	/^RCP<const Basic> sqrt_(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine::__anon25
sqrt_	symengine/constants.cpp	/^RCP<const Basic> sqrt_(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine::__anon4
square_expand	symengine/expand.cpp	/^    void square_expand(umap_basic_num &base_dict)$/;"	f	class:SymEngine::ExpandVisitor
ssubs	symengine/subs.h	/^inline RCP<const Basic> ssubs(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
stacktrace2str	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string stacktrace2str(const StacktraceAddresses &stacktrace_addresses)$/;"	f	namespace:__anon22
stacktrace2str	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^std::string stacktrace2str(const StacktraceAddresses &stacktrace_addresses)$/;"	f	namespace:__anon43
stacktrace_buffer	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::vector<bfd_vma> stacktrace_buffer;$/;"	m	class:__anon22::StacktraceAddresses	file:
stacktrace_buffer	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  std::vector<bfd_vma> stacktrace_buffer;$/;"	m	class:__anon43::StacktraceAddresses	file:
standard_deviation	benchmarks/nonius.h++	/^            estimate<double> standard_deviation;$/;"	m	struct:nonius::detail::bootstrap_analysis
standard_deviation	benchmarks/nonius.h++	/^        double standard_deviation(Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
standard_deviation	benchmarks/nonius.h++	/^        estimate<Duration> standard_deviation;$/;"	m	struct:nonius::sample_analysis
standard_reporter	benchmarks/nonius.h++	/^    struct standard_reporter : reporter {$/;"	s	namespace:nonius
startCondition	symengine/parser/scannerbase.h	/^inline ScannerBase::StartCondition__ ScannerBase::startCondition() const$/;"	f	class:SymEngine::ScannerBase
start_	symengine/sets.h	/^    RCP<const Number> start_;$/;"	m	class:SymEngine::Interval
started	benchmarks/nonius.h++	/^            TimePoint<Clock> started;$/;"	m	struct:nonius::detail::final
state__	symengine/parser/scannerbase.h	/^inline size_t ScannerBase::state__() const$/;"	f	class:SymEngine::ScannerBase
std	symengine/basic-inl.h	/^namespace std$/;"	n
std	symengine/basic.h	/^namespace std$/;"	n
std	symengine/parser/scannerbase.h	/^        FinalData std;$/;"	m	struct:SymEngine::ScannerBase::Final
step	symengine/mp_boost.cpp	/^integer_class step(const unsigned long &n, const integer_class &i,$/;"	f	namespace:SymEngine
step_list	symengine/series.h	/^    static inline const std::list<unsigned int> &step_list(unsigned int prec)$/;"	f	class:SymEngine::SeriesBase
stop_	symengine/visitor.h	/^    bool stop_;$/;"	m	class:SymEngine::StopVisitor
stop_arg_tracking	symengine/cse.cpp	/^    void stop_arg_tracking(unsigned func_i)$/;"	f	class:SymEngine::FuncArgTracker
store_stacktrace	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^void Teuchos::store_stacktrace()$/;"	f	class:Teuchos
stored_object	benchmarks/nonius.h++	/^            T& stored_object()$/;"	f	struct:nonius::detail::object_storage
str	symengine/cwrapper.cpp	/^#define str(/;"	d	file:
str	symengine/printers/strprinter.cpp	/^std::string str(const Basic &x)$/;"	f	namespace:SymEngine
str_	symengine/printers/strprinter.h	/^    std::string str_;$/;"	m	class:SymEngine::StrPrinter
stream	symengine/utilities/catch/catch.hpp	/^        CopyableStream &stream()$/;"	f	class:Catch::ResultBuilder
strength	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^ERCPStrength RCP<T>::strength() const$/;"	f	class:Teuchos::RCP
strength	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ERCPStrength strength() const$/;"	f	class:Teuchos::RCPNodeHandle
strength_	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ERCPStrength strength_;$/;"	m	class:Teuchos::RCPNodeHandle
string	symengine/parser/parserbase.h	/^    string,$/;"	m	class:SymEngine::Tag__
stringize	symengine/symengine_assert.h	/^#define stringize(/;"	d
strong_count	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^int RCP<T>::strong_count() const$/;"	f	class:Teuchos::RCP
strong_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int strong_count() const$/;"	f	class:Teuchos::RCPNode
strong_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int strong_count() const$/;"	f	class:Teuchos::RCPNodeHandle
sub	symengine/add.cpp	/^RCP<const Basic> sub(const RCP<const Basic> &a, const RCP<const Basic> &b)$/;"	f	namespace:SymEngine
sub	symengine/complex.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::Complex
sub	symengine/complex_double.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::ComplexDouble
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const Complex &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const ComplexMPC &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const Integer &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const Rational &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.cpp	/^RCP<const Number> ComplexMPC::sub(const RealMPFR &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/complex_mpc.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::ComplexMPC
sub	symengine/integer.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::Integer
sub	symengine/number.cpp	/^RCP<const Number> Number::sub(const Number &other) const$/;"	f	class:SymEngine::Number
sub	symengine/rational.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::Rational
sub	symengine/real_double.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::RealDouble
sub	symengine/real_mpfr.h	/^    virtual RCP<const Number> sub(const Number &other) const$/;"	f	class:SymEngine::RealMPFR
sub_mpoly	symengine/polys/msymenginepoly.h	/^RCP<const Poly> sub_mpoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
sub_upoly	symengine/polys/upolybase.h	/^RCP<const Poly> sub_upoly(const Poly &a, const Poly &b)$/;"	f	namespace:SymEngine
subcomp	symengine/complex.h	/^    inline RCP<const Number> subcomp(const Complex &other) const$/;"	f	class:SymEngine::Complex
subcomp	symengine/complex.h	/^    inline RCP<const Number> subcomp(const Integer &other) const$/;"	f	class:SymEngine::Complex
subcomp	symengine/complex.h	/^    inline RCP<const Number> subcomp(const Rational &other) const$/;"	f	class:SymEngine::Complex
subcomp	symengine/complex_double.h	/^    RCP<const Number> subcomp(const Complex &other) const$/;"	f	class:SymEngine::ComplexDouble
subcomp	symengine/complex_double.h	/^    RCP<const Number> subcomp(const ComplexDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
subcomp	symengine/complex_double.h	/^    RCP<const Number> subcomp(const Integer &other) const$/;"	f	class:SymEngine::ComplexDouble
subcomp	symengine/complex_double.h	/^    RCP<const Number> subcomp(const Rational &other) const$/;"	f	class:SymEngine::ComplexDouble
subcomp	symengine/complex_double.h	/^    RCP<const Number> subcomp(const RealDouble &other) const$/;"	f	class:SymEngine::ComplexDouble
subint	symengine/integer.h	/^    inline RCP<const Integer> subint(const Integer &other) const$/;"	f	class:SymEngine::Integer
submatrix	symengine/dense_matrix.cpp	/^void DenseMatrix::submatrix(MatrixBase &result, unsigned row_start,$/;"	f	class:SymEngine::DenseMatrix
submatrix	symengine/sparse_matrix.cpp	/^void CSRMatrix::submatrix(MatrixBase &result, unsigned row_start,$/;"	f	class:SymEngine::CSRMatrix
submatrix_dense	symengine/dense_matrix.cpp	/^void submatrix_dense(const DenseMatrix &A, DenseMatrix &B, unsigned row_start,$/;"	f	namespace:SymEngine
subnum	symengine/number.h	/^inline RCP<const Number> subnum(const RCP<const Number> &self,$/;"	f	namespace:SymEngine
subrat	symengine/rational.h	/^    inline RCP<const Number> subrat(const Integer &other) const$/;"	f	class:SymEngine::Rational
subrat	symengine/rational.h	/^    inline RCP<const Number> subrat(const Rational &other) const$/;"	f	class:SymEngine::Rational
subreal	symengine/real_double.h	/^    RCP<const Number> subreal(const Complex &other) const$/;"	f	class:SymEngine::RealDouble
subreal	symengine/real_double.h	/^    RCP<const Number> subreal(const Integer &other) const$/;"	f	class:SymEngine::RealDouble
subreal	symengine/real_double.h	/^    RCP<const Number> subreal(const Rational &other) const$/;"	f	class:SymEngine::RealDouble
subreal	symengine/real_double.h	/^    RCP<const Number> subreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealDouble
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const Complex &other) const$/;"	f	class:SymEngine::RealMPFR
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const ComplexDouble &other) const$/;"	f	class:SymEngine::RealMPFR
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const Integer &other) const$/;"	f	class:SymEngine::RealMPFR
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const Rational &other) const$/;"	f	class:SymEngine::RealMPFR
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const RealDouble &other) const$/;"	f	class:SymEngine::RealMPFR
subreal	symengine/real_mpfr.cpp	/^RCP<const Number> RealMPFR::subreal(const RealMPFR &other) const$/;"	f	class:SymEngine::RealMPFR
subs	symengine/basic.cpp	/^RCP<const Basic> Basic::subs(const map_basic_basic &subs_dict) const$/;"	f	class:SymEngine::Basic
subs	symengine/cse.cpp	/^    umap_basic_basic &subs;$/;"	m	class:SymEngine::RebuildVisitor	file:
subs	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper subs(const fmpq_poly_wrapper &o, unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
subs	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::subs(const fqp_t &s, const fqp_t &var, const fqp_t &r,$/;"	f	class:SymEngine::URatPSeriesFlint
subs	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::subs(const UExprDict &s, const UExprDict &var,$/;"	f	class:SymEngine::UnivariateSeries
subs	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::subs(const p_expr &s, const p_expr &var,$/;"	f	class:SymEngine::UPSeriesPiranha
subs	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::subs(const pp_t &s, const pp_t &var, const pp_t &r,$/;"	f	class:SymEngine::URatPSeriesPiranha
subs	symengine/subs.h	/^inline RCP<const Basic> subs(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
subs_dict_	symengine/subs.h	/^    const map_basic_basic &subs_dict_;$/;"	m	class:SymEngine::XReplaceVisitor
suite_complete	benchmarks/nonius.h++	/^        void suite_complete() {$/;"	f	struct:nonius::reporter
suite_start	benchmarks/nonius.h++	/^        void suite_start() {$/;"	f	struct:nonius::reporter
summary	benchmarks/nonius.h++	/^        bool summary = false;$/;"	m	struct:nonius::configuration
summary	benchmarks/nonius.h++	/^        bool summary = false;$/;"	m	struct:nonius::standard_reporter
swap	symengine/utilities/catch/catch.hpp	/^        void swap( Ptr& other ) { std::swap( m_p, other.m_p ); }$/;"	f	class:Catch::Ptr
swap	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^void RCP<T>::swap(RCP<T> &r_ptr)$/;"	f	class:Teuchos::RCP
swap	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  void swap( RCPNodeHandle& node_ref )$/;"	f	class:Teuchos::RCPNodeHandle
swap	symengine/utilities/teuchos/Teuchos_any.hpp	/^  any & swap(any & rhs)$/;"	f	class:Teuchos::any
swap_fmpz_poly_t	symengine/flint_wrapper.h	/^    void swap_fmpz_poly_t(fmpz_poly_struct &other)$/;"	f	class:SymEngine::fmpz_poly_wrapper
switchIstream	symengine/parser/scanner.cpp	/^void ScannerBase::switchIstream(std::string const &infilename)$/;"	f	class:SymEngine::ScannerBase
switchOstream	symengine/parser/scanner.cpp	/^void ScannerBase::switchOstream(std::ostream &out)$/;"	f	class:SymEngine::ScannerBase
switchOstream	symengine/parser/scanner.cpp	/^void ScannerBase::switchOstream(std::string const &outfilename)$/;"	f	class:SymEngine::ScannerBase
switchStream__	symengine/parser/scanner.cpp	/^void ScannerBase::switchStream__(std::istream &in, size_t lineNr)$/;"	f	class:SymEngine::ScannerBase
switchStreams	symengine/parser/scanner.cpp	/^void ScannerBase::switchStreams(std::istream &in, std::ostream &out)$/;"	f	class:SymEngine::ScannerBase
switchStreams	symengine/parser/scanner.cpp	/^void ScannerBase::switchStreams(std::string const &infilename,$/;"	f	class:SymEngine::ScannerBase
sym	symengine/sets.h	/^    RCP<const Basic> sym;$/;"	m	class:SymEngine::ConditionSet
sym_	symengine/sets.h	/^    RCP<const Basic> sym_;$/;"	m	class:SymEngine::ImageSet
sym_	symengine/solve.cpp	/^    RCP<const Symbol> sym_;$/;"	m	class:SymEngine::InvertComplexVisitor	file:
symbol	symengine/symbol.h	/^inline RCP<const Symbol> symbol(const std::string &name)$/;"	f	namespace:SymEngine
symbol_ptrs	symengine/llvm_double.h	/^    std::vector<llvm::Value *> symbol_ptrs;$/;"	m	class:SymEngine::LLVMDoubleVisitor
symbol_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE symbol_set(basic s, const char *c)$/;"	f
symbol_table	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  asymbol **symbol_table;     \/* Symbol table.  *\/$/;"	m	struct:__anon22::line_data	file:
symbol_table	symengine/utilities/teuchos/Teuchos_stacktrace.cpp	/^  asymbol **symbol_table;     \/* Symbol table.  *\/$/;"	m	struct:__anon43::line_data	file:
symbols	symengine/lambda_double.h	/^    vec_basic symbols;$/;"	m	class:SymEngine::LambdaDoubleVisitor
symbols	symengine/llvm_double.h	/^    vec_basic symbols;$/;"	m	class:SymEngine::LLVMDoubleVisitor
symengine_dir	bin/test_make_install.py	/^symengine_dir = sys.argv[2]$/;"	v
symengine_exceptions_t	symengine/symengine_exception.h	/^} symengine_exceptions_t;$/;"	t	typeref:enum:__anon2
symengine_exceptions_t	symengine/symengine_exception.h	/^} symengine_exceptions_t;$/;"	t	typeref:enum:__anon23
symengine_have_component	symengine/cwrapper.cpp	/^int symengine_have_component(const char *c)$/;"	f
symengine_print_stack_on_segfault	symengine/cwrapper.cpp	/^void symengine_print_stack_on_segfault()$/;"	f
symengine_version	symengine/cwrapper.cpp	/^const char *symengine_version()$/;"	f
t	symengine/utilities/catch/catch.hpp	/^        static T  const&t;$/;"	m	struct:Catch::Detail::IsStreamInsertable
table_eval_double	symengine/eval_double.cpp	/^const static std::vector<fn> table_eval_double = init_eval_double();$/;"	m	namespace:SymEngine	file:
tag	symengine/parser/parserbase.h	/^    static Tag__ const tag = Tag__::basic;$/;"	m	struct:SymEngine::Meta__::TagOf
tag	symengine/parser/parserbase.h	/^    static Tag__ const tag = Tag__::basic_vec;$/;"	m	struct:SymEngine::Meta__::TagOf
tag	symengine/parser/parserbase.h	/^    static Tag__ const tag = Tag__::string;$/;"	m	struct:SymEngine::Meta__::TagOf
tag	symengine/parser/parserbase.h	/^inline Tag__ Base::tag() const$/;"	f	class:SymEngine::Meta__::Base
tag	symengine/parser/parserbase.h	/^inline Tag__ SType::tag() const$/;"	f	class:SymEngine::Meta__::SType
tan	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> tan(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
tan	symengine/functions.cpp	/^RCP<const Basic> tan(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
tan	symengine/series.h	/^    static inline Coeff tan(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
tan	symengine/series_generic.cpp	/^Expression UnivariateSeries::tan(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
tan	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::tan(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
tan_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper tan_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
tanh	symengine/complex_mpc.cpp	/^    virtual RCP<const Basic> tanh(const Basic &x) const$/;"	f	class:SymEngine::EvaluateMPC	file:
tanh	symengine/functions.cpp	/^RCP<const Basic> tanh(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
tanh	symengine/series.h	/^    static inline Coeff tanh(const Coeff &c)$/;"	f	class:SymEngine::SeriesBase
tanh	symengine/series_generic.cpp	/^Expression UnivariateSeries::tanh(const Expression &c)$/;"	f	class:SymEngine::UnivariateSeries
tanh	symengine/series_piranha.cpp	/^Expression UPSeriesPiranha::tanh(const Expression &c)$/;"	f	class:SymEngine::UPSeriesPiranha
tanh_series	symengine/flint_wrapper.h	/^    fmpq_poly_wrapper tanh_series(unsigned int prec) const$/;"	f	class:SymEngine::fmpq_poly_wrapper
template_string	benchmarks/nonius.h++	/^        static std::string const& template_string() {$/;"	f	class:nonius::html_reporter::std
templates_path	doc/conf.py	/^templates_path = ['_templates']$/;"	v
test_CMapBasicBasic	symengine/tests/cwrapper/test_cwrapper.c	/^void test_CMapBasicBasic()$/;"	f
test_CSetBasic	symengine/tests/cwrapper/test_cwrapper.c	/^void test_CSetBasic()$/;"	f
test_CVecBasic	symengine/tests/cwrapper/test_cwrapper.c	/^void test_CVecBasic()$/;"	f
test_CVectorInt1	symengine/tests/cwrapper/test_cwrapper.c	/^void test_CVectorInt1()$/;"	f
test_CVectorInt2	symengine/tests/cwrapper/test_cwrapper.c	/^void test_CVectorInt2()$/;"	f
test_ascii_art	symengine/tests/cwrapper/test_cwrapper.c	/^void test_ascii_art()$/;"	f
test_basic	symengine/tests/cwrapper/test_cwrapper.c	/^void test_basic()$/;"	f
test_coeff	symengine/tests/cwrapper/test_cwrapper.c	/^void test_coeff()$/;"	f
test_complex	symengine/tests/cwrapper/test_cwrapper.c	/^void test_complex()$/;"	f
test_complex_double	symengine/tests/cwrapper/test_cwrapper.c	/^void test_complex_double()$/;"	f
test_complex_mpc	symengine/tests/cwrapper/test_cwrapper.c	/^void test_complex_mpc()$/;"	f
test_constants	symengine/tests/cwrapper/test_cwrapper.c	/^void test_constants()$/;"	f
test_cse	symengine/tests/cwrapper/test_cwrapper.c	/^void test_cse()$/;"	f
test_cwrapper	symengine/tests/cwrapper/test_cwrapper.c	/^void test_cwrapper()$/;"	f
test_eval	symengine/tests/cwrapper/test_cwrapper.c	/^void test_eval()$/;"	f
test_free_symbols	symengine/tests/cwrapper/test_cwrapper.c	/^void test_free_symbols()$/;"	f
test_function_symbol_get_name	symengine/tests/cwrapper/test_cwrapper.c	/^void test_function_symbol_get_name()$/;"	f
test_function_symbols	symengine/tests/cwrapper/test_cwrapper.c	/^void test_function_symbols()$/;"	f
test_functions	symengine/tests/cwrapper/test_cwrapper.c	/^void test_functions()$/;"	f
test_get_args	symengine/tests/cwrapper/test_cwrapper.c	/^void test_get_args()$/;"	f
test_get_type	symengine/tests/cwrapper/test_cwrapper.c	/^void test_get_type()$/;"	f
test_hash	symengine/tests/cwrapper/test_cwrapper.c	/^void test_hash()$/;"	f
test_infinity	symengine/tests/cwrapper/test_cwrapper.c	/^void test_infinity()$/;"	f
test_lambda_double	symengine/tests/cwrapper/test_cwrapper.c	/^void test_lambda_double()$/;"	f
test_linsolve	symengine/tests/cwrapper/test_cwrapper.c	/^void test_linsolve()$/;"	f
test_matrix	symengine/tests/cwrapper/test_cwrapper.c	/^void test_matrix()$/;"	f
test_nan	symengine/tests/cwrapper/test_cwrapper.c	/^void test_nan()$/;"	f
test_ntheory	symengine/tests/cwrapper/test_cwrapper.c	/^void test_ntheory()$/;"	f
test_real_double	symengine/tests/cwrapper/test_cwrapper.c	/^void test_real_double()$/;"	f
test_real_mpfr	symengine/tests/cwrapper/test_cwrapper.c	/^void test_real_mpfr()$/;"	f
test_solve_poly	symengine/tests/cwrapper/test_cwrapper.c	/^void test_solve_poly()$/;"	f
test_subs	symengine/tests/cwrapper/test_cwrapper.c	/^void test_subs()$/;"	f
test_subs2	symengine/tests/cwrapper/test_cwrapper.c	/^void test_subs2()$/;"	f
test_version	symengine/tests/cwrapper/test_cwrapper.c	/^void test_version()$/;"	f
teuchos_handle	symengine/cwrapper.h	/^    void *teuchos_handle;$/;"	m	struct:CRCPBasic_C
teuchos_strength	symengine/cwrapper.h	/^    int teuchos_strength;$/;"	m	struct:CRCPBasic_C
texinfo_documents	doc/conf.py	/^texinfo_documents = [$/;"	v
the_base	symengine/polys/basic_conversions.cpp	/^    RCP<const Basic> the_base;$/;"	m	class:SymEngine::PolyGeneratorVisitorPow	file:
throwNumber	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^int throwNumber = 0;$/;"	m	namespace:__anon21	file:
throwNumber	symengine/utilities/teuchos/Teuchos_TestForException.cpp	/^int throwNumber = 0;$/;"	m	namespace:__anon42	file:
throw_invalid_obj_exception	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  virtual void throw_invalid_obj_exception($/;"	f	class:Teuchos::RCPNodeTmpl
throw_null	symengine/utilities/teuchos/Teuchos_Ptr.cpp	/^void Teuchos::PtrPrivateUtilityPack::throw_null( const std::string &type_name )$/;"	f	class:Teuchos::PtrPrivateUtilityPack
throw_null_ptr_error	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void Teuchos::throw_null_ptr_error( const std::string &type_name )$/;"	f	class:Teuchos
time	bin/appveyor-download.cmd	/^set time=0$/;"	v
timeout_error	benchmarks/nonius.h++	/^        timeout_error(int seed, int iters) {$/;"	f	struct:nonius::timeout_error
timeout_error	benchmarks/nonius.h++	/^    struct timeout_error : virtual std::exception {$/;"	s	namespace:nonius
timing	benchmarks/nonius.h++	/^    struct timing {$/;"	s	namespace:nonius
title	benchmarks/nonius.h++	/^        std::string title = "benchmarks";$/;"	m	struct:nonius::configuration
title	benchmarks/nonius.h++	/^        std::string title;$/;"	m	struct:nonius::html_reporter
title	benchmarks/nonius.h++	/^        std::string title;$/;"	m	struct:nonius::junit_reporter
toString	symengine/utilities/catch/catch.hpp	/^            std::string toString() const {$/;"	f	class:Catch::Matchers::Impl::MatcherUntypedBase
toString	symengine/utilities/catch/catch.hpp	/^std::string toString( std::vector<T,Allocator> const& v ) {$/;"	f	namespace:Catch
toString	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  static std::string toString( const ERCPStrength &t )$/;"	f	class:Teuchos::ToStringTraits
toString	symengine/utilities/teuchos/Teuchos_any.hpp	/^inline std::string toString(const any &rhs)$/;"	f	namespace:Teuchos
toString	symengine/utilities/teuchos/Teuchos_toString.hpp	/^  static std::string toString( const T &t )$/;"	f	class:Teuchos::ToStringTraits
toString	symengine/utilities/teuchos/Teuchos_toString.hpp	/^  static std::string toString( const bool &t )$/;"	f	class:Teuchos::ToStringTraits
toString	symengine/utilities/teuchos/Teuchos_toString.hpp	/^  static std::string toString( const std::string &t )$/;"	f	class:Teuchos::ToStringTraits
toString	symengine/utilities/teuchos/Teuchos_toString.hpp	/^std::string toString(const T& t)$/;"	f	namespace:Teuchos
to_eliminate	symengine/cse.cpp	/^    set_basic &to_eliminate;$/;"	m	class:SymEngine::RebuildVisitor	file:
to_mp_class	symengine/polys/upolybase.h	/^inline integer_class to_mp_class(const fz_t &i)$/;"	f	namespace:SymEngine
to_mp_class	symengine/polys/upolybase.h	/^inline integer_class to_mp_class(const integer_class &i)$/;"	f	namespace:SymEngine
to_mp_class	symengine/polys/upolybase.h	/^inline integer_class to_mp_class(const piranha::integer &i)$/;"	f	namespace:SymEngine
to_mp_class	symengine/polys/upolybase.h	/^inline rational_class to_mp_class(const fq_t &i)$/;"	f	namespace:SymEngine
to_mp_class	symengine/polys/upolybase.h	/^inline rational_class to_mp_class(const piranha::rational &i)$/;"	f	namespace:SymEngine
to_mp_class	symengine/polys/upolybase.h	/^inline rational_class to_mp_class(const rational_class &i)$/;"	f	namespace:SymEngine
to_string	symengine/basic-inl.h	/^std::string to_string(const T &value)$/;"	f	namespace:SymEngine
to_string	symengine/flint_wrapper.h	/^    std::string to_string() const$/;"	f	class:SymEngine::fmpq_poly_wrapper
to_string	symengine/flint_wrapper.h	/^    std::string to_string() const$/;"	f	class:SymEngine::fmpz_poly_wrapper
token_ptr	benchmarks/nonius.h++	/^    typedef std::shared_ptr<Token> token_ptr ;$/;"	t	namespace:cpptempl
token_vector	benchmarks/nonius.h++	/^    typedef std::vector<token_ptr> token_vector ;$/;"	t	namespace:cpptempl
tokenize	benchmarks/nonius.h++	/^    inline token_vector & tokenize(std::string text, token_vector &tokens)$/;"	f	namespace:cpptempl
top__	symengine/parser/parser.cpp	/^inline size_t ParserBase::top__() const$/;"	f	class:SymEngine::ParserBase
total	benchmarks/nonius.h++	/^        int total() const {$/;"	f	struct:nonius::outlier_classification
totalNumRCPNodeAllocations	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    long int totalNumRCPNodeAllocations;$/;"	m	struct:Teuchos::RCPNodeTracer::RCPNodeStatistics
totalNumRCPNodeDeletions	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^    long int totalNumRCPNodeDeletions;$/;"	m	struct:Teuchos::RCPNodeTracer::RCPNodeStatistics
total_count	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^int RCP<T>::total_count() const$/;"	f	class:Teuchos::RCP
total_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int total_count() const$/;"	f	class:Teuchos::RCPNodeHandle
totient	symengine/ntheory.cpp	/^RCP<const Integer> totient(const RCP<const Integer> &n)$/;"	f	namespace:SymEngine
translate	symengine/polys/msymenginepoly.h	/^    Wrapper translate(const vec_uint &translator, unsigned int size) const$/;"	f	class:SymEngine::UDictWrapper
transpose	symengine/dense_matrix.cpp	/^void DenseMatrix::transpose(MatrixBase &result) const$/;"	f	class:SymEngine::DenseMatrix
transpose	symengine/sparse_matrix.cpp	/^CSRMatrix CSRMatrix::transpose() const$/;"	f	class:SymEngine::CSRMatrix
transpose	symengine/sparse_matrix.cpp	/^void CSRMatrix::transpose(MatrixBase &result) const$/;"	f	class:SymEngine::CSRMatrix
transpose_dense	symengine/dense_matrix.cpp	/^void transpose_dense(const DenseMatrix &A, DenseMatrix &B)$/;"	f	namespace:SymEngine
tree_cse	symengine/cse.cpp	/^void tree_cse(vec_pair &replacements, vec_basic &reduced_exprs,$/;"	f	namespace:SymEngine
trig_has_basic_shift	symengine/functions.cpp	/^bool trig_has_basic_shift(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
trig_simplify	symengine/functions.cpp	/^bool trig_simplify(const RCP<const Basic> &arg, unsigned period, bool odd,$/;"	f	namespace:SymEngine
trig_to_sqrt	symengine/functions.cpp	/^RCP<const Basic> trig_to_sqrt(const RCP<const Basic> &arg)$/;"	f	namespace:SymEngine
trigamma	symengine/functions.cpp	/^RCP<const Basic> trigamma(const RCP<const Basic> &x)$/;"	f	namespace:SymEngine
trueValue	symengine/utilities/catch/catch.hpp	/^        void trueValue() const {}$/;"	f	class:Catch::SafeBool
truncate	benchmarks/nonius.h++	/^        static double truncate(double x) {$/;"	f	struct:nonius::html_reporter
two_by_two_matrix	symengine/mp_boost.cpp	/^    two_by_two_matrix() : data{{0, 0}, {0, 0}}$/;"	f	struct:SymEngine::two_by_two_matrix
two_by_two_matrix	symengine/mp_boost.cpp	/^    two_by_two_matrix(integer_class a, integer_class b, integer_class c,$/;"	f	struct:SymEngine::two_by_two_matrix
two_by_two_matrix	symengine/mp_boost.cpp	/^struct two_by_two_matrix {$/;"	s	namespace:SymEngine	file:
type	benchmarks/nonius.h++	/^        struct complete_type<void> { struct type {}; };$/;"	s	struct:nonius::detail::complete_type
type	symengine/mp_class.h	/^    typedef SymEngine::integer_class type;$/;"	t	struct:boost::detail::make_unsigned_imp
type	symengine/parser/parserbase.h	/^    typedef RCP<const Basic> type;$/;"	t	struct:SymEngine::Meta__::TypeOf
type	symengine/parser/parserbase.h	/^    typedef std::string type;$/;"	t	struct:SymEngine::Meta__::TypeOf
type	symengine/parser/parserbase.h	/^    typedef vec_basic type;$/;"	t	struct:SymEngine::Meta__::TypeOf
type	symengine/symengine_casts.h	/^    typedef T type;$/;"	t	struct:SymEngine::remove_reference
type	symengine/utilities/teuchos/Teuchos_any.hpp	/^    const std::type_info & type() const$/;"	f	class:Teuchos::any::holder
type	symengine/utilities/teuchos/Teuchos_any.hpp	/^  const std::type_info & type() const$/;"	f	class:Teuchos::any
typeName	build/cmake/checkcxx11.cpp	/^std::string typeName(const T &t)$/;"	f
typeName	cmake/checkcxx11.cpp	/^std::string typeName(const T &t)$/;"	f
typeName	symengine/symengine_rcp.h	/^std::string typeName(const T &t)$/;"	f	namespace:SymEngine
typeName	symengine/utilities/teuchos/Teuchos_TypeNameTraits.hpp	/^std::string typeName( const T &t )$/;"	f	namespace:Teuchos
typeName	symengine/utilities/teuchos/Teuchos_any.hpp	/^    std::string typeName() const$/;"	f	class:Teuchos::any::holder
typeName	symengine/utilities/teuchos/Teuchos_any.hpp	/^  std::string typeName() const$/;"	f	class:Teuchos::any
type_code_	symengine/basic.h	/^    TypeID type_code_;$/;"	m	class:SymEngine::Basic
uexpr_poly	symengine/polys/uexprpoly.h	/^inline RCP<const UExprPoly> uexpr_poly(RCP<const Basic> i, UExprDict &&dict)$/;"	f	namespace:SymEngine
uexpr_poly	symengine/polys/uexprpoly.h	/^inline RCP<const UExprPoly> uexpr_poly(RCP<const Basic> i, map_int_Expr &&dict)$/;"	f	namespace:SymEngine
umap_basic_basic	symengine/dict.h	/^    umap_basic_basic;$/;"	t	namespace:SymEngine
umap_basic_num	symengine/dict.h	/^    umap_basic_num;$/;"	t	namespace:SymEngine
umap_basic_uint	symengine/dict.h	/^    umap_basic_uint;$/;"	t	namespace:SymEngine
umap_int_basic	symengine/dict.h	/^typedef std::unordered_map<int, RCP<const Basic>> umap_int_basic;$/;"	t	namespace:SymEngine
umap_short_basic	symengine/dict.h	/^typedef std::unordered_map<short, RCP<const Basic>> umap_short_basic;$/;"	t	namespace:SymEngine
umap_uvec_mpz	symengine/dict.h	/^    umap_uvec_mpz;$/;"	t	namespace:SymEngine
umap_vec_expr	symengine/dict.h	/^    umap_vec_expr;$/;"	t	namespace:SymEngine
umap_vec_mpz	symengine/dict.h	/^    umap_vec_mpz;$/;"	t	namespace:SymEngine
unbind	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  inline void unbind() $/;"	f	class:Teuchos::RCPNodeHandle
unbindOne	symengine/utilities/teuchos/Teuchos_RCPNode.cpp	/^void RCPNodeHandle::unbindOne()$/;"	f	class:Teuchos::RCPNodeHandle
unchecked_jacobi	symengine/mp_boost.cpp	/^int unchecked_jacobi(const integer_class &a, const integer_class &n)$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const RCP<const T> &a, const RCP<const U> &b)$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const T &a, const T &b)$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::map<K, V, C> &a,$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::multiset<T, U> &a,$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::pair<T, U> &a, const std::pair<T, U> &b)$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::set<T, U> &a, const std::set<T, U> &b)$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::unordered_map<K, V, H, E> &a,$/;"	f	namespace:SymEngine
unified_compare	symengine/dict.h	/^inline int unified_compare(const std::vector<T> &a, const std::vector<T> &b)$/;"	f	namespace:SymEngine
unified_compare	symengine/expression.h	/^inline int unified_compare(const Expression &a, const Expression &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const RCP<const T> &a, const RCP<const U> &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const T &a, const T &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::map<K, V, C> &a, const std::map<K, V, C> &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::multiset<T, U> &a,$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::pair<T, U> &a, const std::pair<T, U> &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::set<T, U> &a, const std::set<T, U> &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::unordered_map<K, V, H, E> &a,$/;"	f	namespace:SymEngine
unified_eq	symengine/dict.h	/^inline bool unified_eq(const std::vector<T> &a, const std::vector<T> &b)$/;"	f	namespace:SymEngine
unified_eq	symengine/expression.h	/^inline bool unified_eq(const Expression &a, const Expression &b)$/;"	f	namespace:SymEngine
units_for_magnitude	benchmarks/nonius.h++	/^        inline std::string units_for_magnitude(double magnitude) {$/;"	f	namespace:nonius::detail
univariate_series	symengine/series_generic.h	/^univariate_series(RCP<const Symbol> i, unsigned int prec, const UExprDict &s)$/;"	f	namespace:SymEngine
universalset	symengine/sets.h	/^inline RCP<const UniversalSet> universalset()$/;"	f	namespace:SymEngine
universe_	symengine/sets.h	/^    RCP<const Set> universe_;$/;"	m	class:SymEngine::Complement
unordered_compare	symengine/dict.h	/^inline int unordered_compare(const M &a, const M &b)$/;"	f	namespace:SymEngine
unordered_eq	symengine/dict.h	/^inline bool unordered_eq(const T &a, const T &b)$/;"	f	namespace:SymEngine
updateFinals__	symengine/parser/scanner.cpp	/^void ScannerBase::updateFinals__()$/;"	f	class:SymEngine::ScannerBase
update_func_argset	symengine/cse.cpp	/^    void update_func_argset(unsigned func_i,$/;"	f	class:SymEngine::FuncArgTracker
upoly_print	symengine/printers/strprinter.cpp	/^std::string upoly_print(const P &x)$/;"	f	namespace:SymEngine
upper_bound	benchmarks/nonius.h++	/^        Duration upper_bound;$/;"	m	struct:nonius::estimate
uppergamma	symengine/functions.cpp	/^RCP<const Basic> uppergamma(const RCP<const Basic> &s,$/;"	f	namespace:SymEngine
urandomint	symengine/mp_class.h	/^    void urandomint(integer_class &res, const integer_class &a)$/;"	f	class:SymEngine::mp_randstate
use_count	symengine/symengine_rcp.h	/^    unsigned int use_count() const$/;"	f	class:SymEngine::EnableRCPFromThis
user_code	benchmarks/nonius.h++	/^    detail::CompleteType<detail::ResultOf<Fun()>> user_code(reporter& rep, Fun&& fun) {$/;"	f	namespace:nonius
uset_basic	symengine/dict.h	/^    uset_basic;$/;"	t	namespace:SymEngine
v	symengine/visitor.cpp	/^    uset_basic v;$/;"	m	class:SymEngine::FreeSymbolsVisitor	file:
validate_benchmarks	benchmarks/nonius.h++	/^    void validate_benchmarks(Iterator first, Iterator last) {$/;"	f	namespace:nonius
value	symengine/parser/parserbase.h	/^    static Type *value;$/;"	m	struct:SymEngine::Meta__::Initializer
value	symengine/parser/parserbase.h	/^    static constexpr Type *value = 0;$/;"	m	struct:SymEngine::Meta__::Initializer
value	symengine/parser/parserbase.h	/^Type *Initializer<constructible, Type>::value = new Type;$/;"	m	class:SymEngine::Meta__::Initializer
value	symengine/polys/uintpoly_piranha.h	/^    static const bool value = true;$/;"	m	struct:piranha::has_exact_ring_operations
value	symengine/polys/upolybase.h	/^    static const bool value$/;"	m	struct:SymEngine::is_a_UPoly
value	symengine/utilities/catch/catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon18
value	symengine/utilities/catch/catch.hpp	/^        enum { value = sizeof( testStreamable(s << t) ) == sizeof( TrueType ) };$/;"	e	enum:Catch::Detail::IsStreamInsertable::__anon39
value	symengine/utilities/catch/catch.hpp	/^        static const bool value = decltype(test<std::ostream,const T&>(0))::value;$/;"	m	class:Catch::Detail::IsStreamInsertable
value	symengine/visitor.h	/^    static const bool value = std::is_base_of<First, Derived>::value$/;"	m	struct:SymEngine::is_base_of_multiple
value	symengine/visitor.h	/^    static const bool value = std::is_base_of<First, Derived>::value;$/;"	m	struct:SymEngine::is_base_of_multiple
value_number_to_value	symengine/cse.cpp	/^    vec_basic value_number_to_value;$/;"	m	class:SymEngine::FuncArgTracker	file:
value_numbers	symengine/cse.cpp	/^        value_numbers;$/;"	m	class:SymEngine::FuncArgTracker	file:
value_type	symengine/utilities/teuchos/Teuchos_map.hpp	/^  typedef std::pair<Key,T>  value_type;$/;"	t	class:Teuchos::std::map
var	symengine/series_flint.cpp	/^fqp_t URatPSeriesFlint::var(const std::string &s)$/;"	f	class:SymEngine::URatPSeriesFlint
var	symengine/series_generic.cpp	/^UExprDict UnivariateSeries::var(const std::string &s)$/;"	f	class:SymEngine::UnivariateSeries
var	symengine/series_piranha.cpp	/^p_expr UPSeriesPiranha::var(const std::string &s)$/;"	f	class:SymEngine::UPSeriesPiranha
var	symengine/series_piranha.cpp	/^pp_t URatPSeriesPiranha::var(const std::string &s)$/;"	f	class:SymEngine::URatPSeriesPiranha
var	symengine/series_visitor.h	/^    const Poly var;$/;"	m	class:SymEngine::SeriesVisitor
var_	symengine/polys/upolybase.h	/^    RCP<const Basic> var_;$/;"	m	class:SymEngine::UPolyBase
var_	symengine/series.h	/^    const std::string var_;$/;"	m	class:SymEngine::SeriesBase
varname	symengine/series_visitor.h	/^    const std::string varname;$/;"	m	class:SymEngine::SeriesVisitor
vars_	symengine/polys/msymenginepoly.h	/^    set_basic vars_;$/;"	m	class:SymEngine::MSymEnginePoly
vec_	symengine/logic.h	/^    PiecewiseVec vec_;$/;"	m	class:SymEngine::Piecewise
vec_basic	symengine/dict.h	/^typedef std::vector<RCP<const Basic>> vec_basic;$/;"	t	namespace:SymEngine
vec_basic_eq_perm	symengine/dict.cpp	/^bool vec_basic_eq_perm(const vec_basic &a, const vec_basic &b)$/;"	f	namespace:SymEngine
vec_boolean	symengine/logic.h	/^typedef std::vector<RCP<const Boolean>> vec_boolean;$/;"	t	namespace:SymEngine
vec_dense_matrix_eq_perm	symengine/tests/ntheory/test_diophantine.cpp	/^bool vec_dense_matrix_eq_perm(const std::vector<DenseMatrix> &a,$/;"	f
vec_hash	symengine/dict.h	/^struct vec_hash {$/;"	s	namespace:SymEngine
vec_int	symengine/dict.h	/^typedef std::vector<int> vec_int;$/;"	t	namespace:SymEngine
vec_integer	symengine/dict.h	/^typedef std::vector<RCP<const Integer>> vec_integer;$/;"	t	namespace:SymEngine
vec_integer_class	symengine/dict.h	/^typedef std::vector<integer_class> vec_integer_class;$/;"	t	namespace:SymEngine
vec_pair	symengine/dict.h	/^typedef std::vector<std::pair<RCP<const Basic>, RCP<const Basic>>> vec_pair;$/;"	t	namespace:SymEngine
vec_size	symengine/polys/msymenginepoly.h	/^    unsigned int vec_size;$/;"	m	class:SymEngine::UDictWrapper
vec_sym	symengine/dict.h	/^typedef std::vector<RCP<const Symbol>> vec_sym;$/;"	t	namespace:SymEngine
vec_type	symengine/polys/msymenginepoly.h	/^    typedef Vec vec_type;$/;"	t	class:SymEngine::UDictWrapper
vec_uint	symengine/dict.h	/^typedef std::vector<unsigned int> vec_uint;$/;"	t	namespace:SymEngine
vecbasic_erase	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE vecbasic_erase(CVecBasic *self, size_t n)$/;"	f
vecbasic_free	symengine/cwrapper.cpp	/^void vecbasic_free(CVecBasic *self)$/;"	f
vecbasic_get	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE vecbasic_get(CVecBasic *self, size_t n, basic result)$/;"	f
vecbasic_linsolve	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE vecbasic_linsolve(CVecBasic *sol, const CVecBasic *sys,$/;"	f
vecbasic_new	symengine/cwrapper.cpp	/^CVecBasic *vecbasic_new()$/;"	f
vecbasic_push_back	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE vecbasic_push_back(CVecBasic *self, const basic value)$/;"	f
vecbasic_set	symengine/cwrapper.cpp	/^CWRAPPER_OUTPUT_TYPE vecbasic_set(CVecBasic *self, size_t n, const basic s)$/;"	f
vecbasic_size	symengine/cwrapper.cpp	/^size_t vecbasic_size(CVecBasic *self)$/;"	f
vectorint_free	symengine/cwrapper.cpp	/^void vectorint_free(CVectorInt *self)$/;"	f
vectorint_get	symengine/cwrapper.cpp	/^int vectorint_get(CVectorInt *self, int n)$/;"	f
vectorint_new	symengine/cwrapper.cpp	/^CVectorInt *vectorint_new()$/;"	f
vectorint_placement_free	symengine/cwrapper.cpp	/^void vectorint_placement_free(CVectorInt *self)$/;"	f
vectorint_placement_new	symengine/cwrapper.cpp	/^CVectorInt *vectorint_placement_new(void *data)$/;"	f
vectorint_placement_new_check	symengine/cwrapper.cpp	/^int vectorint_placement_new_check(void *data, size_t size)$/;"	f
vectorint_push_back	symengine/cwrapper.cpp	/^void vectorint_push_back(CVectorInt *self, int value)$/;"	f
verbose	benchmarks/nonius.h++	/^        bool verbose = false;$/;"	m	struct:nonius::configuration
verbose	benchmarks/nonius.h++	/^        bool verbose = false;$/;"	m	struct:nonius::standard_reporter
verbose	benchmarks/nonius.h++	/^        bool verbose;$/;"	m	struct:nonius::csv_reporter
verbose	benchmarks/nonius.h++	/^        bool verbose;$/;"	m	struct:nonius::html_reporter
verbose	benchmarks/nonius.h++	/^        bool verbose;$/;"	m	struct:nonius::junit_reporter
version	doc/conf.py	/^version = '0.1'$/;"	v
visited	symengine/visitor.h	/^    uset_basic visited;$/;"	m	class:SymEngine::AtomsVisitor
volatile	build/CMakeFiles/3.13.3/CompilerIdC/CMakeCCompilerId.c	/^# define volatile$/;"	d	file:
warmup	benchmarks/nonius.h++	/^        int warmup() {$/;"	f	namespace:nonius::detail
warmup_end	benchmarks/nonius.h++	/^        void warmup_end(int iterations) {$/;"	f	struct:nonius::reporter
warmup_iterations	benchmarks/nonius.h++	/^        const auto warmup_iterations = 10000;$/;"	m	namespace:nonius::detail
warmup_seed	benchmarks/nonius.h++	/^        const auto warmup_seed = 10000;$/;"	m	namespace:nonius::detail
warmup_start	benchmarks/nonius.h++	/^        void warmup_start() {$/;"	f	struct:nonius::reporter
warmup_time	benchmarks/nonius.h++	/^        const auto warmup_time = chrono::milliseconds(100);$/;"	m	namespace:nonius::detail
weak_count	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^int RCP<T>::weak_count() const$/;"	f	class:Teuchos::RCP
weak_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int weak_count() const$/;"	f	class:Teuchos::RCPNode
weak_count	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  int weak_count() const$/;"	f	class:Teuchos::RCPNodeHandle
weak_self_ptr_	symengine/symengine_rcp.h	/^    mutable RCP<T> weak_self_ptr_;$/;"	m	class:SymEngine::EnableRCPFromThis
weighted_average_quantile	benchmarks/nonius.h++	/^        double weighted_average_quantile(int k, int q, Iterator first, Iterator last) {$/;"	f	namespace:nonius::detail
what	symengine/symengine_exception.h	/^    const char *what() const throw()$/;"	f	class:SymEngine::SymEngineException
what	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^	virtual const char* what() const throw() { return msg.data(); }$/;"	f	class:Teuchos::m_bad_cast
x	symengine/tests/cwrapper/test_cwrapper.c	/^    void *x;$/;"	m	struct:X	file:
x	symengine/tests/rcp/test_rcp.cpp	/^    int x, y;$/;"	m	class:Mesh	file:
x	symengine/tests/rcp/test_rcp.cpp	/^    int x, y;$/;"	m	class:Mesh2	file:
x_	symengine/functions.h	/^    multiset_basic x_; \/\/! x, y, ...$/;"	m	class:SymEngine::Derivative
x_	symengine/matrix.h	/^    vec_basic x_;$/;"	m	class:SymEngine::CSRMatrix
x_	symengine/series_visitor.h	/^    RCP<const Symbol> x_;$/;"	m	class:SymEngine::NeedsSymbolicExpansionVisitor
x_	symengine/solve.cpp	/^    Ptr<const Symbol> x_;$/;"	m	class:SymEngine::IsALinearArgTrigVisitor	file:
x_	symengine/visitor.h	/^    Ptr<const Basic> x_;$/;"	m	class:SymEngine::CoeffVisitor
x_	symengine/visitor.h	/^    Ptr<const Symbol> x_;$/;"	m	class:SymEngine::HasSymbolVisitor
xreplace	symengine/basic.cpp	/^RCP<const Basic> Basic::xreplace(const map_basic_basic &xreplace_dict) const$/;"	f	class:SymEngine::Basic
xreplace	symengine/subs.h	/^inline RCP<const Basic> xreplace(const RCP<const Basic> &x,$/;"	f	namespace:SymEngine
xstr	symengine/cwrapper.cpp	/^#define xstr(/;"	d	file:
y	symengine/tests/rcp/test_rcp.cpp	/^    int x, y;$/;"	m	class:Mesh	file:
y	symengine/tests/rcp/test_rcp.cpp	/^    int x, y;$/;"	m	class:Mesh2	file:
zero	symengine/constants.cpp	/^RCP<const Integer> zero = integer(0);$/;"	m	namespace:SymEngine	file:
zeros	symengine/dense_matrix.cpp	/^void zeros(DenseMatrix &A)$/;"	f	namespace:SymEngine
zeta	symengine/functions.cpp	/^RCP<const Basic> zeta(const RCP<const Basic> &s)$/;"	f	namespace:SymEngine
zeta	symengine/functions.cpp	/^RCP<const Basic> zeta(const RCP<const Basic> &s, const RCP<const Basic> &a)$/;"	f	namespace:SymEngine
~Basic	symengine/basic.h	/^    virtual ~Basic()$/;"	f	class:SymEngine::Basic
~DecomposedExpression	symengine/utilities/catch/catch.hpp	/^        virtual ~DecomposedExpression() {}$/;"	f	struct:Catch::DecomposedExpression
~MatrixBase	symengine/matrix.h	/^    virtual ~MatrixBase(){};$/;"	f	class:SymEngine::MatrixBase
~MethodTestCase	symengine/utilities/catch/catch.hpp	/^    virtual ~MethodTestCase() {}$/;"	f	class:Catch::MethodTestCase
~Ptr	symengine/utilities/catch/catch.hpp	/^        ~Ptr(){$/;"	f	class:Catch::Ptr
~RCP	build/cmake/checkcxx11.cpp	/^    ~RCP() {$/;"	f	class:RCP
~RCP	cmake/checkcxx11.cpp	/^    ~RCP() {$/;"	f	class:RCP
~RCP	symengine/utilities/teuchos/Teuchos_RCP.hpp	/^RCP<T>::~RCP()$/;"	f	class:Teuchos::RCP
~RCPNodeHandle	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ~RCPNodeHandle()$/;"	f	class:Teuchos::RCPNodeHandle
~RCPNodeThrowDeleter	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ~RCPNodeThrowDeleter()$/;"	f	class:Teuchos::RCPNodeThrowDeleter
~RCPNodeTmpl	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ~RCPNodeTmpl()$/;"	f	class:Teuchos::RCPNodeTmpl
~ScannerBase	symengine/parser/scannerbase.h	/^inline ScannerBase::~ScannerBase()$/;"	f	class:SymEngine::ScannerBase
~SetTracingActiveNodesStack	symengine/utilities/teuchos/Teuchos_RCPNode.hpp	/^  ~SetTracingActiveNodesStack()$/;"	f	class:Teuchos::SetTracingActiveNodesStack
~any	symengine/utilities/teuchos/Teuchos_any.hpp	/^  ~any()$/;"	f	class:Teuchos::any
~data_ptr	benchmarks/nonius.h++	/^        virtual ~data_ptr() {}$/;"	f	class:cpptempl::data_ptr
~fmpq_poly_wrapper	symengine/flint_wrapper.h	/^    ~fmpq_poly_wrapper()$/;"	f	class:SymEngine::fmpq_poly_wrapper
~fmpz_poly_factor_wrapper	symengine/flint_wrapper.h	/^    ~fmpz_poly_factor_wrapper()$/;"	f	class:SymEngine::fmpz_poly_factor_wrapper
~fmpz_poly_wrapper	symengine/flint_wrapper.h	/^    ~fmpz_poly_wrapper()$/;"	f	class:SymEngine::fmpz_poly_wrapper
~iterator	symengine/ntheory.cpp	/^Sieve::iterator::~iterator()$/;"	f	class:SymEngine::Sieve::iterator
~m_bad_cast	symengine/utilities/teuchos/Teuchos_dyn_cast.hpp	/^	virtual ~m_bad_cast() throw() {}$/;"	f	class:Teuchos::m_bad_cast
~mp_randstate	symengine/mp_class.h	/^    ~mp_randstate()$/;"	f	class:SymEngine::mp_randstate
~mpc_class	symengine/complex_mpc.h	/^    ~mpc_class()$/;"	f	class:SymEngine::mpc_class
~mpfr_class	symengine/real_mpfr.h	/^    ~mpfr_class()$/;"	f	class:SymEngine::mpfr_class
~mpq_view_flint	symengine/flint_wrapper.h	/^    ~mpq_view_flint()$/;"	f	class:SymEngine::mpq_view_flint
~mpz_view_flint	symengine/flint_wrapper.h	/^    ~mpz_view_flint()$/;"	f	class:SymEngine::mpz_view_flint
~object_storage	benchmarks/nonius.h++	/^            ~object_storage() { destruct_on_exit<T>(); }$/;"	f	struct:nonius::detail::object_storage
~placeholder	symengine/utilities/teuchos/Teuchos_any.hpp	/^    virtual ~placeholder() {}$/;"	f	class:Teuchos::any::placeholder
